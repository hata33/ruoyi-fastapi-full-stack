# è·¯ç”±ä¸è¯·æ±‚å¤„ç†

> æ·±å…¥ç†è§£ FastAPI çš„è·¯ç”±ç³»ç»Ÿï¼ŒæŒæ¡è®¾è®¡è®°è´¦ API çš„æ ¸å¿ƒæŠ€èƒ½

## ğŸ“‹ æœ¬ç« ç›®æ ‡

- [ ] ç†è§£è·¯ç”±çš„å·¥ä½œåŸç†
- [ ] æŒæ¡è·¯å¾„å‚æ•°å’ŒæŸ¥è¯¢å‚æ•°çš„ä½¿ç”¨
- [ ] å­¦ä¼šè¯·æ±‚ä½“ï¼ˆRequest Bodyï¼‰çš„å¤„ç†
- [ ] è®¾è®¡å®Œæ•´çš„è®°è´¦ç³»ç»Ÿ API è·¯ç”±

## ğŸ›£ï¸ è·¯ç”±åŸºç¡€æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯è·¯ç”±ï¼Ÿ

è·¯ç”±æ˜¯ URL è·¯å¾„ä¸å¤„ç†å‡½æ•°ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚å½“å®¢æˆ·ç«¯å‘é€è¯·æ±‚æ—¶ï¼ŒFastAPI æ ¹æ®è·¯ç”±è§„åˆ™æ‰¾åˆ°å¯¹åº”çš„å¤„ç†å‡½æ•°ã€‚

```mermaid
flowchart LR
    subgraph Requests["å®¢æˆ·ç«¯è¯·æ±‚"]
        R1["GET /transactions"]
        R2["POST /transactions"]
        R3["GET /transactions/1"]
    end

    subgraph Router["è·¯ç”±ç³»ç»Ÿ"]
        direction TB
        Match["è·¯ç”±åŒ¹é…å™¨"]
    end

    subgraph Handlers["å¤„ç†å‡½æ•°"]
        H1["list_transactions()"]
        H2["create_transaction()"]
        H3["get_transaction()"]
    end

    R1 --> Match --> H1
    R2 --> Match --> H2
    R3 --> Match --> H3

    style Router fill:#e3f2fd
    style Handlers fill:#c8e6c9
```

### è·¯ç”±æ³¨å†Œæ–¹å¼

```python
from fastapi import FastAPI

app = FastAPI()

# æ–¹å¼ä¸€ï¼šè£…é¥°å™¨ï¼ˆæ¨èï¼‰
@app.get("/path")
def handler():
    return {"message": "Hello"}

# æ–¹å¼äºŒï¼šç›´æ¥è°ƒç”¨æ–¹æ³•
def another_handler():
    return {"message": "World"}

app.add_api_route("/another", another_handler, methods=["GET"])
```

## ğŸ“ è·¯å¾„å‚æ•°ï¼ˆPath Parametersï¼‰

### åŸºæœ¬ç”¨æ³•

```mermaid
flowchart LR
    URL["URL: /transactions/123"] --> Parse["è§£æè·¯å¾„"]
    Parse --> Match{"åŒ¹é…è·¯ç”±"}
    Match --> Extract["æå–å‚æ•°<br/>id = 123"]
    Extract --> Convert["ç±»å‹è½¬æ¢"]
    Convert --> Call["è°ƒç”¨å¤„ç†å‡½æ•°"]

    style URL fill:#fff3e0
    style Call fill:#c8e6c9
```

### ä»£ç ç¤ºä¾‹

```python
from fastapi import FastAPI

app = FastAPI()

# åŸºæœ¬è·¯å¾„å‚æ•°
@app.get("/items/{item_id}")
def read_item(item_id: int):
    return {"item_id": item_id}

# å¤šä¸ªè·¯å¾„å‚æ•°
@app.get("/users/{user_id}/items/{item_id}")
def read_user_item(user_id: int, item_id: int):
    return {"user_id": user_id, "item_id": item_id}

# å¸¦ç±»å‹çš„è·¯å¾„å‚æ•°
@app.get("/transactions/{transaction_id}")
def get_transaction(transaction_id: int):  # è‡ªåŠ¨è½¬æ¢ä¸º int
    return {"transaction_id": transaction_id}
```

### è·¯å¾„å‚æ•°ç±»å‹ä¸éªŒè¯

```mermaid
flowchart LR
    A["è·¯å¾„å‚æ•°ç±»å‹"]

    subgraph Basic["åŸºæœ¬ç±»å‹"]
        direction TB
        B1["str - å­—ç¬¦ä¸²"]
        B2["int - æ•´æ•°"]
        B3["float - æµ®ç‚¹æ•°"]
        B4["bool - å¸ƒå°”å€¼"]
        B5["UUID - å”¯ä¸€æ ‡è¯†"]
    end

    subgraph Enum["æšä¸¾ç±»å‹"]
        C1["Enum - é™å®šå€¼"]
    end

    subgraph Path["è·¯å¾„è½¬æ¢å™¨"]
        D1["path - åŒ…å«æ–œæ "]
    end

    A --> Basic
    A --> Enum
    A --> Path

    style Basic fill:#e8f5e9
    style Enum fill:#fff3e0
    style Path fill:#e3f2fd
```

### æšä¸¾è·¯å¾„å‚æ•°

```python
from enum import Enum
from fastapi import FastAPI

app = FastAPI()

# å®šä¹‰æšä¸¾
class TransactionType(str, Enum):
    income = "income"
    expense = "expense"

# ä½¿ç”¨æšä¸¾é™åˆ¶å‚æ•°å€¼
@app.get("/transactions/type/{transaction_type}")
def get_by_type(transaction_type: TransactionType):
    if transaction_type == TransactionType.income:
        return {"type": "income", "message": "è¿™æ˜¯æ”¶å…¥"}
    return {"type": "expense", "message": "è¿™æ˜¯æ”¯å‡º"}
```

### è·¯å¾„å‚æ•°é¡ºåºè§„åˆ™

```mermaid
flowchart LR
    subgraph Correct["âœ… æ­£ç¡®é¡ºåº"]
        C1["/users/me"] --> C2["/users/{user_id}"]
    end

    subgraph Wrong["âŒ é”™è¯¯é¡ºåº"]
        W1["/users/{user_id}"] --> W2["/users/me æ°¸è¿œä¸åŒ¹é…"]
    end

    style Correct fill:#c8e6c9
    style Wrong fill:#ffcdd2
```

```python
# âœ… æ­£ç¡®ï¼šå›ºå®šè·¯å¾„åœ¨å‰
@app.get("/users/me")
def get_current_user():
    return {"user": "current"}

@app.get("/users/{user_id}")
def get_user(user_id: str):
    return {"user_id": user_id}

# âŒ é”™è¯¯ï¼šåŠ¨æ€è·¯å¾„åœ¨å‰ä¼šæ‹¦æˆªæ‰€æœ‰è¯·æ±‚
# @app.get("/users/{user_id}")  # è¿™ä¼šåŒ¹é… /users/me
# def get_user(user_id: str):
#     return {"user_id": user_id}

# @app.get("/users/me")  # æ°¸è¿œä¸ä¼šè¢«åŒ¹é…
# def get_current_user():
#     return {"user": "current"}
```

## ğŸ” æŸ¥è¯¢å‚æ•°ï¼ˆQuery Parametersï¼‰

### åŸºæœ¬æ¦‚å¿µ

```mermaid
flowchart LR
    URL["/transactions?category=food&limit=10&skip=0"]

    URL --> P1["category=food"]
    URL --> P2["limit=10"]
    URL --> P3["skip=0"]

    P1 --> F1["æŒ‰åˆ†ç±»è¿‡æ»¤"]
    P2 --> F2["é™åˆ¶æ•°é‡"]
    P3 --> F3["è·³è¿‡è®°å½•"]

    style URL fill:#e3f2fd
```

### æŸ¥è¯¢å‚æ•°ç¤ºä¾‹

```python
from fastapi import FastAPI
from typing import Optional

app = FastAPI()

# æ¨¡æ‹Ÿæ•°æ®
transactions = [
    {"id": 1, "category": "food", "amount": 50.0},
    {"id": 2, "category": "transport", "amount": 30.0},
    {"id": 3, "category": "food", "amount": 100.0},
]

# å¿…éœ€çš„æŸ¥è¯¢å‚æ•°
@app.get("/items")
def read_items(item_id: int):  # æ²¡æœ‰é»˜è®¤å€¼ï¼Œå¿…éœ€
    return {"item_id": item_id}

# å¯é€‰çš„æŸ¥è¯¢å‚æ•°
@app.get("/search")
def search(keyword: Optional[str] = None):  # æœ‰é»˜è®¤å€¼ï¼Œå¯é€‰
    if keyword:
        return {"keyword": keyword}
    return {"message": "è¯·è¾“å…¥æœç´¢å…³é”®è¯"}

# å¤šä¸ªæŸ¥è¯¢å‚æ•° + åˆ†é¡µ
@app.get("/transactions")
def list_transactions(
    category: Optional[str] = None,  # å¯é€‰è¿‡æ»¤
    min_amount: Optional[float] = None,  # æœ€å°é‡‘é¢
    skip: int = 0,    # é»˜è®¤å€¼ï¼Œåˆ†é¡µåç§»
    limit: int = 10,  # é»˜è®¤å€¼ï¼Œæ¯é¡µæ•°é‡
):
    result = transactions

    # è¿‡æ»¤é€»è¾‘
    if category:
        result = [t for t in result if t["category"] == category]
    if min_amount:
        result = [t for t in result if t["amount"] >= min_amount]

    # åˆ†é¡µ
    return {
        "data": result[skip : skip + limit],
        "total": len(result),
        "skip": skip,
        "limit": limit
    }
```

### æŸ¥è¯¢å‚æ•°éªŒè¯

```mermaid
flowchart LR
    subgraph Fail["éªŒè¯å¤±è´¥ç¤ºä¾‹"]
        Request["/items?limit=abc"] --> Validate["å‚æ•°éªŒè¯"]
        Validate --> Error["âŒ ç±»å‹é”™è¯¯"]
        Error --> Response["HTTP 422"]
    end

    subgraph Pass["éªŒè¯æˆåŠŸç¤ºä¾‹"]
        Request2["/items?limit=50"] --> Validate2["å‚æ•°éªŒè¯"]
        Validate2 --> RangeCheck["èŒƒå›´æ£€æŸ¥"]
        RangeCheck --> AutoFix["è‡ªåŠ¨è°ƒæ•´ä¸ºæœ€å¤§å€¼"]
    end

    style Fail fill:#ffcdd2
    style Pass fill:#c8e6c9
```

```python
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items")
def read_items(
    # æ·»åŠ éªŒè¯è§„åˆ™
    q: Optional[str] = Query(
        None,  # é»˜è®¤å€¼
        min_length=3,     # æœ€å°é•¿åº¦
        max_length=50,    # æœ€å¤§é•¿åº¦
        title="æœç´¢å…³é”®è¯",
        description="ç”¨äºæœç´¢å•†å“çš„å…³é”®è¯ï¼Œ3-50ä¸ªå­—ç¬¦"
    ),
    limit: int = Query(
        10,  # é»˜è®¤å€¼
        gt=0,      # å¤§äº 0
        le=100,    # å°äºç­‰äº 100
        description="è¿”å›ç»“æœæ•°é‡é™åˆ¶"
    ),
    skip: int = Query(0, ge=0),  # å¤§äºç­‰äº 0
):
    return {"q": q, "limit": limit, "skip": skip}

# å¿…éœ€çš„æŸ¥è¯¢å‚æ•°ï¼ˆä½¿ç”¨ ... ä½œä¸ºé»˜è®¤å€¼ï¼‰
@app.get("/required-query")
def required_query(
    token: str = Query(..., min_length=10, description="è®¤è¯ä»¤ç‰Œ")
):
    return {"token": token}
```

### æŸ¥è¯¢å‚æ•°éªŒè¯è§„åˆ™

```mermaid
graph LR
    subgraph Numbers["æ•°å€¼éªŒè¯"]
        N1["gt - å¤§äº"]
        N2["ge - å¤§äºç­‰äº"]
        N3["lt - å°äº"]
        N4["le - å°äºç­‰äº"]
    end

    subgraph Strings["å­—ç¬¦ä¸²éªŒè¯"]
        S1["min_length - æœ€å°é•¿åº¦"]
        S2["max_length - æœ€å¤§é•¿åº¦"]
        S3["regex - æ­£åˆ™åŒ¹é…"]
    end

    subgraph Lists["åˆ—è¡¨éªŒè¯"]
        L1["min_items - æœ€å°‘é¡¹æ•°"]
        L2["max_items - æœ€å¤šé¡¹æ•°"]
    end

    style Numbers fill:#e8f5e9
    style Strings fill:#fff3e0
    style Lists fill:#e3f2fd
```

## ğŸ“¦ è¯·æ±‚ä½“ï¼ˆRequest Bodyï¼‰

### è¯·æ±‚ä½“æ¦‚å¿µ

```mermaid
sequenceDiagram
    participant Client as å®¢æˆ·ç«¯
    participant API as FastAPI
    participant Validator as éªŒè¯å™¨
    participant Handler as å¤„ç†å‡½æ•°

    Client->>API: POST /transactions<br/>Body: JSON æ•°æ®
    API->>Validator: è§£æè¯·æ±‚ä½“
    Validator->>Validator: éªŒè¯æ•°æ®æ ¼å¼
    alt éªŒè¯æˆåŠŸ
        Validator->>Handler: ä¼ é€’éªŒè¯åçš„å¯¹è±¡
        Handler-->>Client: 200 OK
    else éªŒè¯å¤±è´¥
        Validator-->>Client: 422 é”™è¯¯è¯¦æƒ…
    end
```

### Pydantic æ¨¡å‹å®šä¹‰

```python
from fastapi import FastAPI
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional

app = FastAPI()

# å®šä¹‰è¯·æ±‚ä½“æ¨¡å‹
class TransactionCreate(BaseModel):
    amount: float = Field(..., gt=0, description="äº¤æ˜“é‡‘é¢ï¼Œå¿…é¡»å¤§äº0")
    category: str = Field(..., min_length=1, max_length=50, description="äº¤æ˜“åˆ†ç±»")
    note: Optional[str] = Field("", max_length=200, description="å¤‡æ³¨")
    transaction_date: Optional[datetime] = Field(
        None,
        description="äº¤æ˜“æ—¥æœŸï¼Œé»˜è®¤ä¸ºå½“å‰æ—¶é—´"
    )

    class Config:
        # ç¤ºä¾‹æ•°æ®ï¼Œç”¨äº API æ–‡æ¡£
        json_schema_extra = {
            "example": {
                "amount": 99.9,
                "category": "é¤é¥®",
                "note": "åˆé¤",
                "transaction_date": "2024-01-15T12:00:00"
            }
        }

# ä½¿ç”¨è¯·æ±‚ä½“
@app.post("/transactions")
def create_transaction(transaction: TransactionCreate):
    # transaction æ˜¯å·²éªŒè¯çš„ Pydantic å¯¹è±¡
    return {
        "message": "åˆ›å»ºæˆåŠŸ",
        "data": transaction.model_dump()
    }
```

### è¯·æ±‚ä½“ + è·¯å¾„å‚æ•° + æŸ¥è¯¢å‚æ•°

```mermaid
flowchart LR
    Request["POST /users/123/transactions?notify=true"]

    Request --> Path["è·¯å¾„å‚æ•°<br/>user_id = 123"]
    Request --> Query["æŸ¥è¯¢å‚æ•°<br/>notify = true"]
    Request --> Body["è¯·æ±‚ä½“<br/>JSON æ•°æ®"]

    Path --> Handler["å¤„ç†å‡½æ•°"]
    Query --> Handler
    Body --> Handler

    Handler --> Response["ç»„åˆå¤„ç†"]

    style Request fill:#e3f2fd
    style Handler fill:#c8e6c9
```

```python
from fastapi import FastAPI, Path, Query
from pydantic import BaseModel

app = FastAPI()

class Transaction(BaseModel):
    amount: float
    category: str
    note: str = ""

@app.post("/users/{user_id}/transactions")
def create_user_transaction(
    # è·¯å¾„å‚æ•°
    user_id: int = Path(..., gt=0, description="ç”¨æˆ·ID"),
    # æŸ¥è¯¢å‚æ•°
    notify: bool = Query(False, description="æ˜¯å¦å‘é€é€šçŸ¥"),
    # è¯·æ±‚ä½“
    transaction: Transaction = None,
):
    return {
        "user_id": user_id,
        "notify": notify,
        "transaction": transaction
    }
```

### å¤šä¸ªè¯·æ±‚ä½“å‚æ•°

```python
from fastapi import FastAPI, Body
from pydantic import BaseModel

app = FastAPI()

class User(BaseModel):
    username: str
    email: str

class Transaction(BaseModel):
    amount: float
    category: str

# å•ä¸ªè¯·æ±‚ä½“ï¼ˆé»˜è®¤ï¼‰
@app.post("/transaction")
def create_transaction(transaction: Transaction):
    return transaction

# å¤šä¸ªè¯·æ±‚ä½“ï¼ˆéœ€è¦ç”¨ Body åµŒå…¥ï¼‰
@app.post("/user-with-transaction")
def create_user_transaction(
    user: User,
    transaction: Transaction,
    importance: int = Body(...)  # å•ä¸ªå€¼ä½œä¸ºè¯·æ±‚ä½“
):
    return {
        "user": user,
        "transaction": transaction,
        "importance": importance
    }

# è¯·æ±‚ä½“ç¤ºä¾‹ï¼š
# {
#     "user": {"username": "john", "email": "john@example.com"},
#     "transaction": {"amount": 100, "category": "food"},
#     "importance": 5
# }
```

## ğŸ—ï¸ è®°è´¦ç³»ç»Ÿè·¯ç”±è®¾è®¡

### å®Œæ•´è·¯ç”±æ¶æ„

```mermaid
flowchart TB
    subgraph API["è®°è´¦ç³»ç»Ÿ API"]
        Root["/"]

        subgraph Transactions["/transactions äº¤æ˜“ç®¡ç†"]
            T1["GET / - åˆ—è¡¨"]
            T2["POST / - åˆ›å»º"]
            T3["GET /{id} - è¯¦æƒ…"]
            T4["PUT /{id} - æ›´æ–°"]
            T5["DELETE /{id} - åˆ é™¤"]
            T6["GET /stats - ç»Ÿè®¡"]
        end

        subgraph Categories["/categories åˆ†ç±»ç®¡ç†"]
            C1["GET / - åˆ—è¡¨"]
            C2["POST / - åˆ›å»º"]
            C3["PUT /{id} - æ›´æ–°"]
            C4["DELETE /{id} - åˆ é™¤"]
        end

        subgraph Accounts["/accounts è´¦æˆ·ç®¡ç†"]
            A1["GET / - åˆ—è¡¨"]
            A2["POST / - åˆ›å»º"]
            A3["GET /{id}/balance - ä½™é¢"]
        end
    end

    Root --> Transactions
    Root --> Categories
    Root --> Accounts

    style API fill:#f5f5f5
    style Transactions fill:#e8f5e9
    style Categories fill:#fff3e0
    style Accounts fill:#e3f2fd
```

### è·¯ç”±æ¨¡å—åŒ–

```mermaid
flowchart LR
    Main["main.py<br/>ä¸»åº”ç”¨"] --> Router1["transactions.py"]
    Main --> Router2["categories.py"]
    Main --> Router3["accounts.py"]

    Router1 --> Endpoints1["5 ä¸ªç«¯ç‚¹"]
    Router2 --> Endpoints2["4 ä¸ªç«¯ç‚¹"]
    Router3 --> Endpoints3["3 ä¸ªç«¯ç‚¹"]

    style Main fill:#e3f2fd
    style Router1 fill:#c8e6c9
    style Router2 fill:#c8e6c9
    style Router3 fill:#c8e6c9
```

### æ¨¡å—åŒ–ä»£ç å®ç°

```python
# routers/transactions.py
from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from typing import List, Optional

router = APIRouter(
    prefix="/transactions",
    tags=["äº¤æ˜“ç®¡ç†"],
    responses={404: {"description": "æœªæ‰¾åˆ°"}}
)

# æ•°æ®æ¨¡å‹
class Transaction(BaseModel):
    id: Optional[int] = None
    amount: float
    category: str
    note: str = ""
    account_id: int

class TransactionCreate(BaseModel):
    amount: float
    category: str
    note: str = ""
    account_id: int

class TransactionUpdate(BaseModel):
    amount: Optional[float] = None
    category: Optional[str] = None
    note: Optional[str] = None

# æ¨¡æ‹Ÿæ•°æ®åº“
transactions_db = []
transaction_id_counter = 0

@router.get("", response_model=List[Transaction])
def list_transactions(
    category: Optional[str] = Query(None, description="æŒ‰åˆ†ç±»ç­›é€‰"),
    account_id: Optional[int] = Query(None, description="æŒ‰è´¦æˆ·ç­›é€‰"),
    min_amount: Optional[float] = Query(None, ge=0, description="æœ€å°é‡‘é¢"),
    max_amount: Optional[float] = Query(None, ge=0, description="æœ€å¤§é‡‘é¢"),
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
):
    """
    è·å–äº¤æ˜“è®°å½•åˆ—è¡¨

    - **category**: æŒ‰åˆ†ç±»ç­›é€‰
    - **account_id**: æŒ‰è´¦æˆ·ç­›é€‰
    - **min_amount/max_amount**: é‡‘é¢èŒƒå›´
    - **skip/limit**: åˆ†é¡µå‚æ•°
    """
    result = transactions_db

    if category:
        result = [t for t in result if t["category"] == category]
    if account_id:
        result = [t for t in result if t["account_id"] == account_id]
    if min_amount is not None:
        result = [t for t in result if t["amount"] >= min_amount]
    if max_amount is not None:
        result = [t for t in result if t["amount"] <= max_amount]

    return result[skip:skip+limit]

@router.post("", response_model=Transaction, status_code=201)
def create_transaction(transaction: TransactionCreate):
    """åˆ›å»ºæ–°çš„äº¤æ˜“è®°å½•"""
    global transaction_id_counter
    transaction_id_counter += 1

    new_transaction = transaction.model_dump()
    new_transaction["id"] = transaction_id_counter

    transactions_db.append(new_transaction)
    return new_transaction

@router.get("/stats")
def get_statistics():
    """è·å–äº¤æ˜“ç»Ÿè®¡ä¿¡æ¯"""
    if not transactions_db:
        return {
            "total_count": 0,
            "total_amount": 0,
            "by_category": {}
        }

    total_amount = sum(t["amount"] for t in transactions_db)
    by_category = {}

    for t in transactions_db:
        cat = t["category"]
        by_category[cat] = by_category.get(cat, 0) + t["amount"]

    return {
        "total_count": len(transactions_db),
        "total_amount": total_amount,
        "by_category": by_category
    }

@router.get("/{transaction_id}", response_model=Transaction)
def get_transaction(transaction_id: int):
    """è·å–å•æ¡äº¤æ˜“è®°å½•"""
    for t in transactions_db:
        if t["id"] == transaction_id:
            return t
    raise HTTPException(status_code=404, detail="äº¤æ˜“è®°å½•ä¸å­˜åœ¨")

@router.put("/{transaction_id}", response_model=Transaction)
def update_transaction(transaction_id: int, update_data: TransactionUpdate):
    """æ›´æ–°äº¤æ˜“è®°å½•"""
    for i, t in enumerate(transactions_db):
        if t["id"] == transaction_id:
            # åªæ›´æ–°æä¾›çš„å­—æ®µ
            update_dict = update_data.model_dump(exclude_unset=True)
            transactions_db[i].update(update_dict)
            return transactions_db[i]
    raise HTTPException(status_code=404, detail="äº¤æ˜“è®°å½•ä¸å­˜åœ¨")

@router.delete("/{transaction_id}")
def delete_transaction(transaction_id: int):
    """åˆ é™¤äº¤æ˜“è®°å½•"""
    for i, t in enumerate(transactions_db):
        if t["id"] == transaction_id:
            transactions_db.pop(i)
            return {"message": "åˆ é™¤æˆåŠŸ"}
    raise HTTPException(status_code=404, detail="äº¤æ˜“è®°å½•ä¸å­˜åœ¨")
```

### ä¸»åº”ç”¨æ³¨å†Œè·¯ç”±

```python
# main.py
from fastapi import FastAPI
from routers import transactions, categories, accounts

app = FastAPI(
    title="è®°è´¦ç³»ç»Ÿ API",
    description="ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„ä¸ªäººè®°è´¦ç³»ç»Ÿ",
    version="1.0.0"
)

# æ³¨å†Œè·¯ç”±
app.include_router(transactions.router)
app.include_router(categories.router)
app.include_router(accounts.router)

@app.get("/", tags=["æ ¹è·¯å¾„"])
def root():
    return {
        "message": "æ¬¢è¿ä½¿ç”¨è®°è´¦ç³»ç»Ÿ API",
        "docs": "/docs",
        "version": "1.0.0"
    }
```

## ğŸ“Š è¯·æ±‚å¤„ç†æµç¨‹

### å®Œæ•´è¯·æ±‚ç”Ÿå‘½å‘¨æœŸ

```mermaid
sequenceDiagram
    participant Client as å®¢æˆ·ç«¯
    participant Server as FastAPI æœåŠ¡å™¨
    participant Router as è·¯ç”±ç³»ç»Ÿ
    participant Validator as éªŒè¯å™¨
    participant Handler as å¤„ç†å‡½æ•°
    participant DB as æ•°æ®åº“

    Client->>Server: HTTP è¯·æ±‚
    Server->>Router: è·¯ç”±åŒ¹é…

    alt è·¯ç”±åŒ¹é…æˆåŠŸ
        Router->>Validator: å‚æ•°éªŒè¯

        alt éªŒè¯æˆåŠŸ
            Validator->>Handler: è°ƒç”¨å¤„ç†å‡½æ•°
            Handler->>DB: æ•°æ®æ“ä½œ
            DB-->>Handler: è¿”å›æ•°æ®
            Handler-->>Server: è¿”å›ç»“æœ
            Server-->>Client: 200 OK + JSON
        else éªŒè¯å¤±è´¥
            Validator-->>Client: 422 é”™è¯¯è¯¦æƒ…
        end
    else è·¯ç”±åŒ¹é…å¤±è´¥
        Router-->>Client: 404 Not Found
    end
```

### å‚æ•°è§£æé¡ºåº

```mermaid
flowchart LR
    Request["HTTP è¯·æ±‚"] --> Parse1["1.è·¯å¾„å‚æ•°"]
    Parse1 --> Parse2["2.æŸ¥è¯¢å‚æ•°"]
    Parse2 --> Parse3["3.è¯·æ±‚å¤´"]
    Parse3 --> Parse4["4.è¯·æ±‚ä½“"]
    Parse4 --> Validate["5.ç±»å‹éªŒè¯"]
    Validate --> Inject["6.ä¾èµ–æ³¨å…¥"]
    Inject --> Handler["7.è°ƒç”¨å‡½æ•°"]

    style Request fill:#e3f2fd
    style Handler fill:#c8e6c9
```

## ğŸ”§ é«˜çº§è·¯ç”±åŠŸèƒ½

### è·¯ç”±å‰ç¼€ä¸æ ‡ç­¾

```python
from fastapi import APIRouter

# åˆ›å»ºå¸¦æœ‰å‰ç¼€å’Œæ ‡ç­¾çš„è·¯ç”±å™¨
router = APIRouter(
    prefix="/api/v1/transactions",
    tags=["äº¤æ˜“ç®¡ç† - v1"],
    dependencies=[],  # å…¨å±€ä¾èµ–
    responses={
        404: {"description": "æœªæ‰¾åˆ°"},
        500: {"description": "æœåŠ¡å™¨é”™è¯¯"}
    }
)
```

### è·¯ç”±å“åº”æ¨¡å‹

```mermaid
flowchart LR
    Handler["å¤„ç†å‡½æ•°è¿”å›<br/>Python å­—å…¸"] --> Validate["å“åº”æ¨¡å‹éªŒè¯"]
    Validate --> Convert["è½¬æ¢ä¸º JSON"]
    Convert --> Client["è¿”å›ç»™å®¢æˆ·ç«¯"]

    style Handler fill:#e8f5e9
    style Client fill:#e3f2fd
```

```python
from pydantic import BaseModel
from typing import List

class TransactionResponse(BaseModel):
    id: int
    amount: float
    category: str

class TransactionListResponse(BaseModel):
    data: List[TransactionResponse]
    total: int
    page: int

# æŒ‡å®šå“åº”æ¨¡å‹
@router.get("", response_model=TransactionListResponse)
def list_transactions():
    # è¿”å›çš„æ•°æ®ä¼šè‡ªåŠ¨æŒ‰ response_model æ ¼å¼åŒ–
    return {
        "data": [...],
        "total": 100,
        "page": 1,
        "extra_field": "ä¼šè¢«è¿‡æ»¤æ‰"  # ä¸åœ¨æ¨¡å‹ä¸­çš„å­—æ®µä¼šè¢«ç§»é™¤
    }
```

### è·¯ç”±åˆ†ç»„ä¸ç‰ˆæœ¬æ§åˆ¶

```mermaid
flowchart TB
    App["FastAPI App"]

    subgraph V1["API v1"]
        V1T["/api/v1/transactions"]
        V1C["/api/v1/categories"]
    end

    subgraph V2["API v2"]
        V2T["/api/v2/transactions"]
        V2C["/api/v2/categories"]
        V2R["/api/v2/reports (æ–°å¢)"]
    end

    App --> V1
    App --> V2

    style V1 fill:#fff3e0
    style V2 fill:#c8e6c9
```

```python
from fastapi import FastAPI, APIRouter

app = FastAPI()

# v1 ç‰ˆæœ¬è·¯ç”±
v1_router = APIRouter(prefix="/api/v1")

@v1_router.get("/transactions")
def list_transactions_v1():
    return {"version": "v1", "data": []}

# v2 ç‰ˆæœ¬è·¯ç”±
v2_router = APIRouter(prefix="/api/v2")

@v2_router.get("/transactions")
def list_transactions_v2():
    return {"version": "v2", "data": [], "metadata": {}}

# æ³¨å†Œè·¯ç”±
app.include_router(v1_router)
app.include_router(v2_router)
```

## ğŸ“ ç»ƒä¹ ä»»åŠ¡

### åŸºç¡€ç»ƒä¹ 

1. **åˆ›å»ºç”¨æˆ· API**
   - GET /users - åˆ—è¡¨
   - GET /users/{id} - è¯¦æƒ…
   - POST /users - åˆ›å»º
   - PUT /users/{id} - æ›´æ–°
   - DELETE /users/{id} - åˆ é™¤

2. **æ·»åŠ åˆ†é¡µå‚æ•°**
   ```python
   # å®ç°åˆ†é¡µæŸ¥è¯¢
   @app.get("/items")
   def list_items(page: int = 1, size: int = 10):
       # è®¡ç®— skip å’Œè¿”å›æ•°æ®
       pass
   ```

### è¿›é˜¶ç»ƒä¹ 

3. **å¤æ‚æŸ¥è¯¢åŠŸèƒ½**
   - æ”¯æŒæŒ‰æ—¥æœŸèŒƒå›´æŸ¥è¯¢äº¤æ˜“
   - æ”¯æŒæŒ‰é‡‘é¢èŒƒå›´æŸ¥è¯¢
   - æ”¯æŒå¤šæ¡ä»¶ç»„åˆæŸ¥è¯¢

4. **API ç‰ˆæœ¬æ§åˆ¶**
   - å®ç° v1 å’Œ v2 ä¸¤ä¸ªç‰ˆæœ¬
   - v2 å¢åŠ ç»Ÿè®¡åŠŸèƒ½
   - ä¿æŒ v1 çš„å…¼å®¹æ€§

## âœ… æ£€æŸ¥ç‚¹

å®Œæˆæœ¬ç« å­¦ä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] è§£é‡Šè·¯ç”±çš„ä½œç”¨å’Œå·¥ä½œåŸç†
- [ ] åŒºåˆ†è·¯å¾„å‚æ•°ã€æŸ¥è¯¢å‚æ•°ã€è¯·æ±‚ä½“
- [ ] æ­£ç¡®ä½¿ç”¨å‚æ•°éªŒè¯
- [ ] è®¾è®¡ RESTful é£æ ¼çš„ API è·¯ç”±
- [ ] å®ç°æ¨¡å—åŒ–è·¯ç”±ç»„ç»‡
- [ ] å¤„ç†å¤æ‚çš„è¯·æ±‚åœºæ™¯

## ğŸ¤” å¸¸è§é—®é¢˜

### Q1: ä»€ä¹ˆæ—¶å€™ç”¨è·¯å¾„å‚æ•° vs æŸ¥è¯¢å‚æ•°ï¼Ÿ

**A**:
- **è·¯å¾„å‚æ•°**ï¼šæ ‡è¯†èµ„æºï¼Œå¦‚ `/transactions/123`
- **æŸ¥è¯¢å‚æ•°**ï¼šè¿‡æ»¤/åˆ†é¡µï¼Œå¦‚ `/transactions?category=food&page=1`

```mermaid
flowchart LR
    A["èµ„æºæ ‡è¯†"] --> B["è·¯å¾„å‚æ•°<br/>/transactions/123"]
    C["ç­›é€‰æ¡ä»¶"] --> D["æŸ¥è¯¢å‚æ•°<br/>?category=food"]
    E["åˆ†é¡µæ§åˆ¶"] --> F["æŸ¥è¯¢å‚æ•°<br/>?page=1&size=10"]
```

### Q2: å¦‚ä½•å¤„ç†å¤§é‡å¯é€‰å‚æ•°ï¼Ÿ

**A**: ä½¿ç”¨ Pydantic æ¨¡å‹æˆ–ä¾èµ–æ³¨å…¥ï¼š

```python
from pydantic import BaseModel
from fastapi import Depends

class TransactionFilter(BaseModel):
    category: Optional[str] = None
    min_amount: Optional[float] = None
    max_amount: Optional[float] = None
    start_date: Optional[str] = None
    end_date: Optional[str] = None

@app.get("/transactions")
def list_transactions(filter: TransactionFilter = Depends()):
    # filter åŒ…å«æ‰€æœ‰è¿‡æ»¤å‚æ•°
    return filter.model_dump()
```

### Q3: å¦‚ä½•è¿”å›è‡ªå®šä¹‰é”™è¯¯ä¿¡æ¯ï¼Ÿ

**A**: ä½¿ç”¨ HTTPExceptionï¼š

```python
from fastapi import HTTPException

@app.get("/transactions/{id}")
def get_transaction(id: int):
    transaction = find_transaction(id)
    if not transaction:
        raise HTTPException(
            status_code=404,
            detail={
                "error": "NOT_FOUND",
                "message": "äº¤æ˜“è®°å½•ä¸å­˜åœ¨",
                "transaction_id": id
            }
        )
    return transaction
```

## ğŸ“š å»¶ä¼¸é˜…è¯»

- **FastAPI è·¯ç”±æ–‡æ¡£**ï¼š[https://fastapi.tiangolo.com/tutorial/routing/](https://fastapi.tiangolo.com/tutorial/routing/)
- **è¯·æ±‚å‚æ•°æ–‡æ¡£**ï¼š[https://fastapi.tiangolo.com/tutorial/query-params/](https://fastapi.tiangolo.com/tutorial/query-params/)
- **Bigger Applications**ï¼š[https://fastapi.tiangolo.com/tutorial/bigger-applications/](https://fastapi.tiangolo.com/tutorial/bigger-applications/)

---

**ä¸‹ä¸€ç« **ï¼š[03-ä¾èµ–æ³¨å…¥.md](./03-ä¾èµ–æ³¨å…¥.md) - å­¦ä¹ å¦‚ä½•ä¼˜é›…åœ°ç®¡ç†èµ„æºå’Œå…±äº«é€»è¾‘
