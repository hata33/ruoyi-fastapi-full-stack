# 异步编程专题

> 本文档深入探讨 Python 异步编程的核心概念和实践，帮助你理解并掌握异步编程。

## 同步 vs 异步对比

```mermaid
flowchart TB
    subgraph 同步[同步执行]
        S1[请求1<br/>等待响应]
        S2[请求2<br/>等待响应]
        S3[请求3<br/>等待响应]

        S1 --> S2
        S2 --> S3

        Total1[总时间 = 1+2+3 = 6秒]
    end

    subgraph 异步[异步执行]
        A1[请求1<br/>发出后等待]
        A2[请求2<br/>发出后等待]
        A3[请求3<br/>发出后等待]

        A1 --> Response1[响应1返回]
        A2 --> Response2[响应2返回]
        A3 --> Response3[响应3返回]

        Total2[总时间 = max(1,2,3) = 3秒]
    end

```

## 并发执行流程

```mermaid
sequenceDiagram
    participant Event as 事件循环
    participant T1 as 任务1
    participant T2 as 任务2
    participant T3 as 任务3

    Event->>T1: await 创建任务1
    Event->>T2: await 创建任务2
    Event->>T3: await 创建任务3

    Note over Event: 任务1执行IO操作

    T1-->>Event: 等待IO
    Event->>T2: 切换到任务2

    Note over Event: 任务2执行IO操作

    T2-->>Event: 等待IO
    Event->>T3: 切换到任务3

    Note over Event: 任务3执行IO操作

    T3-->>Event: 等待IO
    Event->>T1: 任务1IO完成，恢复

    T1-->>Event: 任务1完成
    Event->>T2: 任务2IO完成，恢复

    T2-->>Event: 任务2完成
    Event->>T3: 任务3IO完成，恢复

    T3-->>Event: 任务3完成
```

## 任务状态变化

```mermaid
stateDiagram-v2
    [*] --> Created: 创建任务
    Created --> Pending: 提交到事件循环
    Pending --> Running: 获得执行权
    Running --> Waiting: await 等待IO
    Waiting --> Running: IO完成
    Running --> Finished: 任务完成
    Finished --> [*]

    Running --> Failed: 发生错误
    Failed --> [*]

    note right of Pending
        等待被调度
    end note

    note right of Waiting
        不占用CPU
        可执行其他任务
    end note

    note right of Running
        占用CPU执行
        可主动让出
    end note
```

## async/await 语法

```mermaid
flowchart TB
    Start([开始]) --> AsyncFunc[定义异步函数<br/>async def func]

    AsyncFunc --> Await[等待异步操作<br/>await operation]

    Await --> IO{操作类型?}

    IO -->|数据库| DB[async with db<br/>数据库操作]
    IO -->|HTTP| HTTP[aiohttp请求]
    IO -->|文件| File[aiofiles文件操作]
    IO -->|睡眠| Sleep[asyncio.sleep]

    DB --> Result[获取结果]
    HTTP --> Result
    File --> Result
    Sleep --> Result

    Result --> Return[返回或继续处理]
    Return --> End([结束])

```

### 语法要点

| 关键字 | 用途 | 示例 |
|-------|------|------|
| `async def` | 定义协程函数 | `async def fetch_data()` |
| `await` | 等待协程完成 | `result = await fetch()` |
| `async with` | 异步上下文管理器 | `async with session.get()` |
| `async for` | 异步迭代器 | `async for line in reader:` |

## 并发控制

```mermaid
flowchart TB
    Tasks[多个任务] --> Strategy{并发策略}

    Strategy -->|全部并发| All[asyncio.gather<br/>全部同时执行]
    Strategy -->|限制并发| Semaphore[Semaphore<br/>限制并发数]
    Strategy -->|超时控制| Timeout[timeout<br/>超时取消]
    Strategy -->|任务组| Group[TaskGroup<br/>结构化并发]

    All --> Result[等待所有完成]
    Semaphore --> Result
    Timeout --> Result
    Group --> Result

    Result --> Handle{处理结果}

    Handle --> Return[返回结果]
    Handle --> Error[处理异常]

```

### 并发模式对比

| 模式 | 优点 | 缺点 | 适用场景 |
|-----|------|------|---------|
| `gather` | 简单，等待全部 | 无法限制并发 | 少量任务，全部需要结果 |
| `Semaphore` | 控制并发数 | 需要手动管理 | 大量任务，限制资源 |
| `TaskGroup` | 结构化，自动清理 | Python 3.11+ | 复杂任务依赖 |
| `create_task` | 立即返回，后台执行 | 需要手动等待 | 后台任务，不关心结果 |

## 异步上下文管理器

```mermaid
sequenceDiagram
    participant Code as 代码
    participant CM as 上下文管理器
    participant Resource as 资源

    Code->>CM: async with <resource>
    CM->>Resource: __aenter__()
    Resource-->>CM: 资源初始化
    CM-->>Code: 返回资源

    Code->>Resource: 使用资源
    Resource-->>Code: 返回数据

    Code->>CM: 退出 with 块
    CM->>Resource: __aexit__()
    Resource-->>CM: 资源清理
    CM-->>Code: 完成
```

### 异步上下文管理器示例

| 资源类型 | 上下文管理器 | 说明 |
|---------|-------------|------|
| 数据库会话 | `async with db.begin()` | 自动提交/回滚事务 |
| HTTP 客户端 | `async with aiohttp.ClientSession()` | 自动关闭连接 |
| 文件操作 | `async with aiofiles.open()` | 自动关闭文件 |
| 锁 | `async with lock:` | 自动释放锁 |

## asyncio.gather 并发执行

```mermaid
flowchart TB
    Start([开始]) --> Create[创建多个协程]

    Create --> Tasks[task1, task2, task3]

    Tasks --> Gather[asyncio.gather<br/>并发执行]

    Gather --> Wait[等待所有完成]

    Wait --> Check{是否有异常?}

    Check -->|是| Error[抛出第一个异常]
    Check -->|否| Success[返回所有结果]

    Error --> Handle1[处理异常]
    Success --> Handle2[处理结果]

    Handle1 --> End([结束])
    Handle2 --> End

```

### gather 参数说明

```python
# 基本用法
results = await asyncio.gather(task1, task2, task3)

# 遇到异常不停止，返回异常对象
results = await asyncio.gather(
    task1, task2, task3,
    return_exceptions=True
)

# 按顺序返回结果
results = await asyncio.gather(
    coroutine1(),
    coroutine2(),
    coroutine3()
)
```

## 超时控制

```mermaid
flowchart TB
    Start([开始任务]) --> Timeout{设置超时?}

    Timeout -->|否| Normal[正常执行]
    Timeout -->|是| TimeLimit[设置超时时间]

    TimeLimit --> Execute[执行任务]

    Normal --> Execute

    Execute --> Check{超时?}

    Check -->|否| Complete[任务完成]
    Check -->|是| Cancel[取消任务]

    Complete --> Result[返回结果]
    Cancel --> Error[抛出TimeoutError]

    Result --> End([结束])
    Error --> End

```

### 超时控制方法

| 方法 | 说明 | 示例 |
|-----|------|------|
| `asyncio.wait_for` | 单个任务超时 | `await wait_for(task, timeout=5)` |
| `asyncio.timeout` | 上下文管理器 | `async with timeout(5):` |
| `asyncio.wait` | 等待一组任务 | `done, pending = wait(tasks, timeout=5)` |

## 数据库操作异步化

```mermaid
sequenceDiagram
    participant API as API接口
    participant DB as 异步数据库
    participant DBPool as 连接池
    participant MySQL as MySQL

    API->>DB: 查询用户
    DB->>DBPool: 获取连接
    DBPool-->>DB: 返回连接

    DB->>MySQL: 发送SQL
    DB-->>API: await 等待

    Note over DB,MySQL: 网络IO，不阻塞

    MySQL-->>DB: 返回结果
    DB->>DBPool: 归还连接
    DB-->>API: 返回数据
```

### 异步数据库操作要点

| 操作 | 同步 | 异步 |
|-----|------|------|
| 连接 | `engine.connect()` | `async_engine.acquire()` |
| 查询 | `session.query()` | `await session.execute()` |
| 事务 | `with session.begin()` | `async with session.begin()` |
| 执行 | `session.execute()` | `await session.execute()` |

## 错误处理

```mermaid
flowchart TB
    Start([异步任务]) --> Execute[执行任务]

    Execute --> Error{发生异常?}

    Error -->|是| Type{异常类型?}

    Type -->|Timeout| TO[TimeoutError]
    Type -->|Cancelled| Cancel[CancelledError]
    Type -->|Other| Other[其他异常]

    TO --> Handle1[处理超时]
    Cancel --> Handle2[处理取消]
    Other --> Handle3[处理异常]

    Handle1 --> Log[记录日志]
    Handle2 --> Log
    Handle3 --> Log

    Error -->|否| Success[任务成功]
    Success --> End([结束])
    Log --> End

```

### 错误处理最佳实践

```python
try:
    result = await async_operation()
except asyncio.TimeoutError:
    # 超时处理
    logger.error("Operation timed out")
except asyncio.CancelledError:
    # 取消处理
    logger.info("Operation was cancelled")
except Exception as e:
    # 其他异常
    logger.error(f"Operation failed: {e}")
    raise
```

## 异步编程最佳实践

```mermaid
mindmap
  root((最佳实践))
    何时使用异步
      IO密集型
        数据库操作
        HTTP请求
        文件操作
      避免CPU密集
        计算密集用进程池
    不要阻塞事件循环
      使用async/await
      不要time.sleep
      不要同步阻塞
    资源管理
      使用上下文管理器
      及时关闭连接
      控制并发数量
    错误处理
      捕获特定异常
      记录详细日志
      优雅处理取消
    超时控制
      设置合理超时
      处理超时异常
      避免资源泄漏
    测试
      使用异步测试框架
      模拟异步操作
      测试并发场景
```

## 异步编程检查清单

### 基础使用
- 使用 `async def` 定义异步函数
- 使用 `await` 等待异步操作
- 使用 `async with` 管理资源
- 使用 `asyncio.run()` 运行异步代码

### 并发控制
- 使用 `asyncio.gather()` 并发执行
- 使用 `Semaphore` 限制并发数
- 设置合理的超时时间
- 正确处理任务取消

### 资源管理
- 使用连接池管理连接
- 及时释放不再使用的资源
- 避免创建过多协程
- 正确关闭异步资源

### 错误处理
- 捕获并处理异常
- 记录详细的错误日志
- 优雅处理超时
- 正确处理取消操作

## 实战案例：并发请求优化

### 问题：串行请求慢

```python
# 串行执行，总耗时 = 2 + 3 + 1 = 6秒
async def fetch_user(user_id):
    await asyncio.sleep(2)  # 模拟数据库查询
    return {"id": user_id, "name": f"User{user_id}"}

async def main():
    users = []
    for i in range(1, 4):
        user = await fetch_user(i)
        users.append(user)
    return users
```

### 解决：并发执行快

```python
# 并发执行，总耗时 = max(2, 3, 1) = 3秒
async def main():
    tasks = [fetch_user(i) for i in range(1, 4)]
    users = await asyncio.gather(*tasks)
    return users
```

### 性能对比

| 方式 | 耗时 | 提升 |
|-----|------|------|
| 串行执行 | 6秒 | - |
| 并发执行 | 3秒 | 2倍 |

## 相关文档

- [05-前端开发者的后端入门/05-异步编程-比Promise更优雅.md](../05-前端开发者的后端入门/05-异步编程-比Promise更优雅.md) - 异步编程入门
- [09-性能优化专题.md](./09-性能优化专题.md) - 性能优化
- [12-数据持久化专题.md](./12-数据持久化专题.md) - 异步数据库操作
