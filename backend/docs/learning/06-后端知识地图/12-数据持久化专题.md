# 数据持久化专题

> 本文档深入探讨数据持久化的核心概念和实践，包括 CRUD 操作、事务管理、ORM 查询和缓存策略。

## 数据流转路径

```mermaid
flowchart TB
    Request[HTTP请求] --> Parse[解析参数]

    Parse --> QueryModel{Query Model<br/>参数验证}

    QueryModel --> Service[Service层]

    Service --> Business{业务逻辑}

    Business --> DAO[DAO层]

    DAO --> ORM{ORM操作}

    ORM --> CRUD{CRUD操作}

    CRUD --> C[Create 创建]
    CRUD --> R[Read 查询]
    CRUD --> U[Update 更新]
    CRUD --> D[Delete 删除]

    C --> DB[(数据库)]
    R --> DB
    U --> DB
    D --> DB

    DB --> Result[返回结果]

    Result --> VO{VO Model<br/>数据转换}

    VO --> Response[JSON响应]

```

## 事务处理流程

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Service as Service层
    participant DB as 数据库

    Client->>Service: 开始事务
    Service->>Service: async with db.begin()

    Note over Service,DB: 事务开始

    Service->>DB: 操作1: INSERT
    DB-->>Service: 成功

    Service->>DB: 操作2: UPDATE
    DB-->>Service: 成功

    Service->>DB: 操作3: DELETE
    DB-->>Service: 成功

    alt 所有操作成功
        Service->>DB: COMMIT
        DB-->>Client: 返回成功
    else 任何操作失败
        Service->>DB: ROLLBACK
        DB-->>Client: 返回失败
    end

    Note over Service,DB: 事务结束
```

## 缓存策略选择

```mermaid
flowchart TB
    Request[查询请求] --> Cache{缓存策略}

    Cache -->|Cache-Aside| CA[Cache-Aside]
    Cache -->|Read-Through| RT[Read-Through]
    Cache -->|Write-Through| WT[Write-Through]
    Cache -->|Write-Behind| WB[Write-Behind]

    subgraph CacheAside[Cache-Aside 旁路缓存]
        CA1[查缓存]
        CA2[未命中查DB]
        CA3[写入缓存]
    end

    subgraph ReadThrough[Read-Through 读穿透]
        RT1[查缓存]
        RT2[缓存负责加载DB]
        RT3[返回数据]
    end

    subgraph WriteThrough[Write-Through 写穿透]
        WT1[写缓存]
        WT2[同步写DB]
        WT3[两者一致]
    end

    subgraph WriteBehind[Write-Behind 写回]
        WB1[写缓存]
        WB2[异步写DB]
        WB3[延迟写入]
    end

    CA --> Result[返回数据]
    RT --> Result
    WT --> Result
    WB --> Result

```

### 缓存策略对比

| 策略 | 优点 | 缺点 | 适用场景 |
|-----|------|------|---------|
| Cache-Aside | 简单灵活 | 首次查询慢 | 通用场景，最常用 |
| Read-Through | 缓存统一管理 | 代码复杂 | 高频读取 |
| Write-Through | 强一致性 | 写入慢 | 数据一致性要求高 |
| Write-Behind | 写入快 | 可能丢数据 | 允许短时不一致 |

## CRUD 操作

### Create (创建)

```mermaid
flowchart TB
    Create[创建请求] --> Validate{参数验证}

    Validate -->|失败| Error1[返回400]
    Validate -->|成功| Check{检查约束}

    Check -->|唯一性| Duplicate{是否存在?}
    Duplicate -->|是| Error2[返回409 冲突]
    Duplicate -->|否| Insert[插入数据库]

    Check --> Insert

    Insert --> Success{成功?}

    Success -->|是| Result[返回创建的数据]
    Success -->|否| Error3[返回500]

```

### Read (查询)

```mermaid
flowchart TB
    Query[查询请求] --> Cache{缓存存在?}

    Cache -->|是| Return1[返回缓存]
    Cache -->|否| DB[查询数据库]

    DB --> SetCache[写入缓存]
    SetCache --> Return2[返回数据]

    Return1 --> Response[JSON响应]
    Return2 --> Response

```

### Update (更新)

```mermaid
flowchart TB
    Update[更新请求] --> Exist{记录存在?}

    Exist -->|否| NotFound[返回404]
    Exist -->|是| Validate[参数验证]

    Validate -->|失败| Error[返回400]
    Validate -->|成功| Optimistic{乐观锁?}

    Optimistic -->|是| Version{版本匹配?}
    Optimistic -->|否| UpdateDB[更新数据库]

    Version -->|否| Conflict[返回409 冲突]
    Version -->|是| UpdateDB

    UpdateDB --> Success{成功?}

    Success -->|是| Result[返回更新后的数据]
    Success -->|否| Error2[返回500]

```

### Delete (删除)

```mermaid
flowchart TB
    Delete[删除请求] --> Mode{删除模式}

    Mode -->|物理删除| Physical[直接删除记录]
    Mode -->|软删除| Soft[设置del_flag=1]

    Physical --> DB[执行DELETE]
    Soft --> DB[执行UPDATE]

    DB --> Success{成功?}

    Success -->|是| Result[返回成功]
    Success -->|否| Error[返回500]

```

## ORM 查询构建

```mermaid
flowchart TB
    Query[构建查询] --> Base[基础查询<br/>session.query(Model)]

    Base --> Where{添加条件?}

    Where -->|是| Filter[filter()/filter_by()]
    Where -->|否| Join

    Filter --> Condition{条件类型}

    Condition -->|等值| C1[filter_by(name=value)]
    Condition -->|比较| C2[filter(Model.age > 18)]
    Condition -->|多条件| C3[filter(and_/or_/not_)]

    C1 --> Join{关联查询?}
    C2 --> Join
    C3 --> Join

    Join -->|是| J1[join()/outerjoin()]
    Join -->|否| Order

    J1 --> Order{排序?}

    Order -->|是| Sort[order_by()]
    Order -->|否| Limit

    Sort --> Limit{分页?}

    Limit -->|是| Page[offset()/limit()]
    Limit -->|否| Execute

    Page --> Execute[all()/one()/first()]

    Execute --> Result[返回结果]

```

## 查询优化技巧

```mermaid
mindmap
  root((查询优化))
    选择性查询
      只查询需要的字段
        避免SELECT *
      使用defer/undefer
      延迟加载关联
    索引利用
      WHERE条件使用索引
      ORDER BY使用索引
      覆盖索引
    分页优化
      游标分页
      避免深分页
      使用where替代offset
    批量操作
      批量插入
        bulk_insert_mappings
      批量更新
        bulk_update_mappings
    查询计划
      EXPLAIN分析
      识别慢查询
      优化执行计划
```

## 事务 ACID 特性

```mermaid
graph TB
    subgraph ACID[ACID 特性]
        direction TB
        A[Atomicity<br/>原子性]
        C[Consistency<br/>一致性]
        I[Isolation<br/>隔离性]
        D[Durability<br/>持久性]
    end

    subgraph 示例[转账示例]
        T1[步骤1: 扣除A账户]
        T2[步骤2: 增加B账户]
    end

    A --> Atom[要么全成功<br/>要么全失败]
    C --> Cons[数据保持一致<br/>总额不变]
    I --> Iso[事务间互不影响]
    D --> Dur[提交后永久保存]

    Atom --> T1
    Atom --> T2
    Cons --> T1
    Iso --> T1
    Dur --> T2

    classDef acidStyle fill:#e1f5ff,stroke:#333,stroke-width:2px

    class A,C,I,D acidStyle
```

## 事务隔离级别

```mermaid
flowchart TB
    Isolation[隔离级别] --> Levels{选择级别}

    Levels -->|Read Uncommitted| RU[读未提交<br/>可能出现脏读]
    Levels -->|Read Committed| RC[读已提交<br/>避免脏读]
    Levels -->|Repeatable Read| RR[可重复读<br/>避免脏读+不可重复读]
    Levels -->|Serializable| SER[串行化<br/>完全隔离]

    RU --> Problem1[脏读<br/>Dirty Read]
    RU --> Problem2[不可重复读<br/>Non-Repeatable Read]
    RU --> Problem3[幻读<br/>Phantom Read]

    RC --> Problem2
    RC --> Problem3

    RR --> Problem3

    SER --> None[无并发问题]

```

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 | 适用场景 |
|---------|------|----------|------|------|---------|
| Read Uncommitted | ✗ | ✗ | ✗ | 高 | 极少使用 |
| Read Committed | √ | ✗ | ✗ | 中高 | 默认级别 |
| Repeatable Read | √ | √ | ✗ | 中 | 需要一致性 |
| Serializable | √ | √ | √ | 低 | 严格要求 |

## 分页查询实现

```mermaid
flowchart TB
    Request[分页请求] --> Params{参数类型}

    Params -->|OFFSET/LIMIT| OL[传统分页]
    Params -->|游标| Cursor[游标分页]

    subgraph 传统分页[OFFSET/LIMIT]
        OL1[计算 offset = page * size]
        OL2[执行 LIMIT size OFFSET offset]
        OL3[返回 total 和 rows]
    end

    subgraph 游标分页[游标分页]
        C1[WHERE id > last_id]
        C2[ORDER BY id ASC]
        C3[LIMIT size]
        C4[返回 rows 和 next_cursor]
    end

    OL --> Result[返回结果]
    Cursor --> Result

    OL --> Deep{深分页?}
    Deep -->|是| Slow[性能下降<br/>OFFSET扫描]
    Deep -->|否| Normal[正常]

    Cursor --> Always[始终高效]

```

## 软删除 vs 硬删除

```mermaid
flowchart TB
    Delete[删除操作] --> Choice{删除方式}

    Choice -->|硬删除| Hard[DELETE FROM table]
    Choice -->|软删除| Soft[UPDATE SET del_flag=1]

    Hard --> H1[数据永久删除]
    Hard --> H2[不可恢复]
    Hard --> H3[级联删除关联]

    Soft --> S1[数据标记删除]
    Soft --> S2[可以恢复]
    Soft --> S3[保留关联关系]

    H1 --> Risk[风险高]
    H2 --> Risk
    H3 --> Risk

    S1 --> Safe[更安全]
    S2 --> Safe
    S3 --> Safe

    style Hard fill:#ffe1e1
    style Risk fill:#ffe1e1
    style Soft fill:#e1ffe1
    style Safe fill:#e1ffe1
```

## 数据持久化检查清单

### CRUD 操作
- 创建时验证参数
- 检查唯一性约束
- 查询时使用缓存
- 更新时使用乐观锁
- 删除时考虑软删除

### 事务管理
- 明确事务边界
- 使用上下文管理器
- 正确处理异常
- 避免长事务
- 选择合适的隔离级别

### 查询优化
- 只查询需要的字段
- 使用索引加速查询
- 合理使用分页
- 批量操作代替循环
- 分析慢查询

### 缓存策略
- 选择合适的缓存策略
- 处理缓存穿透
- 处理缓存雪崩
- 设置合理的过期时间
- 更新时同步缓存

## 实战案例：转账事务

```python
async def transfer(from_id: int, to_id: int, amount: Decimal):
    async with db.begin():  # 自动提交/回滚
        # 1. 查询转出账户
        from_account = await db.get(Account, from_id)
        if not from_account or from_account.balance < amount:
            raise ValueError("余额不足")

        # 2. 查询转入账户
        to_account = await db.get(Account, to_id)
        if not to_account:
            raise ValueError("目标账户不存在")

        # 3. 扣除转出账户
        from_account.balance -= amount

        # 4. 增加转入账户
        to_account.balance += amount

        # 5. 记录交易日志
        transaction = Transaction(
            from_id=from_id,
            to_id=to_id,
            amount=amount
        )
        db.add(transaction)

        # 自动提交事务，如果任何步骤失败则回滚
```

## 相关文档

- [05-前端开发者的后端入门/06-数据持久化-状态管理的本质.md](../05-前端开发者的后端入门/06-数据持久化-状态管理的本质.md) - 数据持久化入门
- [07-数据建模专题.md](./07-数据建模专题.md) - 数据建模
- [09-性能优化专题.md](./09-性能优化专题.md) - 查询优化
- [11-异步编程专题.md](./11-异步编程专题.md) - 异步数据库操作
