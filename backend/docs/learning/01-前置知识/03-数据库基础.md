# 数据库基础

> 数据库是后端开发的核心组件，存储和管理应用数据。本节讲解关系型数据库的基础知识和项目中的应用。

## 目录

- [数据库概述](#数据库概述)
- [SQL 基础](#sql-基础)
- [表设计原则](#表设计原则)
- [索引](#索引)
- [事务](#事务)
- [外键与关联](#外键与关联)
- [ORM 框架](#orm-框架)
- [项目中的数据库](#项目中的数据库)

---

## 数据库概述

### 什么是数据库

数据库是**有组织的数据集合**，用于存储、检索和管理数据。

```
┌─────────────────────────────────┐
│          应用程序                │
│   (FastAPI Backend)             │
└────────────┬────────────────────┘
             │ SQL 请求
             ↓
┌─────────────────────────────────┐
│          数据库                  │
│   (MySQL / PostgreSQL)           │
│  ┌─────────┐  ┌─────────┐       │
│  │ 用户表  │  │ 角色表  │  ...  │
│  └─────────┘  └─────────┘       │
└─────────────────────────────────┘
```

### 关系型数据库 vs 非关系型数据库

| 特性 | 关系型数据库 (SQL) | 非关系型数据库 (NoSQL) |
|------|-------------------|----------------------|
| 数据模型 | 表、行、列 | 键值对、文档、图 |
| 示例 | MySQL, PostgreSQL | Redis, MongoDB |
| 优点 | 数据一致性高、支持复杂查询 | 灵活、高性能、易扩展 |
| 适用场景 | 核心业务数据 | 缓存、日志、非结构化数据 |

### 项目使用的数据库

RuoYi-Vue3-FastAPI 支持：
- **MySQL**（默认）
- **PostgreSQL**

```python
# config/env.py
class DatabaseConfig:
    # MySQL 配置
    database_url: str = "mysql+asyncmy://user:pass@localhost:3306/ruoyi"

    # PostgreSQL 配置
    database_url: str = "postgresql+asyncpg://user:pass@localhost:5432/ruoyi"
```

---

## SQL 基础

### 什么是 SQL

SQL（Structured Query Language）是**结构化查询语言**，用于操作关系型数据库。

### DDL - 数据定义语言

```sql
-- 创建表
CREATE TABLE sys_user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(30) NOT NULL,
    nick_name VARCHAR(30),
    email VARCHAR(50),
    status CHAR(1) DEFAULT '0',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 修改表
ALTER TABLE sys_user ADD COLUMN phone VARCHAR(20);

-- 删除表
DROP TABLE sys_user;

-- 删除数据库
DROP DATABASE ruoyi;
```

### DML - 数据操作语言

```sql
-- 插入数据
INSERT INTO sys_user (user_name, nick_name, email)
VALUES ('zhangsan', '张三', 'zhangsan@example.com');

-- 更新数据
UPDATE sys_user
SET nick_name = '张三丰', email = 'zhangsanfeng@example.com'
WHERE user_id = 1;

-- 删除数据
DELETE FROM sys_user WHERE user_id = 1;

-- 软删除（推荐）
UPDATE sys_user SET del_flag = '1' WHERE user_id = 1;
```

### DQL - 数据查询语言

```sql
-- 基础查询
SELECT * FROM sys_user;

-- 条件查询
SELECT user_id, user_name, email
FROM sys_user
WHERE status = '0' AND del_flag = '0';

-- 排序
SELECT * FROM sys_user
ORDER BY create_time DESC;

-- 分页
SELECT * FROM sys_user
LIMIT 10 OFFSET 0;  -- 第 1 页，每页 10 条

-- 聚合函数
SELECT COUNT(*) FROM sys_user;
SELECT MAX(user_id) FROM sys_user;
```

### JOIN - 表连接

```sql
-- 内连接：只匹配两个表中都存在的数据
SELECT u.user_name, d.dept_name
FROM sys_user u
INNER JOIN sys_dept d ON u.dept_id = d.dept_id
WHERE u.del_flag = '0';

-- 左连接：保留左表所有数据，右表没有的为 NULL
SELECT u.user_name, d.dept_name
FROM sys_user u
LEFT JOIN sys_dept d ON u.dept_id = d.dept_id;

-- 右连接：保留右表所有数据
SELECT u.user_name, d.dept_name
FROM sys_user u
RIGHT JOIN sys_dept d ON u.dept_id = d.dept_id;
```

### GROUP BY - 分组

```sql
-- 统计每个部门的用户数量
SELECT d.dept_name, COUNT(u.user_id) as user_count
FROM sys_dept d
LEFT JOIN sys_user u ON d.dept_id = u.dept_id
GROUP BY d.dept_id, d.dept_name;

-- 统计各状态的用户数量
SELECT status, COUNT(*) as count
FROM sys_user
WHERE del_flag = '0'
GROUP BY status;
```

---

## 表设计原则

### 命名规范

| 类型 | 规范 | 示例 |
|------|------|------|
| 数据库名 | 小写，下划线分隔 | `ruoyi_fastapi` |
| 表名 | 小写，前缀 `sys_` | `sys_user`, `sys_role` |
| 字段名 | 小写，下划线分隔 | `user_id`, `user_name` |
| 主键 | `{表名}_id` | `user_id`, `role_id` |
| 外键 | `{关联表}_id` | `dept_id`, `role_id` |

### 字段类型

| 类型 | 说明 | 示例 |
|------|------|------|
| INT | 整数 | `user_id INT` |
| BIGINT | 大整数 | `id BIGINT` |
| VARCHAR(n) | 变长字符串 | `user_name VARCHAR(30)` |
| CHAR(n) | 定长字符串 | `status CHAR(1)` |
| TEXT | 长文本 | `remark TEXT` |
| DATETIME | 日期时间 | `create_time DATETIME` |
| DECIMAL(m,d) | 精确小数 | `amount DECIMAL(10,2)` |
| BOOLEAN | 布尔值 | `is_deleted BOOLEAN` |

### 标准字段

每个表都应该包含的**标准审计字段**：

```sql
CREATE TABLE sys_user (
    -- 主键
    user_id INT AUTO_INCREMENT PRIMARY KEY,

    -- 业务字段
    user_name VARCHAR(30) NOT NULL,
    nick_name VARCHAR(30),

    -- 状态字段
    status CHAR(1) DEFAULT '0',        -- 0=正常 1=停用
    del_flag CHAR(1) DEFAULT '0',      -- 0=存在 1=删除

    -- 审计字段
    create_by VARCHAR(64) DEFAULT 'system',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_by VARCHAR(64),
    update_time DATETIME ON UPDATE CURRENT_TIMESTAMP,
    remark VARCHAR(500)
);
```

### 数据完整性

```sql
-- 非空约束
user_name VARCHAR(30) NOT NULL

-- 唯一约束
user_name VARCHAR(30) UNIQUE

-- 默认值
status CHAR(1) DEFAULT '0'

-- 检查约束
status CHAR(1) DEFAULT '0' CHECK (status IN ('0', '1'))

-- 主键约束
user_id INT PRIMARY KEY

-- 外键约束
dept_id INT,
FOREIGN KEY (dept_id) REFERENCES sys_dept(dept_id)
```

---

## 索引

### 什么是索引

索引是**提高查询速度的数据结构**，类似书的目录。

```
没有索引：
┌─────────┐
│ 查找用户 │ → 遍历整张表，慢！
│ zhangsan│
└─────────┘

有索引：
┌─────────┐     ┌──────┐
│ 查找用户 │ ─→  │ 索引 │ ─→ 快速定位
│ zhangsan│     │ (B树)│
└─────────┘     └──────┘
```

### 索引类型

```sql
-- 主键索引（自动创建）
PRIMARY KEY (user_id)

-- 唯一索引
UNIQUE INDEX idx_user_name (user_name)

-- 普通索引
INDEX idx_email (email)

-- 组合索引
INDEX idx_dept_status (dept_id, status, del_flag)

-- 全文索引
FULLTEXT INDEX idx_remark (remark)
```

### 索引设计原则

✅ **适合创建索引**：
- 频繁作为 WHERE 条件的字段
- 经常用于 JOIN 的字段
- 需要排序的字段（ORDER BY）

❌ **不适合创建索引**：
- 频繁更新的字段
- 数据区分度低的字段（如性别）
- 很少使用的字段

### 项目中的索引

```python
# module_admin/entity/do/user_do.py
class SysUser(Base):
    __tablename__ = 'sys_user'
    __table_args__ = (
        # 组合索引：登录查询优化
        Index('idx_user_login', 'user_name', 'status', 'del_flag'),
        # 唯一索引：用户名唯一
        UniqueConstraint('user_name', name='uq_user_name'),
    )
```

---

## 事务

### 什么是事务

事务是**一组数据库操作，要么全部成功，要么全部失败**。

### ACID 特性

| 特性 | 说明 |
|------|------|
| 原子性 (A) | 事务中的操作要么全做，要么全不做 |
| 一致性 (C) | 事务执行前后，数据库状态一致 |
| 隔离性 (I) | 并发事务之间相互隔离 |
| 持久性 (D) | 事务提交后，数据永久保存 |

### 事务使用

```sql
-- 开始事务
START TRANSACTION;

-- 执行操作
UPDATE account SET balance = balance - 100 WHERE user_id = 1;
UPDATE account SET balance = balance + 100 WHERE user_id = 2;

-- 提交事务（成功）
COMMIT;

-- 或回滚事务（失败）
ROLLBACK;
```

### 项目中的事务

```python
# SQLAlchemy 自动事务管理
async def transfer_money(
    db: AsyncSession,
    from_user: int,
    to_user: int,
    amount: int
):
    # 自动开始事务
    try:
        # 扣款
        await db.execute(
            update(SysAccount)
            .where(SysAccount.user_id == from_user)
            .values(balance=SysAccount.balance - amount)
        )

        # 收款
        await db.execute(
            update(SysAccount)
            .where(SysAccount.user_id == to_user)
            .values(balance=SysAccount.balance + amount)
        )

        # 提交事务
        await db.commit()

    except Exception as e:
        # 回滚事务
        await db.rollback()
        raise e
```

---

## 外键与关联

### 一对一关系

```
用户 ─── 身份证
1 : 1
```

```sql
CREATE TABLE sys_user (
    user_id INT PRIMARY KEY,
    id_card_id INT UNIQUE,
    FOREIGN KEY (id_card_id) REFERENCES sys_id_card(id_card_id)
);
```

### 一对多关系

```
部门 ─── 用户
1 : N
```

```sql
CREATE TABLE sys_user (
    user_id INT PRIMARY KEY,
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES sys_dept(dept_id)
);
```

### 多对多关系

```
用户 ──── 角色 ──── 权限
M : N     M : N
```

```sql
-- 关联表
CREATE TABLE sys_user_role (
    user_id INT,
    role_id INT,
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES sys_user(user_id),
    FOREIGN KEY (role_id) REFERENCES sys_role(role_id)
);
```

---

## ORM 框架

### 什么是 ORM

ORM（Object-Relational Mapping）是**对象关系映射**，用面向对象的方式操作数据库。

```
传统 SQL:
cursor.execute("SELECT * FROM sys_user WHERE user_id = 1")
user = cursor.fetchone()

ORM:
user = session.query(SysUser).filter_by(user_id=1).first()
```

### SQLAlchemy 基础

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import declarative_base, Session

# 声明基类
Base = declarative_base()

# 定义模型
class SysUser(Base):
    __tablename__ = 'sys_user'

    user_id = Column(Integer, primary_key=True)
    user_name = Column(String(30))
    email = Column(String(50))

# 创建引擎
engine = create_engine('mysql+asyncmy://user:pass@localhost/ruoyi')

# 创建会话
session = Session(engine)

# 查询
user = session.query(SysUser).filter_by(user_id=1).first()

# 插入
new_user = SysUser(user_name='zhangsan', email='test@example.com')
session.add(new_user)
session.commit()
```

### SQLAlchemy 2.0 新语法

```python
# 选择语句
from sqlalchemy import select

stmt = select(SysUser).where(SysUser.user_id == 1)
result = await session.execute(stmt)
user = result.scalar_one_or_none()

# 插入
from sqlalchemy import insert

stmt = insert(SysUser).values(user_name='zhangsan')
await session.execute(stmt)

# 更新
from sqlalchemy import update

stmt = update(SysUser).where(SysUser.user_id == 1).values(email='new@example.com')
await session.execute(stmt)

# 删除
from sqlalchemy import delete

stmt = delete(SysUser).where(SysUser.user_id == 1)
await session.execute(stmt)
```

---

## 项目中的数据库

### 数据库初始化

```python
# config/get_db.py
async def init_create_table():
    """应用启动时创建表"""
    async with async_engine.begin() as conn:
        # 创建所有表
        await conn.run_sync(Base.metadata.create_all)
```

### 连接池

```python
# config/database.py
# 创建异步引擎（内置连接池）
async_engine = create_async_engine(
    DATABASE_URL,
    echo=False,              # 是否打印 SQL
    pool_size=10,            # 连接池大小
    max_overflow=20,         # 最大溢出连接数
    pool_pre_ping=True,      # 连接前检测可用性
    pool_recycle=3600,       # 连接回收时间（秒）
)
```

### 依赖注入

```python
# config/get_db.py
async def get_db():
    """依赖注入：获取数据库会话"""
    async with AsyncSessionLocal() as session:
        yield session  # 提供给路由使用
    # 自动关闭会话

# 使用
@userController.get("/list")
async def get_user_list(query_db: AsyncSession = Depends(get_db)):
    # query_db 已经是可用的数据库会话
    result = await query_db.execute(select(SysUser))
    return result.scalars().all()
```

### 复杂查询示例

```python
# 关联查询
stmt = (
    select(SysUser, SysDept)
    .join(SysDept, SysUser.dept_id == SysDept.dept_id)
    .where(SysUser.del_flag == '0')
    .order_by(SysUser.create_time.desc())
)
result = await db.execute(stmt)

# 分页查询
from sqlalchemy import func

total = await db.scalar(
    select(func.count()).select_from(SysUser)
)
stmt = (
    select(SysUser)
    .offset((page - 1) * size)
    .limit(size)
)
users = await db.execute(stmt)
```

---

## 练习建议

### 1. 安装数据库

```bash
# 安装 MySQL
# Windows: https://dev.mysql.com/downloads/installer/
# Mac: brew install mysql
# Linux: sudo apt-get install mysql-server

# 启动 MySQL
mysql -u root -p

# 创建数据库
CREATE DATABASE ruoyi_fastapi CHARACTER SET utf8mb4;

# 导入初始化脚本
source sql/ruoyi-fastapi.sql;
```

### 2. 练习 SQL

```sql
-- 1. 查询所有正常状态的用户
SELECT * FROM sys_user WHERE status = '0' AND del_flag = '0';

-- 2. 查询用户及其部门信息
SELECT u.*, d.dept_name
FROM sys_user u
LEFT JOIN sys_dept d ON u.dept_id = d.dept_id
WHERE u.del_flag = '0';

-- 3. 统计每个部门的用户数量
SELECT d.dept_name, COUNT(u.user_id) as count
FROM sys_dept d
LEFT JOIN sys_user u ON d.dept_id = u.dept_id
GROUP BY d.dept_id, d.dept_name;
```

### 3. 使用 ORM

```python
# 使用项目配置，写一个简单的查询函数
async def get_users_by_dept(db: AsyncSession, dept_id: int):
    """查询指定部门的所有用户"""
    stmt = select(SysUser).where(
        SysUser.dept_id == dept_id,
        SysUser.del_flag == '0'
    )
    result = await db.execute(stmt)
    return result.scalars().all()
```

---

## 检查清单

学完本节后，你应该能够：

- [ ] 理解数据库的基本概念
- [ ] 能写基本的 SQL 查询语句
- [ ] 理解主键、外键、索引的作用
- [ ] 理解事务的 ACID 特性
- [ ] 理解一对一、一对多、多对多关系
- [ ] 理解 ORM 的作用和优势
- [ ] 能使用 SQLAlchemy 进行基本的数据库操作
- [ ] 理解连接池的作用

**下一步**: 学习 [REST API 设计原则](./04-REST_API设计原则.md)
