# 可维护性思维

> 代码的可维护性决定了项目的长期健康度。好代码易于理解、修改和扩展。

## 可维护性的核心

```
┌─────────────────────────────────┐
│     可维护性 =                  │
│   易读性 + 易测性 + 易扩展性     │
└─────────────────────────────────┘
```

---

## 1. 代码组织

### 分层架构

```
┌─────────────────────────────────┐
│      Controller 层              │  ←  处理 HTTP 请求
│  - 参数验证                     │
│  - 调用 Service                 │
│  - 返回响应                     │
├─────────────────────────────────┤
│       Service 层                │  ←  业务逻辑
│  - 业务规则                     │
│  - 事务管理                     │
│  - 调用 DAO                     │
├─────────────────────────────────┤
│       DAO 层                    │  ←  数据访问
│  - 数据库操作                   │
│  - SQL 查询                     │
└─────────────────────────────────┘
```

### 单一职责

```python
# ❌ 一个函数做多件事
async def handle_user(user_data: dict):
    # 验证数据
    if not user_data.get("name"):
        raise ValueError("name is required")

    # 保存到数据库
    await db.execute(insert(SysUser).values(user_data))

    # 发送欢迎邮件
    await send_email(user_data["email"], "Welcome!")

    # 记录日志
    logger.info(f"User created: {user_data['name']}")

# ✅ 拆分为多个函数
async def validate_user_data(user_data: dict):
    if not user_data.get("name"):
        raise ValueError("name is required")

async def save_user(user_data: dict):
    await db.execute(insert(SysUser).values(user_data))

async def send_welcome_email(email: str):
    await send_email(email, "Welcome!")

# 主函数只负责协调
async def handle_user(user_data: dict):
    await validate_user_data(user_data)
    await save_user(user_data)
    await send_welcome_email(user_data["email"])
    logger.info(f"User created: {user_data['name']}")
```

### 模块化

```python
# ❌ 所有代码在一个文件
# user_controller.py (3000+ 行)

# ✅ 按功能拆分模块
# user/
#   ├── __init__.py
#   ├── controller.py    # 控制器
#   ├── service.py       # 服务层
#   ├── dao.py           # 数据访问
#   ├── models.py        # 数据模型
#   └── schemas.py       # Pydantic 模型
```

---

## 2. 命名规范

### 变量命名

```python
# ❌ 不好的命名
d = get_data()
u = get_user()
flag = check()

# ✅ 好的命名
user_data = get_user_data()
current_user = get_current_user()
is_authenticated = check_authentication()

# 布尔值用 is/has/can 前缀
is_active = True
has_permission = True
can_delete = False
```

### 函数命名

```python
# ❌ 不好的命名
def process():
    pass

def do():
    pass

# ✅ 好的命名（动词开头）
def get_user(user_id: int):
    """获取用户"""
    pass

def create_user(user_data: dict):
    """创建用户"""
    pass

def validate_email(email: str):
    """验证邮箱"""
    pass

def calculate_total(items: list):
    """计算总计"""
    pass
```

### 类命名

```python
# ✅ 使用名词，首字母大写
class UserService:
    pass

class UserModel:
    pass

class PermissionException(Exception):
    pass

# 避免用类名重复表达
# ❌
class User:
    def get_user(self):
        pass

# ✅
class UserService:
    def get(self, user_id: int):
        pass
```

---

## 3. 注释与文档

### 文档字符串

```python
# ❌ 没有注释
async def get_user_list(page, size):
    stmt = select(SysUser).offset((page-1)*size).limit(size)
    return await db.execute(stmt)

# ✅ 完整的文档字符串
async def get_user_list(page: int, size: int) -> List[SysUser]:
    """
    获取用户列表（分页）

    Args:
        page: 页码，从1开始
        size: 每页数量，最大100

    Returns:
        用户列表

    Raises:
        ValueError: 当 page < 1 或 size > 100 时

    Example:
        >>> users = await get_user_list(1, 10)
        >>> len(users)
        10
    """
    if page < 1:
        raise ValueError("page must be >= 1")
    if size > 100:
        raise ValueError("size must be <= 100")

    stmt = select(SysUser).offset((page-1)*size).limit(size)
    return await db.execute(stmt)
```

### 行内注释

```python
# ❌ 无用的注释
# 获取用户列表
users = await get_user_list()

# ✅ 解释为什么，而不是做什么
# 使用缓存减少数据库查询（性能优化）
cached_data = await redis.get(key)
if cached_data:
    return json.loads(cached_data)

# ✅ 解释复杂逻辑
# 计算密码错误次数，超过5次锁定账号
error_count = await redis.incr(f"password_error:{username}")
if error_count >= 5:
    # 锁定10分钟
    await redis.setex(f"account_lock:{username}", 600, "1")
```

---

## 4. 错误处理

### 明确的错误信息

```python
# ❌ 模糊的错误
raise Exception("Error")

# ✅ 明确的错误
raise UserNotFoundException(f"User {user_id} not found")
raise InvalidPasswordException("Password must be at least 8 characters")
```

### 自定义异常

```python
# exceptions/exception.py
class BaseServiceException(Exception):
    """业务异常基类"""
    def __init__(self, message: str = "操作失败", data: Any = None):
        self.message = message
        self.data = data
        super().__init__(self.message)

class UserNotFoundException(BaseServiceException):
    """用户不存在异常"""
    pass

class PermissionDeniedException(BaseServiceException):
    """权限不足异常"""
    pass

# 使用
if not user:
    raise UserNotFoundException(f"User {user_id} not found")
```

### 错误处理策略

```python
# ❌ 吞掉异常
try:
    result = await some_operation()
except:
    pass  # 忽略所有错误

# ✅ 记录并重新抛出
try:
    result = await some_operation()
except SpecificException as e:
    logger.error(f"Operation failed: {e}")
    raise  # 重新抛出，让上层处理

# ✅ 提供回滚逻辑
async def create_order(order_data: dict):
    try:
        # 创建订单
        order = await create_order_in_db(order_data)

        # 扣减库存
        await update_inventory(order.product_id, order.quantity)

    except InventoryError as e:
        # 回滚订单
        await delete_order(order.order_id)
        logger.error(f"Create order failed: {e}")
        raise
```

---

## 5. 测试

### 单元测试

```python
import pytest
from unittest.mock import AsyncMock, patch

@pytest.mark.asyncio
async def test_get_user_found():
    """测试：用户存在"""
    # Arrange
    user_id = 1
    expected_user = SysUser(user_id=1, user_name="admin")

    # Act
    with patch('module_admin.dao.user_dao.select') as mock_select:
        mock_execute = AsyncMock()
        mock_execute.scalar_one_or_none.return_value = expected_user
        mock_select.return_value.where.return_value = mock_select
        result = await UserService.get_user_by_id(AsyncMock(), user_id)

    # Assert
    assert result.user_name == "admin"

@pytest.mark.asyncio
async def test_get_user_not_found():
    """测试：用户不存在"""
    user_id = 999

    with patch('module_admin.dao.user_dao.select') as mock_select:
        mock_execute = AsyncMock()
        mock_execute.scalar_one_or_none.return_value = None
        mock_select.return_value.where.return_value = mock_select

        with pytest.raises(UserNotFoundException):
            await UserService.get_user_by_id(AsyncMock(), user_id)
```

### 集成测试

```python
@pytest.mark.asyncio
async def test_create_order_flow():
    """测试：订单创建完整流程"""
    async with async_session_maker() as session:
        # 1. 创建用户
        user = SysUser(user_name="test", email="test@example.com")
        session.add(user)
        await session.commit()

        # 2. 创建商品
        product = SysProduct(product_name="商品", stock=100)
        session.add(product)
        await session.commit()

        # 3. 创建订单
        order = await OrderService.create_order(session, {
            "user_id": user.user_id,
            "product_id": product.product_id,
            "quantity": 1
        })

        # 4. 验证结果
        assert order.order_id is not None
        assert order.total_amount > 0

        # 5. 验证库存扣减
        updated_product = await session.get(SysProduct, product.product_id)
        assert updated_product.stock == 99
```

---

## 6. 配置管理

### 环境变量

```python
# ❌ 硬编码配置
DATABASE_URL = "mysql://user:pass@localhost/db"
SECRET_KEY = "my-secret-key"

# ✅ 使用环境变量
import os
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")
SECRET_KEY = os.getenv("SECRET_KEY")

if not SECRET_KEY:
    raise ValueError("SECRET_KEY must be set")
```

### 配置类

```python
# config/env.py
from pydantic_settings import BaseSettings

class AppConfig(BaseSettings):
    # 应用配置
    app_name: str = "RuoYi-FastAPI"
    app_env: str = "dev"
    debug: bool = False

    # 数据库配置
    database_url: str

    # Redis 配置
    redis_host: str = "localhost"
    redis_port: int = 6379
    redis_password: str = ""

    # JWT 配置
    jwt_secret_key: str
    jwt_expire_minutes: int = 30

    class Config:
        env_file = ".env"

# 使用
config = AppConfig()
print(f"Starting {config.app_name} in {config.app_env} mode")
```

---

## 7. 代码审查清单

提交代码前检查：

### 功能
- [ ] 代码实现了需求
- [ ] 边界情况已处理
- [ ] 错误情况已处理

### 可读性
- [ ] 变量命名清晰
- [ ] 函数命名准确
- [ ] 代码有适当注释
- [ ] 复杂逻辑有文档

### 可维护性
- [ ] 函数职责单一
- [ ] 避免重复代码
- [ ] 模块划分合理
- [ ] 依赖关系清晰

### 测试
- [ ] 有单元测试
- [ ] 测试覆盖主要场景
- [ ] 测试可以重复运行

### 性能
- [ ] 无明显性能问题
- [ ] 数据库查询已优化
- [ ] 没有内存泄漏

### 安全
- [ ] 输入已验证
- [ ] 敏感数据已加密
- [ ] 有权限检查
- [ ] 无安全漏洞

---

## 可维护性原则

1. **KISS 原则 (Keep It Simple, Stupid)**
```
保持简单，避免不必要的复杂性

❌ 过度设计
✅ 简单直接
```

2. **DRY 原则 (Don't Repeat Yourself)**
```
避免重复，提取公共逻辑

❌ 复制粘贴代码
✅ 提取为函数/类
```

3. **YAGNI 原则 (You Aren't Gonna Need It)**
```
只实现当前需要的功能

❌ 提前实现可能需要的功能
✅ 需要时再添加
```

4. **代码审查**
```
定期审查代码质量

- 自我审查
- 同事审查
- 自动化工具
```

---

## 总结

可维护性是长期项目成功的关键：

| 方面 | 具体做法 |
|------|----------|
| **组织** | 分层架构、模块化 |
| **命名** | 清晰准确、符合规范 |
| **注释** | 解释为什么，而非做什么 |
| **测试** | 单元测试、集成测试 |
| **配置** | 环境变量、配置类 |
| **审查** | 定期代码审查 |

**记住**：
> 代码写一次，会被读很多次。为读者编写代码。

**恭喜！** 你已经完成了后端思维培养的学习。继续在项目中实践这些思维，不断提升！
