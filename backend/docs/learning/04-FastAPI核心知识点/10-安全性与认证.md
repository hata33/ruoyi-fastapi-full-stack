# å®‰å…¨æ€§ä¸è®¤è¯

## å­¦ä¹ ç›®æ ‡

- ç†è§£ JWT è®¤è¯åŸç†
- æŒæ¡ OAuth2 æˆæƒæµç¨‹
- å­¦ä¹ å¯†ç åŠ å¯†å­˜å‚¨
- ç†è§£ RBAC æƒé™æ§åˆ¶
- æŒæ¡å®‰å…¨æœ€ä½³å®è·µ

## 1. JWT è®¤è¯

### 1.1 JWT åŸºç¡€

JWT (JSON Web Token) æ˜¯ä¸€ç§å¼€æ”¾æ ‡å‡† (RFC 7519)ï¼Œç”¨äºåœ¨å„æ–¹ä¹‹é—´å®‰å…¨åœ°ä¼ è¾“ä¿¡æ¯ã€‚

**JWT ç»„æˆéƒ¨åˆ†ï¼š**

```mermaid
graph LR
    A[Header] --> B[Payload]
    B --> C[Signature]

    A[Header] --> A1[alg: HS256]
    A[Header] --> A2[typ: JWT]

    B[Payload] --> B1[iss: ç­¾å‘è€…]
    B[Payload] --> B2[sub: ç”¨æˆ·ID]
    B[Payload] --> B3[exp: è¿‡æœŸæ—¶é—´]

    C[Signature] --> C1[HMACSHA256]
```

### 1.2 JWT ç”Ÿæˆä¸éªŒè¯

```python
import jwt
from datetime import datetime, timedelta

SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"

def create_access_token(data: dict, expires_delta: timedelta = None):
    """ç”Ÿæˆè®¿é—®ä»¤ç‰Œ"""
    to_encode = data.copy()

    # è®¾ç½®è¿‡æœŸæ—¶é—´
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=30)

    to_encode.update({"exp": expire})

    # ç”Ÿæˆ JWT
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str):
    """éªŒè¯ä»¤ç‰Œ"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise AuthException('Token å·²è¿‡æœŸ')
    except jwt.InvalidTokenError:
        raise AuthException('Token æ— æ•ˆ')
```

### 1.3 é¡¹ç›®ä¸­çš„è®¤è¯å®ç°

**æ–‡ä»¶ï¼š** `core/exhale.py` æˆ–ç›¸å…³è®¤è¯æ¨¡å—

```python
from fastapi import Depends, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """è·å–å½“å‰ç”¨æˆ·"""
    token = credentials.credentials

    # éªŒè¯ Token
    try:
        payload = decode_token(token)
        user_id = payload.get('sub')

        # æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯
        user = await get_user_by_id(user_id)
        if not user:
            raise HTTPException(status_code=401, detail='ç”¨æˆ·ä¸å­˜åœ¨')

        return user
    except Exception:
        raise HTTPException(status_code=401, detail='è®¤è¯å¤±è´¥')

# ä½¿ç”¨
@router.get('/users')
async def get_users(
    current_user: UserModel = Depends(get_current_user)
):
    """éœ€è¦è®¤è¯çš„æ¥å£"""
    return current_user
```

## 2. OAuth2 æˆæƒ

### 2.1 OAuth2 æµç¨‹

```mermaid
sequenceDiagram
    autonumber
    participant User as ğŸ‘¤ ç”¨æˆ·
    participant Client as ğŸ–¥ï¸ åº”ç”¨
    participant Auth as ğŸ” è®¤è¯æœåŠ¡å™¨
    participant Resource as ğŸ“Š èµ„æºæœåŠ¡å™¨

    Note over User,Resource: OAuth2 æˆæƒæµç¨‹

    User->>Client: è®¿é—®èµ„æº
    Client->>Auth: è¯·æ±‚æˆæƒ

    Auth->>User: æ˜¾ç¤ºæˆæƒé¡µé¢
    User->>Auth: æˆæƒ

    Auth->>Client: è¿”å›æˆæƒç 
    Client->>Auth: ç”¨æˆæƒç æ¢å– Token

    Auth->>Client: è¿”å›è®¿é—® Token
    Client->>Resource: ä½¿ç”¨ Token è®¿é—®èµ„æº
    Resource->>Auth: éªŒè¯ Token
    Resource->>Client: è¿”å›èµ„æºæ•°æ®
```

### 2.2 FastAPI OAuth2

```python
from fastapi import Depends
from fastapi.security import OAuth2PasswordBearer

oauth2_scheme = OAuth2PasswordBearer(tokenUrl='token')

@router.post('/login')
async def login(
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """OAuth2 å¯†ç ç™»å½•"""
    # éªŒè¯ç”¨æˆ·åå¯†ç 
    user = await authenticate_user(
        form_data.username,
        form_data.password
    )

    if not user:
        raise HTTPException(
            status_code=400,
            detail='ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'
        )

    # ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
    access_token = create_access_token(
        data={'sub': user.user_id, 'name': user.user_name}
    )

    return {'access_token': access_token, 'token_type': 'bearer'}
```

## 3. å¯†ç åŠ å¯†

### 3.1 bcrypt å“ˆå¸Œ

```python
import bcrypt

def hash_password(password: str) -> str:
    """å“ˆå¸Œå¯†ç """
    # ç”Ÿæˆç›å€¼å¹¶å“ˆå¸Œ
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """éªŒè¯å¯†ç """
    return bcrypt.checkpw(
        plain_password.encode('utf-8'),
        hashed_password.encode('utf-8')
    )
```

### 3.2 é¡¹ç›®ä¸­çš„å¯†ç å¤„ç†

**æ–‡ä»¶ï¼š** `utils/pwd_util.py`

```python
class PwdUtil:
    """å¯†ç å·¥å…·ç±»"""

    @staticmethod
    def get_password_hash(password: str) -> str:
        """è·å–å¯†ç å“ˆå¸Œ"""
        # ä½¿ç”¨ bcrypt è¿›è¡Œå“ˆå¸Œ
        pwd_hash = bcrypt.hashpw(
            password.encode('utf-8'),
            bcrypt.gensalt()
        )
        return pwd_hash.decode('utf-8')

    @staticmethod
    def verify_password(
        plain_password: str,
        hashed_password: str
    ) -> bool:
        """éªŒè¯å¯†ç """
        return bcrypt.checkpw(
            plain_password.encode('utf-8'),
            hashed_password.encode('utf-8')
        )
```

## 4. RBAC æƒé™æ§åˆ¶

### 4.1 æƒé™æ¨¡å‹

```mermaid
graph TD
    A[ç”¨æˆ·] --> B[è§’è‰²]
    B --> C[æƒé™]

    A1[admin] --> B1[ç®¡ç†å‘˜]
    B2[user] --> B2[æ™®é€šç”¨æˆ·]

    B1 --> C1[ç”¨æˆ·ç®¡ç†]
    B1 --> C2[è§’è‰²ç®¡ç†]
    B2 --> C3[æ•°æ®æŸ¥çœ‹]

    style A1 fill:#4CAF50
    style B1 fill:#FF9800
```

### 4.2 æƒé™æ£€æŸ¥

```python
from exceptions.exception import PermissionException

def check_permission(user: UserModel, permission: str):
    """æ£€æŸ¥æƒé™"""

    # ç®¡ç†å‘˜æ‹¥æœ‰æ‰€æœ‰æƒé™
    if user.admin:
        return True

    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ‹¥æœ‰æŒ‡å®šæƒé™
    user_permissions = await get_user_permissions(user.user_id)
    if permission not in user_permissions:
        raise PermissionException(
            message=f'ç¼ºå°‘æƒé™: {permission}',
            data={'permission': permission}
        )

    return True
```

## 5. å®‰å…¨æœ€ä½³å®è·µ

### 5.1 å¯†é’¥ç®¡ç†

```python
# âœ… å¥½çš„åšæ³•
from config.env import AppConfig

SECRET_KEY = AppConfig.SECRET_KEY  # ä»ç¯å¢ƒå˜é‡è¯»å–

# âŒ ä¸å¥½çš„åšæ³•
SECRET_KEY = "hardcoded-secret-key"  # ç¡¬ç¼–ç å¯†é’¥
```

### 5.2 Token æœ‰æ•ˆæœŸ

```python
# è®¿é—®ä»¤ç‰Œï¼šçŸ­æœŸï¼ˆ30åˆ†é’Ÿï¼‰
access_token_expires = timedelta(minutes=30)

# åˆ·æ–°ä»¤ç‰Œï¼šé•¿æœŸï¼ˆ7å¤©ï¼‰
refresh_token_expires = timedelta(days=7)

# è®°ä½ä»¤ç‰Œï¼šé•¿æœŸï¼ˆ30å¤©ï¼‰
remember_token_expires = timedelta(days=30)
```

### 5.3 HTTPS ä¼ è¾“

```python
# å§‹ç»ˆé€šè¿‡ HTTPS ä¼ è¾“æ•æ„Ÿä¿¡æ¯

@app.middleware("https")
async def force_https(request: Request, call_next):
    """å¼ºåˆ¶ HTTPS"""
    if request.url.scheme != 'https':
        url = request.url.replace('http://', 'https://')
        return RedirectResponse(url)

    response = await call_next(request)
    return response
```

## 6. æ€»ç»“

### 6.1 å®‰å…¨å±‚æ¬¡

| å±‚æ¬¡ | æªæ–½ | ç›®çš„ |
|------|------|------|
| **ä¼ è¾“å±‚** | HTTPS | é˜²æ­¢çªƒå¬ |
| **è®¤è¯å±‚** | JWT | èº«ä»½éªŒè¯ |
| **æˆæƒå±‚** | RBAC | æƒé™æ§åˆ¶ |
| **æ•°æ®å±‚** | åŠ å¯† | æ•°æ®ä¿æŠ¤ |

### 6.2 å®‰å…¨æ¸…å•

- [ ] ä½¿ç”¨ HTTPS
- [ ] å¯†é’¥å­˜å‚¨åœ¨ç¯å¢ƒå˜é‡
- [ ] å¯†ç ä½¿ç”¨ bcrypt å“ˆå¸Œ
- [ ] Token è®¾ç½®åˆç†è¿‡æœŸæ—¶é—´
- [ ] å®ç° RBAC æƒé™æ§åˆ¶
- [ ] å®šæœŸæ›´æ¢å¯†é’¥
- [ ] è®°å½•å®‰å…¨å®¡è®¡æ—¥å¿—

## 7. ä¸‹ä¸€æ­¥

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œç»§ç»­å­¦ä¹ ï¼š
- **[11-æ•°æ®åº“é›†æˆ](./11-æ•°æ®åº“é›†æˆ.md)** - å­¦ä¹ SQLAlchemy
