# 第二阶段：项目实战（4-6周）

> 本阶段深入理解 RuoYi-Vue3-FastAPI 项目的架构和核心功能实现。

## 学习目标

完成本阶段后，你将能够：

- ✅ 理解项目的分层架构
- ✅ 掌握 FastAPI 依赖注入的使用
- ✅ 理解登录功能的完整流程
- ✅ 掌握权限控制的实现原理
- ✅ 能够自己添加新的 API 接口

---

## Week 1-2: 理解架构

### Day 1-2: 项目结构

**学习文档**：
- [项目文件结构](../../start/01-file_structure.md)

**学习目标**：
- 理解项目的目录组织
- 理解分层架构（Controller → Service → DAO）
- 知道各个模块的作用

**实践**：
```
1. 启动项目
   cd ruoyi-fastapi-backend
   pip install -r requirements.txt
   python app.py --env=dev

2. 访问 API 文档
   http://localhost:9099/docs

3. 阅读代码
   - server.py（应用入口）
   - config/env.py（配置管理）
   - module_admin/controller/（控制器）
   - module_admin/service/（服务层）
   - module_admin/dao/（数据访问层）
```

**检查**：
- [ ] 能画出项目的分层架构图
- [ ] 知道每个目录的作用
- [ ] 能找到核心配置文件

---

### Day 3-4: 依赖注入

**学习文档**：
- [Depends 依赖注入](../../public/03-Depends.md)
- [数据库连接管理模块](../../start/05-数据库连接管理模块.md)

**学习目标**：
- 理解 FastAPI 依赖注入的工作原理
- 理解 get_db 的作用
- 能识别项目中的依赖注入使用

**代码阅读**：
```python
# config/get_db.py
async def get_db():
    async with AsyncSessionLocal() as session:
        yield session

# module_admin/controller/user_controller.py
@userController.get("/list")
async def get_user_list(
    query_db: AsyncSession = Depends(get_db)  # 依赖注入
):
    # 使用 query_db 进行数据库操作
    pass
```

**实践**：
```python
# 1. 写一个获取当前时间的依赖
async def get_current_time():
    from datetime import datetime
    return datetime.now()

@app.get("/time")
async def show_time(current_time = Depends(get_current_time)):
    return {"time": current_time}

# 2. 写一个验证 Token 的依赖
async def verify_token(token: str = Header(...)):
    # TODO: 验证 Token
    pass
```

**检查**：
- [ ] 能解释依赖注入的作用
- [ ] 知道 yield 在依赖注入中的用途
- [ ] 能自己写简单的依赖函数

---

### Day 5-7: 异步编程

**学习文档**：
- [async-await 异步编程](../../public/04-async-await.md)
- [异步上下文](../../start/19-异步上下文.md)

**学习目标**：
- 理解项目中的异步编程模式
- 理解为什么需要异步
- 能写异步的数据库操作

**代码阅读**：
```python
# 同步方式（阻塞）
def get_user(db, user_id):
    result = db.query(User).filter_by(id=user_id).first()
    return result

# 异步方式（非阻塞）
async def get_user(db, user_id):
    result = await db.execute(
        select(User).where(User.id == user_id)
    )
    return result.scalar_one_or_none()
```

**检查**：
- [ ] 理解 async/await 的作用
- [ ] 知道为什么要使用异步
- [ ] 能看懂项目中的异步代码

---

## Week 3-4: 核心功能

### Day 1-3: 登录功能

**学习文档**：
- [登录功能全链路流程详解](../../function/01-登录功能.md)
- [登录功能语法](../../function/02-登录功能-语法.md)

**学习目标**：
- 理解登录的完整流程
- 理解 JWT Token 的生成和验证
- 理解安全机制（密码错误计数、账号锁定）

**流程图**：
```
前端输入
  ↓
验证码校验
  ↓
密码错误计数检查
  ↓
数据库查询用户
  ↓
密码验证（bcrypt）
  ↓
生成 JWT Token
  ↓
存储到 Redis
  ↓
返回 Token 给前端
```

**代码跟踪**：
```python
# 1. 从 controller 开始
# module_admin/controller/login_controller.py
@masterController.post('/login')
async def login(request: Request, form_data: ..., query_db: AsyncSession = Depends(get_db)):
    result = await LoginService.authenticate_user(request, query_db, user)
    # ...

# 2. 跟踪到 service
# module_admin/service/login_service.py
@classmethod
async def authenticate_user(cls, request, db, login_user):
    # 验证码检查
    # IP 黑名单检查
    # 账号锁定检查
    # 用户查询
    # 密码验证
    # Token 生成

# 3. 使用断点调试，一步步跟踪
```

**检查**：
- [ ] 能画出登录功能的流程图
- [ ] 理解 JWT Token 的生成过程
- [ ] 理解密码验证的机制
- [ ] 知道为什么使用 Redis 存储 Token

---

### Day 4-5: 权限控制

**学习文档**：
- [权限 RBAC ABAC](../../function/08-权限-RBAC-ABAC.md)
- [Aspect 切面功能详解](../../feature/03-Aspect切面功能详解.md)

**学习目标**：
- 理解 RBAC 权限模型
- 理解数据权限和接口权限
- 知道如何实现权限控制

**权限模型**：
```
用户 (User)
  ↓ 拥有
角色 (Role) ── 拥有权限 ──> 权限 (Permission)
  ↓ 拥有
数据权限范围 (Data Scope)
  - 全部数据
  - 自定义数据
  - 本部门数据
  - 本部门及以下数据
  - 仅本人数据
```

**代码阅读**：
```python
# module_admin/aspect/interface_auth.py
class CheckUserInterfaceAuth:
    """接口权限校验"""
    async def __call__(self, current_user: CurrentUserService = Depends()):
        # 检查用户是否有指定权限
        if self.perms not in current_user.permissions:
            raise PermissionException()

# 使用
@userController.post("/add")
async def add_user(
    _: bool = Depends(CheckUserInterfaceAuth("system:user:add"))
):
    pass
```

**检查**：
- [ ] 理解 RBAC 权限模型
- [ ] 知道如何检查接口权限
- [ ] 理解数据权限的实现原理

---

### Day 6-7: 全局异常处理

**学习文档**：
- [全局异常处理机制](../../feature/04-全局异常处理机制.md)

**学习目标**：
- 理解全局异常处理的作用
- 知道如何定义自定义异常
- 理解异常处理的流程

**代码阅读**：
```python
# exceptions/exception.py
class AuthException(Exception):
    """认证异常"""
    def __init__(self, data: Any = None, message: str = ""):
        self.data = data
        self.message = message

# exceptions/handle.py
@app.exception_handler(AuthException)
async def auth_exception_handler(request: Request, exc: AuthException):
    return ResponseUtil.unauthorized(data=exc.data, msg=exc.message)
```

**检查**：
- [ ] 理解全局异常处理的好处
- [ ] 知道如何定义自定义异常
- [ ] 能处理常见的异常情况

---

## Week 5-6: 深入细节

### Day 1-2: 链路追踪

**学习文档**：
- [链路追踪 ASGI 中间件](../../start/15-链路追踪ASGI中间件.md)
- [TraceASGIMiddleware](../../start/16-TraceASGIMiddleware.md)

**学习目标**：
- 理解链路追踪的作用
- 知道如何实现请求追踪

**检查**：
- [ ] 理解 TraceId 的作用
- [ ] 知道如何在日志中追踪请求

---

### Day 3-4: 并发控制

**学习文档**：
- [数据库锁及并发操作](../../public/11-数据库锁及并发操作.md)

**学习目标**：
- 理解并发问题
- 知道如何使用锁
- 理解事务隔离级别

**检查**：
- [ ] 理解乐观锁和悲观锁
- [ ] 知道什么时候需要加锁
- [ ] 理解死锁的概念

---

### Day 5-7: 综合实践

**实践项目**：添加一个"公告管理"模块

要求：
1. 设计数据库表（参考 sys_notice）
2. 实现 CRUD 接口
3. 添加权限控制
4. 添加操作日志

```python
# 提示步骤：
# 1. 创建实体类（entity/do/notice_do.py）
# 2. 创建 DAO 层（dao/notice_dao.py）
# 3. 创建 Service 层（service/notice_service.py）
# 4. 创建 Controller 层（controller/notice_controller.py）
# 5. 注册路由
```

---

## 阶段检查点

完成第二阶段后，请检查：

- [ ] 能画出项目的分层架构图
- [ ] 理解依赖注入的工作原理
- [ ] 能解释登录功能的完整流程
- [ ] 理解权限控制的实现方式
- [ ] 理解全局异常处理机制
- [ ] 能自己添加一个新的 CRUD 接口
- [ ] 能使用断点调试跟踪代码执行

### 进入第三阶段的条件

如果以上检查点都能完成，恭喜你！可以进入 [第三阶段：思维进阶](../03-后端思维培养/README.md)。

如果有未掌握的内容，建议：
1. 重读相关项目文档
2. 多跟踪代码执行流程
3. 尝试自己实现类似功能
