## Python 中包装类的 3W 法则

## What（是什么）

**包装类是什么**：

### 1. 定义
包装类（Wrapper Class）是一种设计模式，用于将一个类或对象包装在另一个类中，以提供额外的功能、接口转换或数据验证。

### 2. 基本结构
```python
# 简单包装类示例
class StringWrapper:
    def __init__(self, value):
        self._value = str(value)  # 包装原始值
    
    def get_value(self):
        return self._value
    
    def uppercase(self):
        return self._value.upper()  # 提供额外功能

# 使用
wrapped = StringWrapper("hello")
print(wrapped.uppercase())  # HELLO
```

### 3. 在数据模型中的应用
```python
from pydantic import BaseModel

# 数据包装类（Pydantic 模型）
class UserLogin(BaseModel):
    username: str
    password: str
    email: str
    
    # 提供额外的验证和方法
    def is_valid_email(self):
        return "@" in self.email

# 使用
user_data = UserLogin(username="john", password="123", email="john@test.com")
```

## Why（为什么用）

**为什么要使用包装类**：

### 1. **数据验证和类型安全**
```python
from pydantic import BaseModel, validator

class UserRegistration(BaseModel):
    username: str
    password: str
    age: int
    
    @validator('age')
    def validate_age(cls, v):
        if v < 0 or v > 150:
            raise ValueError('年龄必须在0-150之间')
        return v
    
    @validator('password')
    def validate_password(cls, v):
        if len(v) < 6:
            raise ValueError('密码长度至少6位')
        return v

# 自动验证
try:
    user = UserRegistration(username="test", password="123", age=200)
except ValidationError as e:
    print(e)  # 自动捕获并处理验证错误
```

### 2. **接口适配和转换**
```python
# 原始数据格式
raw_data = {
    "user_name": "john_doe",
    "pass_word": "secret123",
    "user_age": "25"
}

# 包装类进行字段映射和类型转换
class UserDTO(BaseModel):
    username: str
    password: str
    age: int
    
    class Config:
        # 字段别名映射
        fields = {
            'username': 'user_name',
            'password': 'pass_word',
            'age': 'user_age'
        }

# 自动转换
user = UserDTO(**raw_data)  # 字段映射 + 类型转换
```

### 3. **业务逻辑封装**
```python
class BankAccount:
    def __init__(self, balance: float):
        self._balance = balance
    
    def get_balance(self) -> float:
        return self._balance
    
    def deposit(self, amount: float):
        if amount <= 0:
            raise ValueError("存款金额必须大于0")
        self._balance += amount
    
    def withdraw(self, amount: float):
        if amount > self._balance:
            raise ValueError("余额不足")
        self._balance -= amount

# 包装原始数值，提供安全的操作接口
account = BankAccount(1000.0)
account.deposit(500)    # 安全操作
account.withdraw(200)   # 安全操作
```

### 4. **统一错误处理**
```python
class APIResponse(BaseModel):
    success: bool
    data: dict = None
    message: str = None
    code: int = 200
    
    @classmethod
    def success(cls, data=None):
        return cls(success=True, data=data, message="操作成功")
    
    @classmethod
    def error(cls, message="操作失败", code=400):
        return cls(success=False, message=message, code=code)

# 统一的响应格式
response = APIResponse.success({"user_id": 123})
error_response = APIResponse.error("用户名已存在")
```

## When（何时用）

**在以下场景中使用包装类**：

### 1. **数据传输对象（DTO）**
```python
# API 接口数据验证
class LoginRequest(BaseModel):
    username: str
    password: str
    captcha: Optional[str] = None

@app.post("/login")
async def login(request: LoginRequest):
    # 数据已自动验证，无需手动检查
    if authenticate(request.username, request.password):
        return {"success": True}
    return {"success": False}
```

### 2. **配置管理**
```python
class DatabaseConfig(BaseModel):
    host: str
    port: int = 5432
    username: str
    password: str
    database: str
    
    class Config:
        env_prefix = "DB_"  # 从环境变量读取配置

# 自动从环境变量加载配置
# DB_HOST=localhost DB_PORT=3306 ...
config = DatabaseConfig()
```

### 3. **复杂业务对象封装**
```python
class ShoppingCart:
    def __init__(self):
        self._items = []
        self._total = 0.0
    
    def add_item(self, product_id: str, price: float, quantity: int):
        item = {
            "product_id": product_id,
            "price": float(price),
            "quantity": int(quantity),
            "subtotal": float(price) * int(quantity)
        }
        self._items.append(item)
        self._total += item["subtotal"]
    
    def get_total(self) -> float:
        return self._total
    
    def get_items(self) -> list:
        return self._items.copy()

# 包装购物车逻辑
cart = ShoppingCart()
cart.add_item("product1", 29.99, 2)
print(f"总价: ${cart.get_total()}")
```

### 4. **第三方库适配**
```python
# 包装第三方库的复杂接口
class EmailServiceWrapper:
    def __init__(self, smtp_config):
        self.client = SMTPClient(smtp_config)
    
    def send_email(self, to: str, subject: str, content: str):
        # 简化接口
        message = EmailMessage()
        message['To'] = to
        message['Subject'] = subject
        message.set_content(content)
        
        try:
            self.client.send_message(message)
            return True
        except Exception as e:
            logger.error(f"邮件发送失败: {e}")
            return False

# 简化后的使用
email_service = EmailServiceWrapper(config)
email_service.send_email("user@example.com", "欢迎", "欢迎使用我们的服务")
```

### 5. **不应该使用包装类的场景**
```python
# ❌ 过度包装简单数据
class SimpleInt:  # 不必要
    def __init__(self, value: int):
        self.value = value

# ✅ 直接使用原生类型
number = 42

# ❌ 包装类只是为了包装而包装
class PointWrapper:  # 不必要
    def __init__(self, x, y):
        self.x = x
        self.y = y

# ✅ 直接使用命名元组或数据类
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
```

## 总结

**包装类的 3W 法则**：

**What**：包装类是将一个类或对象包装在另一个类中，以提供额外功能、接口转换或数据验证的设计模式

**Why**：用于数据验证、接口适配、业务逻辑封装和统一错误处理，提高代码的安全性和可维护性

**When**：在需要数据传输对象、配置管理、复杂业务对象封装和第三方库适配时使用；避免对简单数据进行不必要的包装