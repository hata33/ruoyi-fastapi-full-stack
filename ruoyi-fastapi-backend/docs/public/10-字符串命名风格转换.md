``` python
"""Alias generators for converting between different capitalization conventions."""

import re

__all__ = ('to_pascal', 'to_camel', 'to_snake')

# TODO: in V3, change the argument names to be more descriptive
# Generally, don't only convert from snake_case, or name the functions
# more specifically like snake_to_camel.


def to_pascal(snake: str) -> str:
    """Convert a snake_case string to PascalCase.

    Args:
        snake: The string to convert.

    Returns:
        The PascalCase string.
    """
    camel = snake.title()
    return re.sub('([0-9A-Za-z])_(?=[0-9A-Z])', lambda m: m.group(1), camel)


def to_camel(snake: str) -> str:
    """Convert a snake_case string to camelCase.

    Args:
        snake: The string to convert.

    Returns:
        The converted camelCase string.
    """
    # If the string is already in camelCase and does not contain a digit followed
    # by a lowercase letter, return it as it is
    if re.match('^[a-z]+[A-Za-z0-9]*$', snake) and not re.search(r'\d[a-z]', snake):
        return snake

    camel = to_pascal(snake)
    return re.sub('(^_*[A-Z])', lambda m: m.group(1).lower(), camel)


def to_snake(camel: str) -> str:
    """Convert a PascalCase, camelCase, or kebab-case string to snake_case.

    Args:
        camel: The string to convert.

    Returns:
        The converted string in snake_case.
    """
    # Handle the sequence of uppercase letters followed by a lowercase letter
    snake = re.sub(r'([A-Z]+)([A-Z][a-z])', lambda m: f'{m.group(1)}_{m.group(2)}', camel)
    # Insert an underscore between a lowercase letter and an uppercase letter
    snake = re.sub(r'([a-z])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)
    # Insert an underscore between a digit and an uppercase letter
    snake = re.sub(r'([0-9])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)
    # Insert an underscore between a lowercase letter and a digit
    snake = re.sub(r'([a-z])([0-9])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)
    # Replace hyphens with underscores to handle kebab-case
    snake = snake.replace('-', '_')
    return snake.lower()
```

这三个函数是 **字符串命名风格转换工具**，核心作用是在 Python 项目中常见的三种命名规范（`snake_case`、`camelCase`、`PascalCase`）之间进行自动转换，同时兼容数字与特殊场景（如 `kebab-case`）。下面逐函数拆解逻辑、效果与细节：


### 1. `to_pascal(snake: str) -> str`：snake_case → PascalCase
#### 功能定义
将「下划线分隔命名」（`snake_case`，如 `user_name`、`order_123_detail`）转换为「首字母全大写的驼峰命名」（`PascalCase`，如 `UserName`、`Order123Detail`），常用于类名、模型名（如 Pydantic 模型、数据库模型）。

#### 实现逻辑（两步）
```python
def to_pascal(snake: str) -> str:
    # 步骤1：将 snake_case 字符串转为 "每个单词首字母大写、其余小写" 的格式（title() 特性）
    # 例："user_name" → "User_Name"，"order_123_detail" → "Order_123_Detail"
    camel = snake.title()
    
    # 步骤2：用正则删除 "字母/数字" 后的下划线（仅匹配 "_后接字母/数字" 的场景）
    # 正则规则：([0-9A-Za-z])_(?=[0-9A-Z]) 
    # - 分组1：匹配任意字母/数字（确保下划线前是有效字符）
    # - _：匹配要删除的下划线
    # - 正向预查 (?=[0-9A-Z])：确保下划线后是字母/数字（避免删除无意义的下划线）
    # 例："User_Name" → "UserName"，"Order_123_Detail" → "Order123Detail"
    return re.sub('([0-9A-Za-z])_(?=[0-9A-Z])', lambda m: m.group(1), camel)
```

#### 效果示例
| 输入（snake_case）       | 输出（PascalCase）       |
|--------------------------|--------------------------|
| `user`                   | `User`                   |
| `user_name`              | `UserName`               |
| `order_123_detail`       | `Order123Detail`         |
| `_user_profile`（前导下划线） | `_UserProfile`（保留前导下划线，符合特殊场景需求） |


### 2. `to_camel(snake: str) -> str`：snake_case → camelCase（兼容已有camelCase检测）
#### 功能定义
将 `snake_case` 转换为「首字母小写、后续单词首字母大写」的 `camelCase`（如 `userName`、`order123Detail`），常用于变量名、函数名、API 参数（如前端传参 `pageNum`）；同时增加了「检测已有 `camelCase`」的逻辑，避免重复转换。

#### 实现逻辑（三步）
```python
def to_camel(snake: str) -> str:
    # 步骤1：先判断输入是否已经是合法的 camelCase（避免重复转换）
    # 正则规则1：^[a-z]+[A-Za-z0-9]*$ → 以小写字母开头，后续是字母/数字（无下划线）
    # 正则规则2：not re.search(r'\d[a-z]', snake) → 排除 "数字后接小写字母"（如 "user123name" 不是标准camelCase）
    # 例："userName" → 符合规则，直接返回；"user_name" → 不符合，进入后续转换
    if re.match('^[a-z]+[A-Za-z0-9]*$', snake) and not re.search(r'\d[a-z]', snake):
        return snake

    # 步骤2：先调用 to_pascal() 转为 PascalCase（复用逻辑，减少重复代码）
    # 例："user_name" → "UserName"，"order_123_detail" → "Order123Detail"
    camel = to_pascal(snake)

    # 步骤3：将 PascalCase 的首字母转为小写（核心区别：PascalCase 转 camelCase）
    # 正则规则：(^_*[A-Z]) → 匹配 "开头的下划线（可选）+ 第一个大写字母"
    # lambda 函数：将匹配到的内容（如 "U"、"_O"）转为小写
    # 例："UserName" → "userName"，"_Order123Detail" → "_order123Detail"（保留前导下划线）
    return re.sub('(^_*[A-Z])', lambda m: m.group(1).lower(), camel)
```

#### 效果示例
| 输入（snake_case/已有camelCase） | 输出（camelCase）        |
|----------------------------------|--------------------------|
| `userName`（已有camelCase）      | `userName`（直接返回）   |
| `user_name`                      | `userName`               |
| `order_123_detail`               | `order123Detail`         |
| `_user_profile`（前导下划线）     | `_userProfile`（保留前导下划线） |
| `user123name`（数字后接小写）    | 不匹配camelCase，转为 `user123Name` |


### 3. `to_snake(camel: str) -> str`：PascalCase/camelCase/kebab-case → snake_case
#### 功能定义
将 `PascalCase`（如 `UserName`）、`camelCase`（如 `userName`）、`kebab-case`（中划线命名，如 `user-profile`）统一转换为 `snake_case`（如 `user_name`），常用于后端变量名、数据库字段名（如 `user_name`），是前两个函数的「逆向操作」，且兼容更多输入格式。

#### 实现逻辑（五步，覆盖所有边界场景）
```python
def to_snake(camel: str) -> str:
    # 步骤1：处理 "连续大写字母+大写字母+小写字母"（如 "ABCUser" → "ABC_User"）
    # 正则规则：([A-Z]+)([A-Z][a-z]) → 分组1：连续大写；分组2：大写+小写
    # 例："ABCUser" → "ABC_User"，"OrderIDDetail" → "Order_ID_Detail"
    snake = re.sub(r'([A-Z]+)([A-Z][a-z])', lambda m: f'{m.group(1)}_{m.group(2)}', camel)
    
    # 步骤2：处理 "小写字母+大写字母"（核心：camelCase/PascalCase 转 snake_case）
    # 正则规则：([a-z])([A-Z]) → 分组1：小写；分组2：大写
    # 例："userName" → "user_name"，"ABC_User" → "a_b_c__user"（后续步骤会统一处理）
    snake = re.sub(r'([a-z])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)
    
    # 步骤3：处理 "数字+大写字母"（如 "order123Detail" → "order123_detail"）
    # 正则规则：([0-9])([A-Z]) → 分组1：数字；分组2：大写
    # 例："order123Detail" → "order123_detail"，"User2024Profile" → "user2024_profile"
    snake = re.sub(r'([0-9])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)
    
    # 步骤4：处理 "小写字母+数字"（如 "userProfile2024" → "user_profile_2024"）
    # 正则规则：([a-z])([0-9]) → 分组1：小写；分组2：数字
    # 例："userProfile2024" → "user_profile_2024"，"orderDetail123" → "order_detail_123"
    snake = re.sub(r'([a-z])([0-9])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)
    
    # 步骤5：处理 kebab-case（中划线转下划线）+ 统一转为小写
    # 例："user-profile" → "user_profile"，"Order-Detail-123" → "order_detail_123"
    snake = snake.replace('-', '_').lower()
    
    return snake
```

#### 效果示例
| 输入（PascalCase/camelCase/kebab-case） | 输出（snake_case）       |
|-----------------------------------------|--------------------------|
| `UserName`（PascalCase）                | `user_name`              |
| `order123Detail`（camelCase）           | `order123_detail`        |
| `user-profile`（kebab-case）            | `user_profile`           |
| `ABCUser`（连续大写）                   | `abc_user`               |
| `User2024Profile`（字母+数字）          | `user_2024_profile`      |


### 三个函数的核心价值与使用场景
| 函数名       | 转换方向                  | 典型使用场景                          |
|--------------|---------------------------|---------------------------------------|
| `to_pascal`  | snake_case → PascalCase   | 类名、Pydantic 模型名、数据库表名     |
| `to_camel`   | snake_case → camelCase    | API 参数、前端变量名、函数名          |
| `to_snake`   | 多格式 → snake_case       | 后端变量名、数据库字段名、配置键名    |

它们的设计亮点在于：
1. **复用逻辑**：`to_camel` 复用 `to_pascal` 的代码，减少冗余；
2. **边界兼容**：支持前导下划线、数字、`kebab-case` 等特殊场景；
3. **防重复转换**：`to_camel` 会检测已有 `camelCase`，避免错误处理。

在实际项目中，这类工具常用于「前后端数据交互」（如前端 `camelCase` 转后端 `snake_case`）、「代码自动生成」（如根据数据库表名生成模型类名）等场景，大幅减少手动转换的工作量。