### 系统字典参数命名映射与兼容策略

本文解释：为什么前端传入驼峰命名（camelCase）的查询参数，在后端依然可以使用“中划线/kebab-case”或其他形式的参数名被正确解析；并结合 `dict_vo.py`、`pydantic_annotation.py`、`dict_dao.py` 说明其原理。

---

#### 一、核心结论
- 前端常用参数命名：`camelCase`（如 `dictType`, `pageNum`）。
- 后端之所以“看起来”可以接受其他风格（例如带中划线），是因为我们使用了“模型别名 + 依赖注入签名改写”的组合方案，让 FastAPI 按“字符串别名”取参，而不是按 Python 标识符取参。
- 因为参数是在请求查询字符串里（URL 上），FastAPI 会用“查询参数名字符串”进行匹配；该名字可以是 `dictType`，也可以设置为 `dict-type` 等。我们通过装饰器把“参数签名”改写为任意别名字符串后，框架会用该字符串从请求中取值，最终再交由 Pydantic 模型进行解析与校验。

> 实际项目中我们统一采用驼峰（camelCase）作为对外别名：保证与前端保持一致。之所以“中划线也能用”，是框架与装饰器机制允许，但非推荐对外标准。

---

#### 二、关键代码与机制

##### 1) `dict_vo.py`：模型别名（alias）= camelCase
```python
class DictTypePageQueryModel(DictTypeQueryModel):
    model_config = ConfigDict(alias_generator=to_camel, from_attributes=True)
    page_num: int = Field(default=1, description='当前页码')
    page_size: int = Field(default=10, description='每页记录数')
```
- `alias_generator=to_camel`：Pydantic v2 会将模型字段 `page_num`, `page_size` 的“对外别名”生成为 `pageNum`, `pageSize`。
- 这样，前端传 `?pageNum=1&pageSize=10` 能被模型正确识别。

##### 2) `pydantic_annotation.py`：把“模型字段别名”改写进依赖函数签名
```python
for field_name, model_field in cls.model_fields.items():
    # 关键点：使用 model_field.alias 作为签名中的参数名
    inspect.Parameter(
        model_field.alias,
        inspect.Parameter.POSITIONAL_ONLY,
        default=Query(default=model_field.default, description=model_field.description),
        annotation=model_field.annotation,
    )
...
# 绑定到类方法 as_query，供 FastAPI 依赖注入使用
setattr(cls, 'as_query', as_query_func)
```
- 装饰器 `@as_query` 会动态创建一个依赖函数，其“参数签名”的参数名就是模型字段的“别名”（alias）。
- 也就是说，FastAPI 会按“别名字符串”去从请求 URL 的查询参数里取值，而不是按 Python 变量名。
- 使用 `POSITIONAL_ONLY` 规避了 Python 形参必须是合法标识符的问题（例如别名里含有中划线时，依然可以在签名中声明）。

> 这意味着：如果你把别名设置为 `dict-type`，FastAPI 也能从 `?dict-type=xxx` 里取到值。但项目规范中我们统一使用 `camelCase` 别名（如 `dictType`）。

##### 3) `dict_controller.py`：依赖注入采用模型 `.as_query`
```python
@dictController.get('/type/list', ...)
async def get_system_dict_type_list(
    request: Request,
    dict_type_page_query: DictTypePageQueryModel = Depends(DictTypePageQueryModel.as_query),
    query_db: AsyncSession = Depends(get_db),
):
    ...
```
- 这里的 `DictTypePageQueryModel.as_query` 就是上一步装饰器动态注入的依赖函数，里面的参数名就是“模型别名”。
- 因此前端传 `?dictName=...&dictType=...&pageNum=1&pageSize=10` 会被正确解析为模型字段。

##### 4) `dict_dao.py`：DAO 层仅消费模型数据
```python
async def get_dict_type_list(db: AsyncSession, query_object: DictTypePageQueryModel, is_page: bool = False):
    query = (
        select(SysDictType)
        .where(
            SysDictType.dict_name.like(f'%{query_object.dict_name}%') if query_object.dict_name else True,
            SysDictType.dict_type.like(f'%{query_object.dict_type}%') if query_object.dict_type else True,
            SysDictType.status == query_object.status if query_object.status else True,
            ...
        )
    )
    return await PageUtil.paginate(db, query, query_object.page_num, query_object.page_size, is_page)
```
- 到了 DAO 层已经是 Python 内部世界，直接通过模型字段（蛇形命名）访问；别名问题只存在于“请求参数解析阶段”。

---

#### 三、为什么“中划线参数名”也能用？
- FastAPI 解析查询参数是按“字符串 key”匹配，不要求这个 key 是合法的 Python 标识符。
- 我们的 `@as_query` 动态签名把“参数名”换成了“模型别名字符串”。理论上这个别名可以是 `dict-type` 这样的中划线形式，框架依然能从 `?dict-type=...` 中取值。
- 由于使用了 `POSITIONAL_ONLY` 参数位，避免了 Python 在调用依赖函数时需要以关键字参数形式传入的限制，从而允许别名里包含中划线。

> 再次强调：这是一种“能力”，不是项目“规范”。实际规范是对外使用 `camelCase` 别名，以与前端约定保持一致，便于统一与可读性。

---

#### 四、前后端参数命名建议
- 对外统一：`camelCase`（示例：`dictType`, `dictName`, `pageNum`, `pageSize`）。
- 内部 Python 代码：`snake_case`（示例：`dict_type`, `dict_name`, `page_num`, `page_size`）。
- 如需临时兼容历史中划线参数（`kebab-case`），可在 `alias_generator` 或装饰器处针对性设置别名，但不建议作为常规风格使用。

---

#### 五、排查与调试技巧
- 打开接口文档（Swagger/Redoc）查看参数名是否为 `camelCase`：这由模型别名与依赖签名共同决定。
- 若某个参数未解析，确认：
  - 该字段是否在对应模型中定义；
  - 模型是否启用了 `alias_generator=to_camel`；
  - 控制器是否使用了 `Model.as_query` 依赖；
  - 前端实际请求的 query key 与文档展示是否一致。

---

#### 六、简短例子
- 前端请求：
```
GET /system/dict/type/list?dictName=状态&dictType=sys_normal_disable&pageNum=1&pageSize=10
```
- 后端解析：
  - `DictTypePageQueryModel.as_query` 使用别名 `dictName`、`dictType`、`pageNum`、`pageSize` 解析
  - Pydantic 模型接收并映射到字段 `dict_name`、`dict_type`、`page_num`、`page_size`
  - DAO 读取模型字段构造 SQLAlchemy 查询

这样即可实现“前端 camelCase / 后端 snake_case”的双向友好，同时具备对任意别名字符串（包括中划线）的兼容能力。
