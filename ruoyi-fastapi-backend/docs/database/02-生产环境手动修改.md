针对多人维护、允许手动修改的项目（含生产环境），核心原则是 **“先备份、再变更、留记录、强校验”**——用最小的流程成本规避数据丢失和环境不一致风险，以下是可落地的通用操作规范：


# 通用表结构增删改操作规范（生产环境适用）
## 一、前置准备：变更前必做2件事
### 1. 数据备份（核心，避免删库跑路）
- **备份范围**：至少备份“待变更表”的全量数据，若表数据量大（10万+行），可备份近3个月增量数据（但全量优先）；
- **备份方式**：
  - 轻量场景：用 `SELECT * INTO 备份表 FROM 原表` 创建备份表（如 `sys_file` 备份为 `sys_file_bak_20241001`，后缀为操作日期）；
    ```sql
    -- MySQL/PostgreSQL 通用备份表语法
    CREATE TABLE sys_file_bak_20241001 AS SELECT * FROM sys_file;
    ```
  - 正式场景：用数据库工具（Navicat、pgAdmin）导出表数据为 SQL/CSV 文件，存到项目“备份目录”（如 `docs/db_backup/20241001/`）；
- **校验备份**：备份后执行 `SELECT COUNT(*) FROM 备份表`，确认备份数据量与原表一致，避免空备份。

### 2. 环境确认（避免改错库）
- 明确操作的环境（开发/测试/生产），在 SQL 工具中执行 `SELECT DATABASE()`（MySQL）或 `SELECT current_database()`（PostgreSQL），确认当前连接的库是目标库；
- 若生产环境有“只读从库”，需先确认变更是否需要同步到从库（通常主库变更后从库自动同步，但需提前告知运维）。


## 二、具体操作规范：增/删/改分别处理
### 1. 新增字段（风险最低，优先按此流程）
#### 步骤1：模型层（SQLAlchemy DO）先定义字段
在对应 DO 类中添加字段（如给 `SysFile` 加 `file_type`），确保字段类型、默认值、注释与预期一致：
```python
# models.py
class SysFile(Base):
    __tablename__ = "sys_file"
    # 原有字段...
    file_type = Column(String(50), default="unknown", comment="文件类型（如.jpg/.pdf）")  # 新增字段
```

#### 步骤2：生产库执行 SQL 新增字段
用 `ALTER TABLE` 语句新增字段，**必须指定默认值**（避免新增字段时因 `NOT NULL` 导致插入报错）：
```sql
-- 给 sys_file 加 file_type 字段，默认值为 unknown
ALTER TABLE sys_file 
ADD COLUMN file_type VARCHAR(50) NOT NULL DEFAULT 'unknown' COMMENT '文件类型（如.jpg/.pdf）';
```
- 若字段允许为 `NULL`，可去掉 `NOT NULL`，但需在模型中同步设置 `nullable=True`；
- 执行后用 `DESC sys_file`（MySQL）或 `\d sys_file`（PostgreSQL）确认字段已新增。

#### 步骤3：校验功能可用性
- 重启 FastAPI 服务（确保模型变更生效）；
- 测试“新增数据”（如上传文件），确认 `file_type` 字段能正常写入；
- 测试“查询数据”（如列表接口），确认返回结果包含 `file_type`，且默认值正确。


### 2. 修改字段（风险中等，分“安全修改”和“危险修改”）
#### （1）安全修改（推荐，无数据丢失风险）
包括：扩大字段长度（如 `VARCHAR(100)` → `VARCHAR(200)`）、修改字段注释、调整默认值（仅影响新增数据）。
##### 步骤1：模型层先修改
```python
# models.py：将 file_name 长度从 100 扩到 200
file_name = Column(String(200), comment="文件名（扩大长度支持长文件名）")
```

##### 步骤2：生产库执行 SQL 修改
```sql
-- MySQL：扩大 file_name 长度
ALTER TABLE sys_file MODIFY COLUMN file_name VARCHAR(200) NOT NULL COMMENT '文件名（扩大长度支持长文件名）';
-- PostgreSQL：扩大 file_name 长度（PostgreSQL 无需 MODIFY，直接 ALTER）
ALTER TABLE sys_file ALTER COLUMN file_name TYPE VARCHAR(200);
```

##### 步骤3：校验
- 执行 `DESC sys_file` 确认字段长度已变更；
- 测试“修改数据”（如更新文件名），确认长文件名能正常保存。

#### （2）危险修改（谨慎，可能导致数据丢失）
包括：修改字段类型（如 `INT` → `VARCHAR`）、缩小字段长度（如 `VARCHAR(200)` → `VARCHAR(100)`）。
##### 额外前置步骤：评估数据兼容性
- 先执行 `SELECT DISTINCT 字段名 FROM 原表`，确认现有数据能否转换为新类型（如 `INT` 转 `VARCHAR` 通常兼容，但 `VARCHAR` 转 `INT` 需确保所有值都是数字）；
- 若缩小字段长度，需执行 `SELECT MAX(LENGTH(字段名)) FROM 原表`，确认最大长度 ≤ 新长度（否则会截断数据）。

##### 执行修改（同安全修改步骤2）
```sql
-- 仅示例：将 file_size（原 INT）改为 VARCHAR(20)（需确保现有数据是数字字符串）
ALTER TABLE sys_file MODIFY COLUMN file_size VARCHAR(20) NOT NULL COMMENT '文件大小（改为字符串存储，如"10MB"）';
```

##### 校验：全量数据检查
执行 `SELECT 字段名 FROM 原表 LIMIT 100`，确认现有数据未被破坏（如无乱码、无截断）。


### 3. 删除字段（风险最高，严格限制场景）
#### 仅允许删除的场景
- 字段从未使用过（无任何数据，或数据全为默认值且业务无依赖）；
- 字段已废弃超过3个月，且确认所有接口、报表、脚本都不再引用该字段。

#### 步骤1：代码层先删除引用
- 删除 DO 类中对应的字段；
- 全局搜索项目代码（如 VS Code 搜 `字段名`），确认接口、Service、前端代码均不再使用该字段（避免删除后代码报错）；
- 若有定时任务、报表脚本，需同步检查并修改。

#### 步骤2：生产库执行 SQL 删除
```sql
-- 仅删除确认无用的字段！删除后数据无法恢复（依赖备份）
ALTER TABLE sys_file DROP COLUMN file_size;
```

#### 步骤3：紧急校验
- 执行 `DESC sys_file` 确认字段已删除；
- 重启 FastAPI 服务，测试所有相关接口（列表、详情、新增、修改），确认无报错；
- 若发现误删，立即用备份表恢复数据：
  ```sql
  -- 从备份表恢复字段（示例）
  ALTER TABLE sys_file ADD COLUMN file_size INT COMMENT '文件大小（字节）';
  UPDATE sys_file t1 
  JOIN sys_file_bak_20241001 t2 ON t1.id = t2.id 
  SET t1.file_size = t2.file_size;
  ```


## 三、变更后：留记录+同步环境
### 1. 记录变更文档
在项目 `docs/db_change/` 目录下新建 Markdown 文件（命名格式：`20241001_变更人_表名_操作.md`），记录：
- 变更目的：为什么要改（如“支持长文件名，需扩大 file_name 长度”）；
- 变更 SQL：完整的执行语句（含备份语句）；
- 变更时间：操作时间（精确到分钟）；
- 校验结果：数据量是否一致、接口是否正常。

### 2. 同步所有环境
- 开发/测试库必须同步执行相同的变更 SQL（避免环境不一致导致开发测正常、生产报错）；
- 告知团队其他成员“已执行表结构变更”，提醒他们更新本地代码（拉取最新 DO 类）。


## 四、应急处理：变更出错怎么办？
1. **执行 SQL 时报错**（如语法错误、字段已存在）：
   - 立即停止操作，执行 `ROLLBACK`（若用了事务）；
   - 检查 SQL 语法（如 MySQL 和 PostgreSQL 的 `ALTER` 语法差异），修正后重新执行。

2. **变更后发现数据异常**（如字段值乱码、数据丢失）：
   - 立即停止业务写入（如暂时关闭上传接口）；
   - 用备份表恢复数据：
     ```sql
     -- 1. 先删除异常字段
     ALTER TABLE sys_file DROP COLUMN file_type;
     -- 2. 重新新增字段
     ALTER TABLE sys_file ADD COLUMN file_type VARCHAR(50) NOT NULL DEFAULT 'unknown';
     -- 3. 从备份表同步正确数据
     UPDATE sys_file t1 
     JOIN sys_file_bak_20241001 t2 ON t1.id = t2.id 
     SET t1.file_type = t2.file_type;
     ```
   - 恢复后校验数据，确认正常后再开放业务。


## 五、核心禁忌（绝对不能碰）
1. 禁止直接执行 `DROP TABLE`（删表），除非确认表完全无用且已备份；
2. 禁止在生产库执行 `TRUNCATE TABLE`（清空表），改用 `DELETE FROM`（可回滚，且有日志）；
3. 禁止同时修改多个表的结构（如一次改 `sys_file` 和 `sys_user`），需分批次操作，每批操作后校验；
4. 禁止在业务高峰期（如白天9-18点）执行变更，优先选凌晨或低峰期操作。


通过以上规范，既能满足“手动修改”的灵活性，又能最大程度降低生产环境的风险——核心是“不侥幸、留后手”，每个步骤都确保有备份、有校验、有记录，即使出问题也能快速恢复。