### 原因（简述）
- 发生错误是因为在 `DictTypeDao.get_all_dict_type` 中调用了 `list_format_datetime`，该工具函数会“就地修改”ORM 实体，把 `datetime` 字段改成字符串。
- 这些被修改的实体仍处于 SQLAlchemy 会话中，后续自动 flush 到数据库时，`create_time` 等字段变成了字符串，触发 asyncpg 的类型校验错误。

### 解决方案（已修复版本）
- 移除对会话中 ORM 实体的就地时间格式化：`get_all_dict_type` 不再调用 `list_format_datetime`，直接返回 ORM 列表。
- 如需时间格式化，放到序列化/出参阶段处理（例如转换为 VO/dict 时），避免污染会话实体。

已修改文件：`module_admin/dao/dict_dao.py` 的 `get_all_dict_type`，删除 `list_format_datetime` 的调用并直接返回查询结果。

 
### 用 values(**update_data) 替代 [update_data]
你的场景是「根据 file_id 单条更新」，而非「批量更新多条记录」，用 values(**update_data) 更符合 SQLAlchemy 单条更新的语法，避免批量参数格式导致的隐性问题。
添加 execution_options(synchronize_session=None)
synchronize_session 控制更新后是否同步会话中已加载的对象：
None：不同步会话，直接执行数据库更新（适合软删除这类无需会话对象同步的场景）；
这是错误提示中明确建议的解决方案，能彻底规避「持久化对象批量同步」的冲突。