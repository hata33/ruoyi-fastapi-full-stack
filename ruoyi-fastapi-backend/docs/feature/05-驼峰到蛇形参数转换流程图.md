# 驼峰到蛇形参数转换流程图

## 核心原理
通过 `@as_query` 装饰器动态修改函数签名，结合 Pydantic 的 `alias_generator=to_camel` 机制，实现前端驼峰参数到后端 snake_case 字段的自动转换。

## 详细执行流程图

```mermaid
graph TD
    A[前端发送请求] --> B[GET /system/dict/type/list?dictName=状态&dictType=sys_normal_disable&pageNum=1&pageSize=10]
    B --> C[FastAPI 路由匹配]
    C --> D[控制器方法调用]
    D --> E[Depends(DictTypePageQueryModel.as_query)]
    
    E --> F[@as_query 装饰器处理]
    F --> G[遍历模型字段]
    G --> H[读取字段别名 alias]
    H --> I[生成依赖函数参数列表]
    I --> J[动态替换函数签名]
    
    J --> K[FastAPI 根据签名提取参数]
    K --> L[提取驼峰参数: dictName, dictType, pageNum, pageSize]
    L --> M[调用依赖函数 as_query_func]
    
    M --> N[Pydantic 模型构造]
    N --> O[alias_generator=to_camel 自动映射]
    O --> P[dictName → dict_name<br/>dictType → dict_type<br/>pageNum → page_num<br/>pageSize → page_size]
    
    P --> Q[模型实例化完成]
    Q --> R[业务层使用 snake_case 字段]
    R --> S[DAO 层数据库查询]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style F fill:#fff3e0
    style O fill:#e8f5e8
    style Q fill:#fce4ec
    style S fill:#f1f8e9
```

## 关键代码示例

### 1. 模型定义（dict_vo.py）
```python
@as_query
class DictTypePageQueryModel(DictTypeQueryModel):
    model_config = ConfigDict(alias_generator=to_camel, from_attributes=True)
    
    dict_name: str | None = Field(default=None, description='字典名称')
    dict_type: str | None = Field(default=None, description='字典类型') 
    page_num: int = Field(default=1, description='当前页码')
    page_size: int = Field(default=10, description='每页记录数')
```

### 2. @as_query 装饰器处理（pydantic_annotation.py）
```python
def as_query(cls: Type[BaseModelVar]) -> Type[BaseModelVar]:
    new_parameters = []
    
    for field_name, model_field in cls.model_fields.items():
        new_parameters.append(
            inspect.Parameter(
                model_field.alias,  # 使用驼峰别名作为参数名
                inspect.Parameter.POSITIONAL_ONLY,
                default=Query(default=model_field.default, description=model_field.description),
                annotation=model_field.annotation,
            )
        )
    
    async def as_query_func(**data):
        return cls(**data)  # 用驼峰数据构造模型
    
    # 关键：替换函数签名
    sig = inspect.signature(as_query_func).replace(parameters=new_parameters)
    as_query_func.__signature__ = sig
    setattr(cls, 'as_query', as_query_func)
```

### 3. 控制器使用（dict_controller.py）
```python
@dictController.get('/type/list')
async def get_system_dict_type_list(
    request: Request,
    dict_type_page_query: DictTypePageQueryModel = Depends(DictTypePageQueryModel.as_query),
    query_db: AsyncSession = Depends(get_db),
):
    # 使用服务层查询分页数据
    dict_type_page_query_result = await DictTypeService.get_dict_type_list_services(
        query_db, dict_type_page_query, is_page=True
    )
    return ResponseUtil.success(model_content=dict_type_page_query_result)
```

### 4. DAO 层使用（dict_dao.py）
```python
async def get_dict_type_list(cls, db: AsyncSession, query_object: DictTypePageQueryModel, is_page: bool = False):
    query = (
        select(SysDictType)
        .where(
            SysDictType.dict_name.like(f'%{query_object.dict_name}%') if query_object.dict_name else True,
            SysDictType.dict_type.like(f'%{query_object.dict_type}%') if query_object.dict_type else True,
            # 使用 snake_case 字段名
        )
    )
```

## 数据转换过程

### 前端请求参数
```
?dictName=状态&dictType=sys_normal_disable&pageNum=1&pageSize=10
```

### FastAPI 提取的参数
```python
{
    "dictName": "状态",
    "dictType": "sys_normal_disable", 
    "pageNum": 1,
    "pageSize": 10
}
```

### Pydantic 模型实例
```python
DictTypePageQueryModel(
    dict_name="状态",      # 驼峰 dictName → snake_case dict_name
    dict_type="sys_normal_disable",  # 驼峰 dictType → snake_case dict_type
    page_num=1,           # 驼峰 pageNum → snake_case page_num
    page_size=10          # 驼峰 pageSize → snake_case page_size
)
```

## 关键理解点

1. **别名生成**：`alias_generator=to_camel` 自动为每个字段生成驼峰别名
2. **签名替换**：`@as_query` 动态修改依赖函数签名，使用驼峰别名作为参数名
3. **自动映射**：Pydantic 在构造模型时，自动将驼峰参数映射到 snake_case 字段
4. **透明转换**：整个过程对业务代码透明，前端用驼峰，后端用蛇形

## 总结

这个机制的核心在于：
- **前端**：使用驼峰命名（符合 JavaScript 习惯）
- **API 接口**：通过 `@as_query` 装饰器识别驼峰参数
- **后端业务**：使用 snake_case 字段（符合 Python 习惯）
- **数据库**：使用 snake_case 字段名（符合 SQL 习惯）

通过 Pydantic 的别名机制，实现了前后端命名风格的无缝转换，既保持了各自语言的命名习惯，又确保了数据的一致性。
