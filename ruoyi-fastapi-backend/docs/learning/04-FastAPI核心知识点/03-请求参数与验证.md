# 请求参数与验证

## 学习目标

- 理解 Pydantic 模型的基本概念
- 掌握参数验证的各种方式
- 学习自定义验证器
- 理解错误处理机制
- 掌握嵌套模型验证

## 1. Pydantic 基础

### 1.1 什么是 Pydantic？

Pydantic 是一个使用 Python 类型注解进行数据验证的库。FastAPI 使用它来：

- 验证请求数据
- 转换数据类型
- 自动生成 API 文档
- 提供 IDE 自动补全

### 1.2 基本模型定义

**文件：** `module_admin/entity/vo/user_vo.py:22-48`

```python
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional

class UserModel(BaseModel):
    """用户模型"""

    # 配置类
    model_config = ConfigDict(
        alias_generator=to_camel,    # 自动生成驼峰别名
        from_attributes=True          # 从 ORM 对象创建
    )

    # 字段定义
    user_id: Optional[int] = Field(default=None, description='用户ID')
    user_name: Optional[str] = Field(default=None, description='用户账号')
    nick_name: Optional[str] = Field(default=None, description='用户昵称')
    email: Optional[str] = Field(default=None, description='用户邮箱')
    password: Optional[str] = Field(default=None, description='密码')
```

**Field 参数说明：**

| 参数 | 说明 | 示例 |
|------|------|------|
| `default` | 默认值 | `Field(default=1)` |
| `description` | 字段描述（用于文档） | `Field(description='用户ID')` |
| `gt` | 大于 | `Field(gt=0)` |
| `ge` | 大于等于 | `Field(ge=1)` |
| `lt` | 小于 | `Field(lt=100)` |
| `le` | 小于等于 | `Field(le=10)` |
| `min_length` | 最小长度 | `Field(min_length=1)` |
| `max_length` | 最大长度 | `Field(max_length=50)` |

### 1.3 类型注解

```python
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime

class UserBaseModel(BaseModel):
    # 基本类型
    name: str                # 必填字符串
    age: int = 0            # 可选整数，默认 0
    email: Optional[str]    # 可选字符串

    # 容器类型
    tags: List[str] = []    # 字符串列表
    scores: List[int] = []  # 整数列表

    # 日期时间
    create_time: Optional[datetime] = None

    # 字面量类型（限定值）
    status: Literal['active', 'inactive'] = 'active'
```

## 2. 验证器

### 2.1 内置验证器

**文件：** `module_admin/entity/vo/user_vo.py:66-84`

```python
from pydantic_validation_decorator import (
    NotBlank,   # 非空验证
    Size,       # 长度验证
    Network,    # 网络格式验证
    Xss         # XSS 过滤
)

class UserModel(BaseModel):
    user_name: Optional[str] = Field(default=None)
    email: Optional[str] = Field(default=None)

    # 验证器方法
    @Xss(field_name='user_name', message='用户账号不能包含脚本字符')
    @NotBlank(field_name='user_name', message='用户账号不能为空')
    @Size(field_name='user_name', min_length=0, max_length=30,
          message='用户账号长度不能超过30个字符')
    def get_user_name(self):
        """用户名验证链"""
        return self.user_name

    @Network(field_name='email', field_type='EmailStr',
             message='邮箱格式不正确')
    @Size(field_name='email', min_length=0, max_length=50,
          message='邮箱长度不能超过50个字符')
    def get_email(self):
        """邮箱验证链"""
        return self.email
```

**验证器执行顺序：**

```
@Xss
  ↓
@NotBlank
  ↓
@Size
  ↓
返回验证后的值
```

### 2.2 模型验证器

**文件：** `module_admin/entity/vo/user_vo.py:50-64`

```python
from pydantic import model_validator

class UserModel(BaseModel):
    user_id: Optional[int] = None
    password: Optional[str] = None

    @model_validator(mode='after')
    def check_password(self) -> 'UserModel':
        """
        模型验证器 - 在所有字段验证后执行

        mode='after': 字段验证完成后
        mode='before': 字段验证之前
        """
        import re
        pattern = r"""^[^<>"'|\\]+$"""
        if self.password is None or re.match(pattern, self.password):
            return self
        else:
            raise ModelValidatorException(
                message='密码不能包含非法字符：< > " \' \\ |'
            )

    @model_validator(mode='after')
    def check_admin(self) -> 'UserModel':
        """检查是否为管理员"""
        if self.user_id == 1:
            self.admin = True
        else:
            self.admin = False
        return self
```

## 3. 查询参数验证

### 3.1 基本查询参数

```python
from fastapi import Query, APIRouter

router = APIRouter()

@router.get('/users')
async def get_users(
    page: int = Query(1, ge=1, description='页码'),
    size: int = Query(10, ge=1, le=100, description='每页数量'),
    keyword: Optional[str] = Query(None, max_length=50)
):
    """
    Query 参数验证

    - ge: 大于等于
    - le: 小于等于
    - max_length: 最大长度
    """
    pass
```

### 3.2 使用 Pydantic 模型作为查询参数

**文件：** `module_admin/entity/vo/user_vo.py`

```python
class UserPageQueryModel(BaseModel):
    """用户分页查询模型"""

    page: Optional[int] = Field(default=1, ge=1)
    page_size: Optional[int] = Field(default=10, ge=1, le=100)
    user_name: Optional[str] = Field(default=None)
    status: Optional[str] = Field(default=None)
    dept_id: Optional[int] = Field(default=None)

    @classmethod
    def as_query(cls):
        """作为查询参数使用"""
        return Depends(cls)
```

**使用方式：**

```python
# 文件：module_admin/controller/user_controller.py:110

@userController.get('/list')
async def get_system_user_list(
    user_page_query: UserPageQueryModel = Depends(
        UserPageQueryModel.as_query
    )
):
    """
    将 Pydantic 模型作为查询参数使用

    优点：
    1. 复用验证逻辑
    2. 类型安全
    3. 自动文档生成
    """
    pass
```

## 4. 请求体验证

### 4.1 基本请求体

```python
from pydantic import BaseModel, EmailStr, HttpUrl

class AddUserModel(BaseModel):
    """添加用户模型"""

    # 必填字段
    user_name: str
    password: str

    # 可选字段
    email: Optional[EmailStr] = None  # 邮箱验证
    avatar: Optional[HttpUrl] = None  # URL 验证

    # 嵌套模型
    dept: Optional[DeptModel] = None
    roles: List[RoleModel] = []
```

### 4.2 嵌套模型验证

```python
class AddressModel(BaseModel):
    """地址模型"""
    province: str
    city: str
    street: str

    @model_validator(mode='after')
    def validate_address(self):
        """验证地址完整性"""
        if not all([self.province, self.city, self.street]):
            raise ValueError('地址信息不完整')
        return self

class UserWithAddress(BaseModel):
    """用户地址模型"""
    name: str
    address: AddressModel  # 嵌套模型

    @model_validator(mode='after')
    def validate_user_address(self):
        """验证用户和地址"""
        # 可以访问嵌套模型的数据
        if self.address.province == '北京':
            # 业务逻辑验证
            pass
        return self
```

### 4.3 列表验证

```python
class AddUsersModel(BaseModel):
    """批量添加用户"""
    users: List[AddUserModel]

    @model_validator(mode='after')
    def validate_users(self):
        """验证用户列表"""
        if len(self.users) > 100:
            raise ValueError('单次最多添加100个用户')

        # 检查用户名唯一性
        usernames = [u.user_name for u in self.users]
        if len(usernames) != len(set(usernames)):
            raise ValueError('用户名不能重复')

        return self
```

## 5. 自定义验证器

### 5.1 字段验证器

```python
from pydantic import field_validator

class UserModel(BaseModel):
    username: str
    age: int

    @field_validator('username')
    @classmethod
    def validate_username(cls, v: str) -> str:
        """验证用户名"""
        if len(v) < 3:
            raise ValueError('用户名至少3个字符')
        if not v.isalnum():
            raise ValueError('用户名只能包含字母和数字')
        return v

    @field_validator('age')
    @classmethod
    def validate_age(cls, v: int) -> int:
        """验证年龄"""
        if v < 0 or v > 150:
            raise ValueError('年龄必须在0-150之间')
        return v
```

### 5.2 跨字段验证

```python
class PasswordChangeModel(BaseModel):
    """密码修改模型"""
    old_password: str
    new_password: str
    confirm_password: str

    @model_validator(mode='after')
    def validate_passwords(self):
        """验证密码"""
        # 新密码不能与旧密码相同
        if self.new_password == self.old_password:
            raise ValueError('新密码不能与旧密码相同')

        # 确认密码必须一致
        if self.new_password != self.confirm_password:
            raise ValueError('两次输入的密码不一致')

        # 密码强度验证
        if len(self.new_password) < 8:
            raise ValueError('密码长度至少8位')

        return self
```

## 6. 验证错误处理

### 6.1 错误响应格式

FastAPI 自动处理验证错误：

```json
// 422 Unprocessable Entity
{
  "detail": [
    {
      "loc": ["body", "user_name"],
      "msg": "用户账号不能为空",
      "type": "value_error.not_blank"
    },
    {
      "loc": ["body", "email"],
      "msg": "邮箱格式不正确",
      "type": "value_error.email"
    }
  ]
}
```

### 6.2 自定义错误处理

```python
from fastapi import Request, status
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(
    request: Request,
    exc: RequestValidationError
):
    """
    自定义验证错误处理器
    """
    # 提取错误信息
    errors = exc.errors()

    # 格式化错误
    formatted_errors = []
    for error in errors:
        formatted_errors.append({
            'field': '.'.join(str(loc) for loc in error['loc'][1:]),
            'message': error['msg']
        })

    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            'code': 422,
            'msg': '参数验证失败',
            'data': formatted_errors
        }
    )
```

## 7. 项目实战示例

### 7.1 完整的用户模型

**文件：** `module_admin/entity/vo/user_vo.py`

```python
class AddUserModel(BaseModel):
    """添加用户模型"""

    # 基础信息
    user_name: str = Field(..., description='用户账号')
    password: str = Field(..., min_length=6, max_length=20,
                         description='密码')
    nick_name: Optional[str] = Field(None, description='用户昵称')

    # 联系信息
    email: Optional[EmailStr] = Field(None, description='邮箱')
    phonenumber: Optional[str] = Field(None, pattern=r'^1[3-9]\d{9}$',
                                     description='手机号')

    # 组织信息
    dept_id: Optional[int] = Field(None, description='部门ID')
    role_ids: List[int] = Field(default_factory=list,
                                description='角色ID列表')

    # 状态
    status: Literal['0', '1'] = Field('0', description='状态')

    # 验证器
    @model_validator(mode='after')
    def validate_user(self):
        """用户信息验证"""
        # 验证部门存在性
        if self.dept_id:
            # 检查部门是否存在
            pass

        # 验证角色
        if not self.role_ids:
            raise ValueError('用户至少分配一个角色')

        return self
```

### 7.2 在控制器中使用

**文件：** `module_admin/controller/user_controller.py:140-186`

```python
from pydantic_validation_decorator import ValidateFields

@userController.post('',
                    dependencies=[Depends(CheckUserInterfaceAuth(...))])
@ValidateFields(validate_model='add_user')  # 启用验证
@Log(title='用户管理', business_type=BusinessType.INSERT)
async def add_system_user(
    request: Request,
    add_user: AddUserModel,  # 自动验证
    query_db: AsyncSession = Depends(get_db),
    current_user: CurrentUserModel = Depends(...),
):
    """
    添加新用户

    FastAPI 自动执行：
    1. 解析 JSON 请求体
    2. 验证 AddUserModel 字段
    3. 执行验证器
    4. 如果验证失败，返回 422 错误
    5. 如果验证通过，调用函数
    """
    # 验证通过后执行业务逻辑
    add_user.password = PwdUtil.get_password_hash(add_user.password)
    result = await UserService.add_user_services(query_db, add_user)

    return ResponseUtil.success(msg=result.message)
```

## 8. 验证最佳实践

### 8.1 验证分层

```python
# 1. 类型验证 - Pydantic 自动处理
class UserModel(BaseModel):
    age: int  # 自动转换和验证

# 2. 格式验证 - 使用 Field 约束
class UserModel(BaseModel):
    email: EmailStr  # 邮箱格式验证

# 3. 业务验证 - 使用验证器
@model_validator(mode='after')
def validate_business(self):
    # 业务逻辑验证
    pass

# 4. 权限验证 - 使用依赖注入
@router.post('/', dependencies=[Depends(check_permission)])
async def create_user():
    pass
```

### 8.2 验证器复用

```python
# 定义可复用的验证器
def validate_password_strength(password: str) -> str:
    """验证密码强度"""
    if len(password) < 8:
        raise ValueError('密码至少8位')
    if not any(c.isupper() for c in password):
        raise ValueError('密码必须包含大写字母')
    return password

# 在模型中使用
class UserModel(BaseModel):
    password: str

    @field_validator('password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        return validate_password_strength(v)
```

## 9. 总结

### 9.1 验证层次

| 层次 | 工具 | 用途 |
|------|------|------|
| **类型验证** | Python 类型注解 | 基础类型检查 |
| **格式验证** | Field 约束 | 长度、范围等 |
| **结构验证** | 嵌套模型 | 复杂数据结构 |
| **业务验证** | 验证器 | 业务规则 |
| **权限验证** | 依赖注入 | 访问控制 |

### 9.2 常用验证器

| 验证器 | 说明 |
|--------|------|
| `@NotBlank` | 非空验证 |
| `@Size` | 大小验证 |
| `@Network` | 网络格式验证 |
| `@Xss` | XSS 过滤 |
| `@field_validator` | 字段验证器 |
| `@model_validator` | 模型验证器 |

### 9.3 错误处理流程

```
请求数据
    ↓
类型验证
    ↓ 失败
返回 422
    ↓ 成功
格式验证
    ↓ 失败
返回 422
    ↓ 成功
验证器
    ↓ 失败
返回自定义错误
    ↓ 成功
业务逻辑
```

## 10. 练习

1. 创建一个用户注册模型
2. 添加邮箱和密码验证
3. 实现密码强度验证器
4. 创建跨字段验证（确认密码）
5. 自定义验证错误响应

## 11. 下一步

完成本节学习后，继续学习：
- **[04-请求体与Pydantic模型](./04-请求体与Pydantic模型.md)** - 深入学习 Pydantic 模型
