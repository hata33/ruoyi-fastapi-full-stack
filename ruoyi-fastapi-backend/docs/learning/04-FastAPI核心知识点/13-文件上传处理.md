# 文件上传处理

## 学习目标

- 掌握文件上传接口设计
- 学习文件类型验证
- 理解文件存储策略
- 掌握大文件分片上传
- 理解文件访问控制

## 1. 文件上传接口

### 1.1 基本上传接口

**文件：** `module_admin/controller/file_controller.py`

```python
from fastapi import APIRouter, UploadFile, File
from typing import List

router = APIRouter(prefix='/file')

@router.post('/upload')
async def upload_file(
    file: UploadFile = File(..., description='上传文件'),
    path: str = None
):
    """
    文件上传接口

    参数：
    - file: 上传的文件对象
    - path: 存储路径（可选）
    """
    # 验证文件类型
    if not UploadUtil.is_allowed_extension(file.filename):
        return ResponseUtil.failure(
            message=f'不支持的文件类型: {file.filename}'
        )

    # 生成文件名
    filename = UploadUtil.generate_filename(file.filename)

    # 确定存储路径
    upload_path = UploadUtil.get_upload_path(path)

    # 保存文件
    file_path = upload_path / filename

    # 保存到磁盘
    with open(file_path, 'wb') as buffer:
        shutil.copyfileobj(file.file, buffer)

    # 返回文件访问URL
    file_url = f'/static/uploads/{filename}'

    return ResponseUtil.success(
        data={'url': file_url, 'filename': filename}
    )
```

### 1.2 批量上传

```python
@router.post('/upload/batch')
async def upload_files(
    files: List[UploadFile] = File(...)
):
    """批量文件上传"""

    results = []

    for file in files:
        try:
            # 上传单个文件
            result = await upload_single_file(file)
            results.append(result)
        except Exception as e:
            results.append({
                'filename': file.filename,
                'success': False,
                'error': str(e)
            })

    return ResponseUtil.success(data=results)
```

## 2. 文件类型验证

### 2.1 允许的文件类型

```python
from utils.upload_util import UploadUtil

class UploadConfig:
    """上传配置"""
    ALLOWED_EXTENSIONS = {
        'image': {'.jpg', '.jpeg', '.png', '.gif', '.bmp'},
        'document': {'.pdf', '.doc', '.docx', '.xls', '.xlsx'},
        'media': {'.mp4', '.avi', '.mov'}
    }

    ALLOWED_MIME_TYPES = {
        'image/jpeg',
        'image/png',
        'application/pdf',
        'application/vnd.ms-excel'
    }
```

### 2.2 验证实现

**文件：** `utils/upload_util.py`

```python
class UploadUtil:
    """上传工具类"""

    @staticmethod
    def is_allowed_extension(filename: str) -> bool:
        """检查文件扩展名"""
        import os
        ext = os.path.splitext(filename)[1].lower()
        allowed = {
            '.jpg', '.jpeg', '.png', '.gif',
            '.pdf', '.doc', '.docx'
        }
        return ext in allowed

    @staticmethod
    def generate_filename(filename: str) -> str:
        """生成唯一文件名"""
        import uuid
        import os

        # 获取文件扩展名
        ext = os.path.splitext(filename)[1]

        # 生成唯一文件名
        unique_name = f"{uuid.uuid4().hex}{ext}"

        return unique_name
```

## 3. 文件存储策略

### 3.1 目录结构

```
uploads/
├── images/          # 图片文件
├── documents/       # 文档文件
└── avatars/          # 用户头像
```

### 3.2 路径生成

```python
from pathlib import Path
from datetime import datetime

def get_upload_path(file_type: str, create_date: bool = True) -> Path:
    """
    生成上传路径

    策略：
    - 按类型分目录
    - 按日期分目录（可选）
    """
    base_path = Path('uploads')

    # 按类型分目录
    type_path = base_path / file_type
    type_path.mkdir(exist_ok=True)

    # 按日期分目录（可选）
    if create_date:
        date_path = type_path / datetime.now().strftime('%Y%m%d')
        date_path.mkdir(exist_ok=True)
        return date_path

    return type_path
```

## 4. 文件访问

### 4.1 静态文件服务

```python
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from pathlib import Path

app = FastAPI()

# 挂载静态文件目录
uploads_path = Path('uploads')
app.mount('/static', StaticFiles(directory=uploads_path))

# 访问: http://localhost:9099/static/images/avatar.jpg
```

### 4.2 文件下载接口

```python
from fastapi import Response
from fastapi.responses import FileResponse

@router.get('/download/{filename}')
async def download_file(filename: str):
    """下载文件"""
    file_path = Path('uploads') / filename

    if not file_path.exists():
        raise HTTPException(status_code=404, detail='文件不存在')

    return FileResponse(
        path=file_path,
        filename=filename,
        media_type='application/octet-stream',
        headers={
            'Content-Disposition': f'attachment; filename="{filename}"'
        }
    )
```

## 5. 大文件处理

### 5.1 分片上传

```python
from fastapi import UploadFile

# 存储分片信息
chunks_info = {}

@router.post('/upload/chunk')
async def upload_chunk(
    chunk: UploadFile = File(...),
    chunk_number: int = 0,
    total_chunks: int = 1,
    file_id: str = None
):
    """上传文件分片"""

    if not file_id:
        file_id = f"{uuid.uuid4().hex}"

    # 保存分片
    chunk_path = Path('chunks') / file_id / f'chunk_{chunk_number}'

    chunk_path.parent.mkdir(parents=True, exist_ok=True)

    with open(chunk_path, 'wb') as buffer:
        shutil.copyfileobj(chunk.file, buffer)

    # 更新分片信息
    if file_id not in chunks_info:
        chunks_info[file_id] = {
            'filename': chunk.filename,
            'total_chunks': total_chunks,
            'uploaded_chunks': []
        }

    chunks_info[file_id]['uploaded_chunks'].append(chunk_number)

    # 检查是否所有分片已上传
    if len(chunks_info[file_id]['uploaded_chunks']) == total_chunks:
        # 合并分片
        await merge_chunks(file_id)

    return {'message': '分片上传成功', 'file_id': file_id}

async def merge_chunks(file_id: str):
    """合并文件分片"""
    chunks_dir = Path('chunks') / file_id
    info = chunks_info[file_id]

    # 创建最终文件
    output_path = Path('uploads') / info['filename']
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, 'wb') as output:
        for i in range(info['total_chunks']):
            chunk_path = chunks_dir / f'chunk_{i}'
            with open(chunk_path, 'rb') as chunk:
                output.write(chunk.read())

    # 清理分片文件
    shutil.rmtree(chunks_dir)
    del chunks_info[file_id]

    return {'message': '文件合并成功', 'path': str(output_path)}
```

## 6. 文件安全

### 6.1 文件类型验证

```python
# 验证 MIME 类型
ALLOWED_MIME_TYPES = {
    'image/jpeg': ['.jpg', '.jpeg'],
    'image/png': ['.png'],
    'application/pdf': ['.pdf']
}

async def validate_file_type(file: UploadFile):
    """验证文件类型"""

    # 检查 MIME 类型
    if file.content_type not in ALLOWED_MIME_TYPES:
        raise HTTPException(
            status_code=400,
            detail=f'不支持的文件类型: {file.content_type}'
        )

    # 检查扩展名
    ext = os.path.splitext(file.filename)[1]
    allowed_exts = ALLOWED_MIME_TYPES.get(file.content_type, [])

    if ext not in allowed_exts:
        raise HTTPException(
            status_code=400,
            detail=f'不允许的文件扩展名: {ext}'
        )
```

### 6.2 文件大小限制

```python
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB

@router.post('/upload')
async def upload_file(
    file: UploadFile = File(...)
):
    """文件上传"""

    # 检查文件大小
    contents = await file.read()

    if len(contents) > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=413,
            detail=f'文件过大，最大允许 {MAX_FILE_SIZE / 1024 / 1024}MB'
        )

    # 重置文件指针
    await file.seek(0)

    # 处理文件...
```

## 7. 总结

### 7.1 文件上传流程

```
1. 前端上传文件
    ↓
2. 服务器接收文件
    ↓
3. 验证文件类型和大小
    ↓
4. 生成唯一文件名
    ↓
5. 保存到磁盘
    ↓
6. 返回文件 URL
```

### 7.2 最佳实践

1. **文件类型验证**：检查 MIME 类型和扩展名
2. **文件大小限制**：防止上传超大文件
3. **唯一文件名**：避免文件名冲突
4. **按类型分目录**：便于管理
5. **访问控制**：限制文件访问权限
6. **定期清理**：删除无用的临时文件

## 8. 下一步

完成本节学习后，继续学习：
- **[14-配置管理](./14-配置管理.md)** - 学习配置管理
