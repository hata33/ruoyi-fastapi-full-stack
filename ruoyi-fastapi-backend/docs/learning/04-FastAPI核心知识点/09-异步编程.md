# 异步编程

## 学习目标

- 理解 async/await 语法
- 掌握异步数据库操作
- 学习并发编程模式
- 理解异步上下文管理器
- 掌握性能优化技巧

## 1. 异步编程基础

### 1.1 什么是异步编程？

异步编程是一种非阻塞的编程模式，允许程序在等待耗时操作（如网络请求、数据库查询）时执行其他任务。

**同步 vs 异步：**

```python
# ❌ 同步代码 - 阻塞
def get_user_sync(user_id: int):
    """同步获取用户 - 阻塞其他请求"""
    user = db.query(User).filter(User.id == user_id).first()
    return user

# ✅ 异步代码 - 非阻塞
async def get_user_async(user_id: int):
    """异步获取用户 - 不阻塞"""
    user = await db.execute(
        select(User).where(User.id == user_id)
    )
    return user.scalar_one_or_none()
```

### 1.2 async/await 语法

```python
import asyncio

# 定义异步函数
async def fetch_user(user_id: int):
    """获取用户信息"""
    # await 暂停函数执行，等待操作完成
    user = await get_user_from_db(user_id)
    return user

# 调用异步函数
async def main():
    user = await fetch_user(1)  # 需要使用 await
    print(user)

# 运行异步函数
asyncio.run(main())
```

**async/await 规则：**
1. `async def` 定义异步函数
2. `await` 只能在 `async def` 内使用
3. `await` 后面必须是 awaitable 对象

## 2. 异步数据库操作

### 2.1 数据库会话管理

**文件：** `config/get_db.py:7-26`

```python
from sqlalchemy.ext.asyncio import AsyncSession
from config.database import AsyncSessionLocal

async def get_db():
    """
    数据库会话依赖

    使用 yield 确保会话正确关闭
    """
    async with AsyncSessionLocal() as current_db:
        yield current_db
        # 退出上下文时自动关闭会话
```

**使用方式：**

```python
from fastapi import Depends
from config.get_db import get_db
from sqlalchemy.ext.asyncio import AsyncSession

@router.get('/users/{user_id}')
async def get_user(
    user_id: int,
    db: AsyncSession = Depends(get_db)
):
    """
    异步查询用户

    db 会话由 get_db() 提供
    请求结束后自动关闭
    """
    stmt = select(SysUser).where(SysUser.user_id == user_id)
    result = await db.execute(stmt)
    return result.scalar_one_or_none()
```

### 2.2 CRUD 操作

```python
from sqlalchemy import select, update, delete
from sqlalchemy.ext.asyncio import AsyncSession

class UserRepository:
    """用户仓储"""

    async def find_by_id(
        self,
        db: AsyncSession,
        user_id: int
    ):
        """根据 ID 查询"""
        stmt = select(SysUser).where(SysUser.user_id == user_id)
        result = await db.execute(stmt)
        return result.scalar_one_or_none()

    async def create(
        self,
        db: AsyncSession,
        user: SysUser
    ):
        """创建用户"""
        db.add(user)
        await db.commit()
        await db.refresh(user)
        return user

    async def update(
        self,
        db: AsyncSession,
        user_id: int,
        **kwargs
    ):
        """更新用户"""
        stmt = (
            update(SysUser)
            .where(SysUser.user_id == user_id)
            .values(**kwargs)
        )
        await db.execute(stmt)
        await db.commit()

    async def delete(
        self,
        db: AsyncSession,
        user_id: int
    ):
        """删除用户"""
        stmt = delete(SysUser).where(SysUser.user_id == user_id)
        await db.execute(stmt)
        await db.commit()
```

## 3. 并发编程

### 3.1 并发执行

```python
import asyncio

async def fetch_user(user_id: int):
    """获取单个用户"""
    await asyncio.sleep(1)  # 模拟耗时操作
    return {'user_id': user_id, 'name': f'user{user_id}'}

async def fetch_users_concurrent(user_ids: List[int]):
    """
    并发获取多个用户

    串行：10个用户 × 1秒 = 10秒
    并发：max(1秒) = 1秒
    """
    # 创建任务列表
    tasks = [fetch_user(uid) for uid in user_ids]

    # 并发执行所有任务
    results = await asyncio.gather(*tasks)

    return results
```

### 3.2 任务组

```python
async def fetch_with_timeout():
    """带超时的并发执行"""

    async def fetch_user(user_id: int):
        await asyncio.sleep(1)
        return user_id

    # 创建任务组
    async with asyncio.TaskGroup() as tg:
        # 添加任务
        tg.create_task(fetch_user(1))
        tg.create_task(fetch_user(2))
        tg.create_task(fetch_user(3))

        # TaskGroup 会自动等待所有任务完成
        # 任何一个任务失败，其他任务会被取消
```

### 3.3 信号量控制

```python
import asyncio

async def limited_concurrent_requests():
    """限制并发数"""

    # 创建信号量（最多3个并发）
    semaphore = asyncio.Semaphore(3)

    async def fetch_user(user_id: int):
        async with semaphore:  # 获取信号量
            await asyncio.sleep(1)
            return user_id

    # 创建100个任务
    tasks = [fetch_user(i) for i in range(100)]

    # 虽然有100个任务，但同时最多只有3个在执行
    results = await asyncio.gather(*tasks)
```

## 4. 异步上下文管理器

### 4.1 自定义异步上下文管理器

```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def transaction(db: AsyncSession):
    """
    事务管理器

    自动提交或回滚事务
    """
    try:
        # 开始事务
        async with db.begin():
            yield db  # 将控制权交给调用者
            # 如果没有异常，自动提交
            # 如果有异常，自动回滚
    except Exception as e:
        # 记录错误
        logger.error(f"事务失败: {e}")
        raise

# 使用
@router.post('/users')
async def create_user(
    user: AddUserModel,
    db: AsyncSession = Depends(get_db)
):
    async with transaction(db):
        db.add(user)
        # 如果这里抛出异常，事务会自动回滚
```

### 4.2 资源管理

```python
@asynccontextmanager
async def redis_connection():
    """Redis 连接管理器"""

    # 获取连接
    redis = await RedisUtil.create_redis_pool()

    try:
        yield redis
    finally:
        # 释放连接
        await RedisUtil.close_redis_pool(redis)

# 使用
async def get_cache():
    async with redis_connection() as redis:
        value = await redis.get('key')
        return value
```

## 5. 异步项目实战

### 5.1 异步服务层

**文件：** `module_admin/service/user_service.py`

```python
class UserService:
    """用户服务类 - 异步实现"""

    @classmethod
    async def get_user_list_services(
        cls,
        query_db: AsyncSession,
        user_page_query: UserPageQueryModel,
        data_scope_sql: str,
        is_page: bool = False
    ):
        """
        异步获取用户列表

        所有数据库操作都是异步的
        """
        # 构建查询
        stmt = select(SysUser)

        # 应用数据权限
        if data_scope_sql:
            stmt = stmt.text(data_scope_sql)

        # 分页
        if is_page:
            offset = (user_page_query.page - 1) * user_page_query.page_size
            stmt = stmt.offset(offset).limit(user_page_query.page_size)

        # 执行查询
        result = await query_db.execute(stmt)

        # 返回结果
        rows = result.scalars().all()
        total = len(rows) if not is_page else await cls.count_user(query_db)

        return PageResponseModel(rows=rows, total=total)

    @classmethod
    async def add_user_services(
        cls,
        query_db: AsyncSession,
        user: AddUserModel
    ):
        """异步添加用户"""
        # 创建用户对象
        db_user = SysUser(**user.model_dump())

        # 添加到会话
        query_db.add(db_user)

        # 提交到数据库
        await query_db.commit()

        # 刷新获取生成的 ID
        await query_db.refresh(db_user)

        return ResultModel(message='添加成功')
```

### 5.2 异步控制器

```python
from fastapi import APIRouter, Depends

router = APIRouter()

@router.get('/users')
async def get_users(
    page: int = 1,
    size: int = 10,
    db: AsyncSession = Depends(get_db)
):
    """
    异步路由处理函数

    所有 I/O 操作都必须是异步的
    """
    # 异步查询
    stmt = select(SysUser).offset((page - 1) * size).limit(size)
    result = await db.execute(stmt)

    # 异步返回
    return result.scalars().all()
```

## 6. 性能优化

### 6.1 批量操作

```python
# ✅ 好的做法 - 批量插入
async def create_users_batch(users: List[AddUserModel]):
    """批量创建用户"""
    db_users = [SysUser(**u.model_dump()) for u in users]

    async with get_db() as db:
        db.add_all(db_users)  # 批量添加
        await db.commit()       # 一次性提交

# ❌ 不好的做法 - 循环插入
async def create_users_loop(users: List[AddUserModel]):
    """循环创建用户"""
    async with get_db() as db:
        for user in users:  # 循环插入
            db_user = SysUser(**user.model_dump())
            db.add(db_user)
            await db.commit()  # 每次都提交 - 慢
```

### 6.2 连接池优化

**文件：** `config/database.py:30-37`

```python
async_engine = create_async_engine(
    ASYNC_SQLALCHEMY_DATABASE_URL,
    # 连接池配置
    pool_size=10,              # 连接池大小
    max_overflow=10,           # 最大溢出连接数
    pool_timeout=30,           # 获取连接超时时间
    pool_recycle=3600,         # 连接回收时间（秒）
    echo=False                  # 是否打印SQL
)
```

**连接池参数说明：**

| 参数 | 说明 | 推荐值 |
|------|------|--------|
| `pool_size` | 常驻连接数 | CPU 核心数 |
| `max_overflow` | 额外连接数 | pool_size 的 50% |
| `pool_timeout` | 获取超时（秒） | 30 |
| `pool_recycle` | 连接回收时间（秒） | 3600 |

## 7. 异步陷阱

### 7.1 避免的陷阱

```python
# ❌ 错误1：在异步函数中使用同步操作
async def bad_example():
    # 同步操作会阻塞事件循环
    result = requests.get('http://api.example.com')  # 阻塞！
    return result

# ✅ 正确：使用异步库
async def good_example():
    async with aiohttp.ClientSession() as session:
        async with session.get('http://api.example.com') as response:
            return await response.json()

# ❌ 错误2：忘记 await
async def bad_example2():
    # 没有 await，任务不会被执行
    result = fetch_user()  # 忘须使用 await
    return result

# ✅ 正确：使用 await
async def good_example2():
    result = await fetch_user()  # 正确等待
    return result
```

### 7.2 阻止信号

```python
import asyncio

class CancellationError(Exception):
    """取消异常"""

async def cancellable_task():
    """可取消的任务"""

    try:
        # 定期检查取消信号
        while True:
            # 检查是否被取消
            if asyncio.current_task().cancelled():
                raise CancellationError('任务被取消')

            # 执行工作
            await do_work()

            # 短暂休眠，允许响应取消
            await asyncio.sleep(0.1)

    except asyncio.CancelledError:
        # 清理资源
        logger.info('任务被取消，正在清理...')
        raise
```

## 8. 异步测试

### 8.1 测试异步代码

```python
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_get_user():
    """测试异步接口"""
    async with AsyncClient(app=app) as client:
        # 异步发送请求
        response = await client.get('/users/1')

        # 验证结果
        assert response.status_code == 200
        assert response.json()['user_id'] == 1

@pytest.mark.asyncio
async def test_create_user():
    """测试异步创建"""
    user_data = {'user_name': 'test', 'password': '123456'}

    async with AsyncClient(app=app) as client:
        response = await client.post('/users', json=user_data)

        assert response.status_code == 200
```

## 9. 总结

### 9.1 异步编程优势

| 优势 | 说明 |
|------|------|
| **高并发** | 同时处理多个请求 |
| **高性能** | 充分利用 CPU |
| **非阻塞** | 不等待慢速 I/O |
| **可扩展** | 容易水平扩展 |

### 9.2 异步编程要点

```python
# 1. 定义异步函数
async def async_function():
    pass

# 2. 使用 await 调用
result = await async_function()

# 3. 并发执行
results = await asyncio.gather(
    async_function_1(),
    async_function_2(),
    async_function_3()
)

# 4. 异步上下文管理器
async with async_context_manager():
    pass

# 5. 运行异步程序
asyncio.run(main())
```

### 9.3 最佳实践

1. **所有 I/O 异步化**：数据库、HTTP、文件
2. **批量操作**：减少数据库往返
3. **连接池配置**：合理设置连接池大小
4. **并发控制**：使用信号量限制并发数
5. **错误处理**：妥善处理异步异常

## 10. 练习

1. 将同步代码改为异步
2. 实现并发用户查询
3. 使用信号量限制并发数
4. 实现异步事务管理器
5. 编写异步测试用例

## 11. 下一步

完成本节学习后，继续学习：
- **[10-安全性与认证](./10-安全性与认证.md)** - 学习JWT认证
