# 响应模型与序列化

## 学习目标

- 理解统一响应格式的设计
- 掌握响应模型的定义和使用
- 学习数据序列化和转换
- 理解数据脱敏的实现
- 掌握文件流响应

## 1. 统一响应格式

### 1.1 标准响应结构

**文件：** `utils/response_util.py:11-60`

```python
from fastapi import status
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import Any, Optional
from datetime import datetime

class ResponseUtil:
    """响应工具类"""

    @classmethod
    def success(
        cls,
        msg: str = '操作成功',
        data: Optional[Any] = None,
        rows: Optional[Any] = None,
        model_content: Optional[BaseModel] = None,
    ) -> Response:
        """
        成功响应方法

        标准响应格式：
        {
            "code": 200,
            "msg": "操作成功",
            "data": {...},  # 或 "rows": [...]
            "success": true,
            "time": "2024-01-01 12:00:00"
        }
        """
        result = {
            'code': 200,
            'msg': msg,
            'success': True,
            'time': datetime.now()
        }

        # 根据参数添加数据字段
        if data is not None:
            result['data'] = data
        if rows is not None:
            result['rows'] = rows
        if model_content is not None:
            result.update(model_content.model_dump(by_alias=True))

        return JSONResponse(
            status_code=status.HTTP_200_OK,
            content=jsonable_encoder(result)
        )
```

**响应格式说明：**

| 字段 | 类型 | 说明 |
|------|------|------|
| `code` | int | 业务状态码（200 成功） |
| `msg` | str | 响应消息 |
| `data` | any | 单个对象数据 |
| `rows` | array | 列表数据 |
| `success` | bool | 成功标识 |
| `time` | datetime | 响应时间 |

### 1.2 在路由中使用

```python
from fastapi import APIRouter
from utils.response_util import ResponseUtil

router = APIRouter()

@router.get('/users/{user_id}')
async def get_user(user_id: int):
    """获取用户详情"""
    user = await get_user_from_db(user_id)

    # 方式1：返回 data 字段
    return ResponseUtil.success(data=user)

@router.get('/users')
async def get_users():
    """获取用户列表"""
    users = await get_users_from_db()

    # 方式2：返回 rows 字段
    return ResponseUtil.success(rows=users)
```

## 2. 响应模型

### 2.1 定义响应模型

```python
from pydantic import BaseModel, ConfigDict
from typing import Optional, List

class UserModel(BaseModel):
    """用户响应模型"""

    model_config = ConfigDict(
        alias_generator=to_camel,  # 驼峰命名
        from_attributes=True       # 从 ORM 创建
    )

    user_id: int
    user_name: str
    nick_name: Optional[str] = None
    email: Optional[str] = None

class UserDetailModel(BaseModel):
    """用户详情模型"""
    user_id: int
    user_name: str
    roles: List[RoleModel] = []
    dept: Optional[DeptModel] = None
```

### 2.2 在路由中指定响应模型

```python
from fastapi import APIRouter
from pydantic import BaseModel

router = APIRouter()

class UserResponse(BaseModel):
    user_id: int
    user_name: str
    email: Optional[str] = None

# 方式1：使用 response_model 参数
@router.get('/users/{user_id}', response_model=UserResponse)
async def get_user(user_id: int):
    """获取用户 - 自动过滤未声明的字段"""
    user = await get_user_from_db(user_id)
    # 即使 user 包含 password 字段，也不会在响应中返回
    return user

# 方式2：使用 response_model_exclude
@router.get('/users/{user_id}',
           response_model=UserModel,
           response_model_exclude={'password'})
async def get_user_safe(user_id: int):
    """获取用户 - 排除敏感字段"""
    user = await get_user_from_db(user_id)
    return user

# 方式3：使用 response_model_include
@router.get('/users/{user_id}',
           response_model=UserModel,
           response_model_include={'user_id', 'user_name'})
async def get_user_simple(user_id: int):
    """获取用户 - 只包含指定字段"""
    user = await get_user_from_db(user_id)
    return user
```

## 3. 数据序列化

### 3.1 Pydantic 序列化

```python
from pydantic import BaseModel

class UserModel(BaseModel):
    user_id: int
    user_name: str
    create_time: datetime

# 序列化为字典
user = UserModel(user_id=1, user_name='admin', create_time=datetime.now())
user_dict = user.model_dump()

# 序列化为 JSON
user_json = user.model_dump_json()

# 使用别名（驼峰）
user_dict = user.model_dump(by_alias=True)
# {'userId': 1, 'userName': 'admin'}

# 排除字段
user_dict = user.model_dump(exclude={'create_time'})

# 包含字段
user_dict = user.model_dump(include={'user_id', 'user_name'})
```

### 3.2 ORM 对象序列化

```python
from sqlalchemy.orm import DeclarativeBase
from pydantic import BaseModel, ConfigDict

class Base(DeclarativeBase):
    """SQLAlchemy 基类"""
    pass

class SysUser(Base):
    """数据库表模型"""
    __tablename__ = 'sys_user'

    user_id: int
    user_name: str
    password: str

class UserModel(BaseModel):
    """Pydantic 模型"""

    model_config = ConfigDict(
        from_attributes=True  # 支持从 ORM 对象创建
    )

    user_id: int
    user_name: str
    # 不包含 password 字段

# 从 ORM 对象创建
db_user = await session.get(SysUser, 1)
user_model = UserModel.model_validate(db_user)
```

### 3.3 项目中的实际应用

**文件：** `module_admin/controller/user_controller.py:130-135`

```python
@userController.get('/list', response_model=PageResponseModel)
async def get_system_user_list(
    user_page_query: UserPageQueryModel = Depends(UserPageQueryModel.as_query),
    query_db: AsyncSession = Depends(get_db),
):
    """获取用户列表"""
    user_page_query_result = await UserService.get_user_list_services(
        query_db, user_page_query, data_scope_sql, is_page=True
    )

    # 使用 model_content 参数传递 Pydantic 模型
    return ResponseUtil.success(model_content=user_page_query_result)
```

## 4. 数据脱敏

### 4.1 字段级脱敏

```python
from pydantic import BaseModel, field_serializer

class UserModel(BaseModel):
    """用户模型 - 带脱敏"""

    user_id: int
    user_name: str
    password: str  # 原始密码
    email: str
    phone: str

    @field_serializer('password')
    def serialize_password(self, value: str) -> str:
        """密码脱敏"""
        return '******'

    @field_serializer('phone')
    def serialize_phone(self, value: str) -> str:
        """手机号脱敏"""
        if len(value) == 11:
            return f'{value[:3]}****{value[-4:]}'
        return value

    @field_serializer('email')
    def serialize_email(self, value: str) -> str:
        """邮箱脱敏"""
        parts = value.split('@')
        if len(parts) == 2:
            name, domain = parts
            if len(name) > 2:
                name = f'{name[:2]}***'
            return f'{name}@{domain}'
        return value
```

**输出示例：**

```json
{
  "userId": 1,
  "userName": "admin",
  "password": "******",
  "phone": "138****5678",
  "email": "zh***@example.com"
}
```

### 4.2 条件脱敏

```python
class UserModel(BaseModel):
    """用户模型 - 条件脱敏"""

    user_id: int
    user_name: str
    email: str
    role: str  # 用户角色

    @field_serializer('email')
    def serialize_email(self, value: str) -> str:
        """根据角色决定是否脱敏"""
        # 管理员可以看到完整邮箱
        if self.role == 'admin':
            return value
        # 普通用户邮箱脱敏
        parts = value.split('@')
        if len(parts) == 2:
            return f'{parts[0][:2]}***@{parts[1]}'
        return value
```

### 4.3 全局脱敏配置

**文件：** `config/constant.py`

```python
class SensitiveFields:
    """敏感字段配置"""

    # 需要脱敏的字段
    PASSWORD_FIELDS = {'password', 'pwd', 'passwd'}
    PHONE_FIELDS = {'phone', 'mobile', 'phonenumber'}
    EMAIL_FIELDS = {'email', 'email_address'}
    ID_CARD_FIELDS = {'id_card', 'idcard', 'identity_card'}

    @classmethod
    def mask_field(cls, field_name: str, value: str) -> str:
        """根据字段名脱敏"""
        if field_name in cls.PASSWORD_FIELDS:
            return '******'
        elif field_name in cls.PHONE_FIELDS:
            return f'{value[:3]}****{value[-4:]}'
        elif field_name in cls.EMAIL_FIELDS:
            parts = value.split('@')
            return f'{parts[0][:2]}***@{parts[1]}'
        return value
```

## 5. 文件响应

### 5.1 文件下载

```python
from fastapi import Response
from fastapi.responses import FileResponse

@router.get('/download/{file_id}')
async def download_file(file_id: int):
    """文件下载"""
    file_info = await get_file_info(file_id)

    return FileResponse(
        path=file_info.file_path,
        filename=file_info.file_name,
        media_type='application/octet-stream',
        headers={
            'Content-Disposition': f'attachment; filename="{file_info.file_name}"'
        }
    )
```

### 5.2 流式响应

```python
from fastapi.responses import StreamingResponse
import asyncio

async def generate_file():
    """生成文件内容"""
    for i in range(100):
        yield f"line {i}\n"
        await asyncio.sleep(0.1)

@router.get('/stream-file')
async def stream_file():
    """流式文件下载"""
    return StreamingResponse(
        generate_file(),
        media_type='text/plain',
        headers={
            'Content-Disposition': 'attachment; filename="data.txt"'
        }
    )
```

### 5.3 项目中的文件响应

**文件：** `module_admin/controller/file_controller.py`

```python
from utils.common_util import bytes2file_response

@file_controller.post('/upload')
async def upload_file(file: UploadFile = File(...)):
    """文件上传"""
    # 读取文件内容
    contents = await file.read()

    # 处理文件...
    result = await process_file(contents)

    # 返回文件响应
    return bytes2file_response(bytes_data=result)
```

## 6. 分页响应

### 6.1 分页模型

```python
from pydantic import BaseModel, ConfigDict, Field
from typing import List, Generic, TypeVar

T = TypeVar('T')

class PageResponseModel(BaseModel, Generic[T]):
    """分页响应模型"""

    model_config = ConfigDict(
        alias_generator=to_camel
    )

    total: int = Field(..., description='总记录数')
    rows: List[T] = Field(default_factory=list, description='数据列表')
    code: int = Field(200, description='状态码')
    msg: str = Field('查询成功', description='消息')

    @classmethod
    def success(cls, rows: List[T], total: int):
        """创建成功分页响应"""
        return cls(
            code=200,
            msg='查询成功',
            rows=rows,
            total=total
        )

# 使用方式
@router.get('/users', response_model=PageResponseModel[UserModel])
async def get_users(page: int = 1, size: int = 10):
    """获取用户列表"""
    users, total = await get_users_from_db(page, size)

    return PageResponseModel.success(
        rows=users,
        total=total
    )
```

## 7. 错误响应

### 7.1 错误响应格式

**文件：** `utils/response_util.py`

```python
class ResponseUtil:
    """响应工具类"""

    @classmethod
    def error(
        cls,
        msg: str = '操作失败',
        data: Optional[Any] = None,
    ) -> Response:
        """服务器错误响应"""
        result = {
            'code': 500,
            'msg': msg,
            'success': False
        }
        if data is not None:
            result['data'] = data

        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content=jsonable_encoder(result)
        )

    @classmethod
    def unauthorized(
        cls,
        msg: str = '未授权',
        data: Optional[Any] = None,
    ) -> Response:
        """未授权响应"""
        result = {
            'code': 401,
            'msg': msg,
            'success': False
        }
        if data is not None:
            result['data'] = data

        return JSONResponse(
            status_code=status.HTTP_401_UNAUTHORIZED,
            content=jsonable_encoder(result)
        )

    @classmethod
    def forbidden(
        cls,
        msg: str = '无权限',
        data: Optional[Any] = None,
    ) -> Response:
        """禁止访问响应"""
        result = {
            'code': 403,
            'msg': msg,
            'success': False
        }
        if data is not None:
            result['data'] = data

        return JSONResponse(
            status_code=status.HTTP_403_FORBIDDEN,
            content=jsonable_encoder(result)
        )

    @classmethod
    def failure(
        cls,
        msg: str = '操作失败',
        data: Optional[Any] = None,
    ) -> Response:
        """业务失败响应"""
        result = {
            'code': 500,
            'msg': msg,
            'success': False
        }
        if data is not None:
            result['data'] = data

        return JSONResponse(
            status_code=status.HTTP_200_OK,
            content=jsonable_encoder(result)
        )
```

### 7.2 错误响应使用

```python
@router.post('/users')
async def create_user(user: AddUserModel):
    """创建用户"""

    # 业务验证失败
    existing_user = await get_user_by_name(user.user_name)
    if existing_user:
        return ResponseUtil.failure(msg='用户名已存在')

    # 系统错误
    try:
        new_user = await create_user_in_db(user)
    except Exception as e:
        return ResponseUtil.error(msg='创建用户失败')

    return ResponseUtil.success(data=new_user)
```

## 8. 自定义序列化

### 8.1 日期时间序列化

```python
from datetime import datetime
from pydantic import BaseModel, field_serializer

class EventModel(BaseModel):
    """事件模型"""
    name: str
    event_time: datetime

    @field_serializer('event_time')
    def serialize_event_time(self, value: datetime) -> str:
        """序列化日期时间"""
        return value.strftime('%Y-%m-%d %H:%M:%S')
```

### 8.2 枚举序列化

```python
from enum import Enum
from pydantic import BaseModel

class StatusEnum(str, Enum):
    """状态枚举"""
    ACTIVE = '0'
    INACTIVE = '1'

class UserModel(BaseModel):
    """用户模型"""
    status: StatusEnum

    @field_serializer('status')
    def serialize_status(self, value: StatusEnum) -> str:
        """序列化枚举"""
        return {
            '0': '正常',
            '1': '停用'
        }.get(value.value, value.value)
```

## 9. 性能优化

### 9.1 使用 `model_dump`

```python
# ✅ 好的做法
user_dict = user.model_dump()

# ❌ 不好的做法
user_dict = {
    'user_id': user.user_id,
    'user_name': user.user_name,
    # ... 手动构造
}
```

### 9.2 批量序列化

```python
from pydantic import BaseModel
from typing import List

class UserListResponse(BaseModel):
    """用户列表响应"""
    total: int
    rows: List[UserModel]

# 一次性序列化
response = UserListResponse(total=100, rows=users)
response_dict = response.model_dump(by_alias=True)
```

## 10. 总结

### 10.1 响应类型

| 类型 | 状态码 | 使用场景 |
|------|--------|----------|
| `success` | 200 | 操作成功 |
| `failure` | 200 | 业务失败 |
| `error` | 500 | 系统错误 |
| `unauthorized` | 401 | 未授权 |
| `forbidden` | 403 | 无权限 |

### 10.2 序列化方法

| 方法 | 说明 |
|------|------|
| `model_dump()` | 序列化为字典 |
| `model_dump_json()` | 序列化为 JSON |
| `model_validate()` | 反序列化 |
| `by_alias=True` | 使用别名 |

### 10.3 最佳实践

1. **统一响应格式**：使用 `ResponseUtil`
2. **响应模型**：定义清晰的响应模型
3. **数据脱敏**：保护敏感信息
4. **错误处理**：区分业务错误和系统错误
5. **性能优化**：使用 Pydantic 内置方法

## 11. 练习

1. 创建用户列表响应模型
2. 实现手机号脱敏
3. 使用 `response_model` 过滤字段
4. 实现文件下载接口
5. 创建分页响应模型

## 12. 下一步

完成本节学习后，继续学习：
- **[06-依赖注入系统](./06-依赖注入系统.md)** - 学习依赖注入
