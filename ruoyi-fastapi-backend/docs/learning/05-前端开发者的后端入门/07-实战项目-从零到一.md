# 实战项目：从零到一

> 把前面学到的知识串联起来，从零构建一个完整的后端 API。

## 项目目标

构建一个"文章管理"API，包含以下功能：

1. 文章的增删改查
2. 分类管理
3. 标签管理
4. 评论系统
5. 点赞功能

---

## 第 1 步：数据建模

### 识别实体

```
核心实体：
- Article (文章)
- Category (分类)
- Tag (标签)
- Comment (评论)
- Like (点赞)
```

### 设计关系

```
Article ── N:1 ──> Category  (文章属于一个分类)
Article ── N:N ──> Tag       (文章有多个标签)
Article ── 1:N ──> Comment   (文章有多条评论)
User    ── 1:N ──> Article   (用户写多篇文章)
User    ── 1:N ──> Comment   (用户发多条评论)
User    ── N:N ──> Like       (用户点赞多篇文章)
```

### 定义 DO（数据库模型）

```python
# module_admin/entity/do/article_do.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey
from sqlalchemy.orm import relationship

class Article(Base):
    __tablename__ = 'tb_article'

    # 主键
    article_id = Column(Integer, primary_key=True, autoincrement=True)

    # 基本信息
    title = Column(String(200), nullable=False)
    content = Column(Text, nullable=False)
    summary = Column(String(500))

    # 外键
    user_id = Column(Integer, ForeignKey('sys_user.user_id'))
    category_id = Column(Integer, ForeignKey('tb_category.category_id'))

    # 统计
    view_count = Column(Integer, default=0)
    like_count = Column(Integer, default=0)
    comment_count = Column(Integer, default=0)

    # 状态
    status = Column(String(1), default='1')  # 1: 草稿, 2: 发布
    del_flag = Column(String(1), default='0')

    # 时间
    create_time = Column(DateTime, default=datetime.now)
    update_time = Column(DateTime, onupdate=datetime.now)

    # 关系
    category = relationship("Category", back_populates="articles")
    tags = relationship("ArticleTag", back_populates="article")
    comments = relationship("Comment", back_populates="article")

class Category(Base):
    __tablename__ = 'tb_category'

    category_id = Column(Integer, primary_key=True, autoincrement=True)
    category_name = Column(String(50), nullable=False)
    description = Column(String(200))
    create_time = Column(DateTime, default=datetime.now)

    # 关系
    articles = relationship("Article", back_populates="category")

class Tag(Base):
    __tablename__ = 'tb_tag'

    tag_id = Column(Integer, primary_key=True, autoincrement=True)
    tag_name = Column(String(30), nullable=False)
    create_time = Column(DateTime, default=datetime.now)

class ArticleTag(Base):
    """文章和标签的多对多关系表"""
    __tablename__ = 'tb_article_tag'

    article_id = Column(Integer, ForeignKey('tb_article.article_id'), primary_key=True)
    tag_id = Column(Integer, ForeignKey('tb_tag.tag_id'), primary_key=True)

    # 关系
    article = relationship("Article", back_populates="tags")
    tag = relationship("Tag")

class Comment(Base):
    __tablename__ = 'tb_comment'

    comment_id = Column(Integer, primary_key=True, autoincrement=True)
    content = Column(Text, nullable=False)

    # 外键
    article_id = Column(Integer, ForeignKey('tb_article.article_id'))
    user_id = Column(Integer, ForeignKey('sys_user.user_id'))

    # 时间
    create_time = Column(DateTime, default=datetime.now)

    # 关系
    article = relationship("Article", back_populates="comments")

class Like(Base):
    """用户点赞表"""
    __tablename__ = 'tb_like'

    user_id = Column(Integer, ForeignKey('sys_user.user_id'), primary_key=True)
    article_id = Column(Integer, ForeignKey('tb_article.article_id'), primary_key=True)
    create_time = Column(DateTime, default=datetime.now)
```

---

## 第 2 步：定义 VO 和 Query Model

### 查询模型

```python
# module_admin/entity/query/article_query.py
from pydantic import BaseModel, Field
from typing import Optional

class ArticleQuery(BaseModel):
    title: Optional[str] = Field(default=None, description="文章标题")
    categoryId: Optional[int] = Field(default=None, alias="categoryId", description="分类ID")
    status: Optional[str] = Field(default='2', description="状态：1草稿 2发布")
    pageNum: int = Field(default=1, ge=1, alias="pageNum")
    pageSize: int = Field(default=10, ge=1, le=100, alias="pageSize")

    class Config:
        from_attributes = True
        populate_by_name = True

class ArticleCreate(BaseModel):
    title: str = Field(min_length=1, max_length=200, description="标题")
    content: str = Field(min_length=1, description="内容")
    summary: Optional[str] = Field(default=None, max_length=500, description="摘要")
    categoryId: int = Field(description="分类ID")
    tagIds: Optional[list[int]] = Field(default=[], alias="tagIds", description="标签ID列表")
    status: str = Field(default='1', description="状态：1草稿 2发布")

    class Config:
        populate_by_name = True

class ArticleUpdate(BaseModel):
    articleId: int = Field(description="文章ID")
    title: Optional[str] = Field(default=None, min_length=1, max_length=200)
    content: Optional[str] = Field(default=None)
    summary: Optional[str] = Field(default=None)
    categoryId: Optional[int] = Field(default=None)
    tagIds: Optional[list[int]] = Field(default=None)
    status: Optional[str] = Field(default=None)

    class Config:
        populate_by_name = True
```

### 视图模型

```python
# module_admin/entity/vo/article_vo.py
from pydantic import BaseModel, Field
from typing import Optional, List

class ArticleVO(BaseModel):
    articleId: int = Field(alias="articleId")
    title: str
    summary: Optional[str]
    content: Optional[str]  # 列表时不返回完整内容
    categoryId: int
    categoryName: Optional[str] = Field(default=None)
    userId: int
    userName: Optional[str] = Field(default=None)
    viewCount: int = Field(alias="viewCount")
    likeCount: int = Field(alias="likeCount")
    commentCount: int = Field(alias="commentCount")
    status: str
    createTime: str = Field(alias="createTime")
    tags: List[dict] = Field(default_factory=list)

    class Config:
        from_attributes = True
        populate_by_name = True

class ArticleDetailVO(ArticleVO):
    """文章详情，包含完整内容"""
    content: str

class CommentVO(BaseModel):
    commentId: int
    content: str
    userId: int
    userName: Optional[str]
    createTime: str

    class Config:
        from_attributes = True
```

---

## 第 3 步：实现 Service 层

```python
# module_admin/service/article_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, update, delete
from module_admin.entity.do.article_do import Article, ArticleTag, Category, Tag
from module_admin.entity.vo.article_vo import ArticleVO, ArticleDetailVO

class ArticleService:

    @classmethod
    async def get_list(
        cls,
        db: AsyncSession,
        query: ArticleQuery
    ) -> tuple[list[Article], int]:
        """
        查询文章列表
        返回: (文章列表, 总数)
        """
        # 构建查询
        stmt = select(Article).where(Article.del_flag == '0')

        # 动态条件
        if query.title:
            stmt = stmt.where(Article.title.like(f'%{query.title}%'))
        if query.categoryId:
            stmt = stmt.where(Article.category_id == query.categoryId)
        if query.status:
            stmt = stmt.where(Article.status == query.status)

        # 查询总数
        count_stmt = select(func.count()).select_from(stmt.subquery())
        total = (await db.execute(count_stmt)).scalar()

        # 分页查询
        stmt = stmt.order_by(Article.create_time.desc())
        stmt = stmt.offset((query.pageNum - 1) * query.pageSize)
        stmt = stmt.limit(query.pageSize)

        result = await db.execute(stmt)
        articles = result.scalars().all()

        return articles, total

    @classmethod
    async def get_by_id(
        cls,
        db: AsyncSession,
        article_id: int
    ) -> Optional[Article]:
        """根据 ID 查询文章"""
        result = await db.execute(
            select(Article)
            .where(Article.article_id == article_id)
            .where(Article.del_flag == '0')
        )
        return result.scalar_one_or_none()

    @classmethod
    async def create(
        cls,
        db: AsyncSession,
        user_id: int,
        data: ArticleCreate
    ) -> Article:
        """创建文章"""
        # 创建文章
        article = Article(
            title=data.title,
            content=data.content,
            summary=data.summary,
            category_id=data.categoryId,
            user_id=user_id,
            status=data.status
        )
        db.add(article)
        await db.flush()  # 获取自增 ID

        # 添加标签关联
        for tag_id in data.tagIds:
            article_tag = ArticleTag(
                article_id=article.article_id,
                tag_id=tag_id
            )
            db.add(article_tag)

        await db.commit()
        await db.refresh(article)
        return article

    @classmethod
    async def update(
        cls,
        db: AsyncSession,
        article_id: int,
        data: ArticleUpdate
    ) -> bool:
        """更新文章"""
        article = await cls.get_by_id(db, article_id)
        if not article:
            return False

        # 更新字段
        if data.title is not None:
            article.title = data.title
        if data.content is not None:
            article.content = data.content
        if data.summary is not None:
            article.summary = data.summary
        if data.categoryId is not None:
            article.category_id = data.categoryId
        if data.status is not None:
            article.status = data.status

        # 更新标签关联
        if data.tagIds is not None:
            # 删除旧的关联
            await db.execute(
                delete(ArticleTag).where(
                    ArticleTag.article_id == article_id
                )
            )
            # 添加新的关联
            for tag_id in data.tagIds:
                article_tag = ArticleTag(
                    article_id=article_id,
                    tag_id=tag_id
                )
                db.add(article_tag)

        await db.commit()
        return True

    @classmethod
    async def delete(
        cls,
        db: AsyncSession,
        article_id: int
    ) -> bool:
        """删除文章（软删除）"""
        article = await cls.get_by_id(db, article_id)
        if not article:
            return False

        article.del_flag = '1'
        await db.commit()
        return True

    @classmethod
    async def increment_view(
        cls,
        db: AsyncSession,
        article_id: int
    ):
        """增加阅读量"""
        await db.execute(
            update(Article)
            .where(Article.article_id == article_id)
            .values(view_count=Article.view_count + 1)
        )
        await db.commit()

    @classmethod
    async def toggle_like(
        cls,
        db: AsyncSession,
        user_id: int,
        article_id: int
    ) -> bool:
        """
        点赞/取消点赞
        返回: True 表示点赞，False 表示取消点赞
        """
        from module_admin.entity.do.article_do import Like

        # 检查是否已点赞
        result = await db.execute(
            select(Like).where(
                Like.user_id == user_id,
                Like.article_id == article_id
            )
        )
        existing = result.scalar_one_or_none()

        if existing:
            # 取消点赞
            await db.delete(existing)
            # 减少点赞数
            await db.execute(
                update(Article)
                .where(Article.article_id == article_id)
                .values(like_count=Article.like_count - 1)
            )
            is_liked = False
        else:
            # 添加点赞
            like = Like(user_id=user_id, article_id=article_id)
            db.add(like)
            # 增加点赞数
            await db.execute(
                update(Article)
                .where(Article.article_id == article_id)
                .values(like_count=Article.like_count + 1)
            )
            is_liked = True

        await db.commit()
        return is_liked
```

---

## 第 4 步：实现 Controller 层

```python
# module_admin/controller/article_controller.py
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from module_admin.common.database import get_db
from module_admin.common.security import get_current_user
from module_admin.common.response import Resp
from module_admin.entity.do.user_do import SysUser
from module_admin.entity.query.article_query import ArticleQuery, ArticleCreate, ArticleUpdate
from module_admin.entity.vo.article_vo import ArticleVO, ArticleDetailVO
from module_admin.service import article_service

articleController = APIRouter(prefix='/article', tags=['文章管理'])

@articleController.post("/list")
async def get_article_list(
    query: ArticleQuery,
    query_db: AsyncSession = Depends(get_db)
):
    """查询文章列表"""
    articles, total = await article_service.get_list(query_db, query)

    # 组合数据
    article_list = []
    for article in articles:
        # 查询分类名称
        category = await query_db.get(Category, article.category_id)

        # 查询标签
        tag_result = await query_db.execute(
            select(Tag).join(ArticleTag).where(
                ArticleTag.article_id == article.article_id
            )
        )
        tags = tag_result.scalars().all()

        # 组装 VO
        article_dict = {
            'articleId': article.article_id,
            'title': article.title,
            'summary': article.summary,
            'content': None,  # 列表不返回完整内容
            'categoryId': article.category_id,
            'categoryName': category.category_name if category else None,
            'userId': article.user_id,
            'userName': None,  # 可以通过 JOIN 查询
            'viewCount': article.view_count,
            'likeCount': article.like_count,
            'commentCount': article.comment_count,
            'status': article.status,
            'createTime': article.create_time.strftime('%Y-%m-%d %H:%M:%S'),
            'tags': [{'tagId': t.tag_id, 'tagName': t.tag_name} for t in tags]
        }
        article_list.append(ArticleVO(**article_dict))

    return Resp.success(data=article_list, msg=f"共 {total} 篇")

@articleController.get("/{article_id}")
async def get_article_detail(
    article_id: int,
    query_db: AsyncSession = Depends(get_db)
):
    """查询文章详情"""
    article = await article_service.get_by_id(query_db, article_id)
    if not article:
        raise BusinessException("文章不存在", code=404)

    # 增加阅读量
    await article_service.increment_view(query_db, article_id)

    # 组装数据
    category = await query_db.get(Category, article.category_id)
    user = await query_db.get(SysUser, article.user_id)

    tag_result = await query_db.execute(
        select(Tag).join(ArticleTag).where(
            ArticleTag.article_id == article.article_id
        )
    )
    tags = tag_result.scalars().all()

    article_dict = {
        'articleId': article.article_id,
        'title': article.title,
        'summary': article.summary,
        'content': article.content,  # 详情返回完整内容
        'categoryId': article.category_id,
        'categoryName': category.category_name if category else None,
        'userId': article.user_id,
        'userName': user.user_name if user else None,
        'viewCount': article.view_count,
        'likeCount': article.like_count,
        'commentCount': article.comment_count,
        'status': article.status,
        'createTime': article.create_time.strftime('%Y-%m-%d %H:%M:%S'),
        'tags': [{'tagId': t.tag_id, 'tagName': t.tag_name} for t in tags]
    }

    return Resp.success(data=ArticleDetailVO(**article_dict))

@articleController.post("/")
async def create_article(
    data: ArticleCreate,
    current_user: SysUser = Depends(get_current_user),
    query_db: AsyncSession = Depends(get_db)
):
    """创建文章"""
    article = await article_service.create(
        query_db,
        current_user.user_id,
        data
    )
    return Resp.success(msg="创建成功")

@articleController.put("/")
async def update_article(
    data: ArticleUpdate,
    current_user: SysUser = Depends(get_current_user),
    query_db: AsyncSession = Depends(get_db)
):
    """更新文章"""
    success = await article_service.update(
        query_db,
        data.articleId,
        data
    )
    if not success:
        raise BusinessException("文章不存在", code=404)

    return Resp.success(msg="更新成功")

@articleController.delete("/{article_id}")
async def delete_article(
    article_id: int,
    current_user: SysUser = Depends(get_current_user),
    query_db: AsyncSession = Depends(get_db)
):
    """删除文章"""
    success = await article_service.delete(query_db, article_id)
    if not success:
        raise BusinessException("文章不存在", code=404)

    return Resp.success(msg="删除成功")

@articleController.post("/like/{article_id}")
async def toggle_like(
    article_id: int,
    current_user: SysUser = Depends(get_current_user),
    query_db: AsyncSession = Depends(get_db)
):
    """点赞/取消点赞"""
    is_liked = await article_service.toggle_like(
        query_db,
        current_user.user_id,
        article_id
    )

    action = "点赞" if is_liked else "取消点赞"
    return Resp.success(data={'liked': is_liked}, msg=action + "成功")
```

---

## 第 5 步：挂载路由

```python
# server.py
from fastapi import FastAPI
from module_admin.controller import article_controller

app = FastAPI()

# 挂载文章管理路由
app.include_router(article_controller.router, prefix='/api')
```

---

## 测试 API

### 1. 创建文章

```bash
POST /api/article/
Authorization: Bearer <token>
Content-Type: application/json

{
  "title": "我的第一篇文章",
  "content": "这是文章内容...",
  "summary": "这是摘要",
  "categoryId": 1,
  "tagIds": [1, 2],
  "status": "2"
}
```

### 2. 查询文章列表

```bash
POST /api/article/list
Content-Type: application/json

{
  "title": "",
  "categoryId": null,
  "status": "2",
  "pageNum": 1,
  "pageSize": 10
}
```

### 3. 查询文章详情

```bash
GET /api/article/1
```

### 4. 更新文章

```bash
PUT /api/article/
Authorization: Bearer <token>
Content-Type: application/json

{
  "articleId": 1,
  "title": "更新后的标题",
  "content": "更新后的内容"
}
```

### 5. 删除文章

```bash
DELETE /api/article/1
Authorization: Bearer <token>
```

### 6. 点赞文章

```bash
POST /api/article/like/1
Authorization: Bearer <token>
```

---

## 前端调用示例

```typescript
// api/article.ts
import request from '@/utils/request'

// 查询文章列表
export function getArticleList(params: ArticleQuery) {
  return request({
    url: '/api/article/list',
    method: 'post',
    data: params
  })
}

// 查询文章详情
export function getArticleDetail(articleId: number) {
  return request({
    url: `/api/article/${articleId}`,
    method: 'get'
  })
}

// 创建文章
export function createArticle(data: ArticleCreate) {
  return request({
    url: '/api/article',
    method: 'post',
    data
  })
}

// 更新文章
export function updateArticle(data: ArticleUpdate) {
  return request({
    url: '/api/article',
    method: 'put',
    data
  })
}

// 删除文章
export function deleteArticle(articleId: number) {
  return request({
    url: `/api/article/${articleId}`,
    method: 'delete'
  })
}

// 点赞文章
export function toggleLike(articleId: number) {
  return request({
    url: `/api/article/like/${articleId}`,
    method: 'post'
  })
}
```

---

## 本质总结

### 完整的数据流

```
前端请求
  ↓
路由匹配
  ↓
Pydantic 验证
  ↓
依赖注入
  ↓
Controller
  ↓
Service
  ↓
数据库操作
  ↓
DO → VO 转换
  ↓
统一响应格式
  ↓
前端接收
```

### 核心要点

1. **分层设计**：Controller → Service → DO
2. **模型分离**：DO（数据库）、VO（返回）、Query（请求）
3. **统一响应**：Resp.success/error
4. **依赖注入**：自动管理数据库会话、当前用户
5. **异常处理**：BusinessException
6. **软删除**：标记删除，不物理删除

---

## 学习检查清单

完成本实战后，你应该能够：

- [ ] 设计合理的数据库表结构
- [ ] 定义 DO、VO、Query 模型
- [ ] 实现 CRUD 操作
- [ ] 处理关联关系（JOIN）
- [ ] 实现分页查询
- [ ] 实现软删除
- [ ] 正确使用事务
- [ ] 实现权限控制
- [ ] 处理异常情况

---

## 下一步建议

你已经掌握了后端开发的核心知识，接下来可以：

1. **深入学习**：
   - Redis 缓存的应用
   - 定时任务（APScheduler）
   - 文件上传处理
   - WebSocket 实时通信

2. **实践项目**：
   - 为现有项目添加新功能
   - 优化查询性能
   - 添加单元测试
   - 部署到生产环境

3. **拓展视野**：
   - 学习其他后端框架（Express、NestJS）
   - 了解微服务架构
   - 学习容器化部署（Docker）
   - 掌握 CI/CD 流程

---

**恭喜你完成学习！** 你已经具备了独立开发后端 API 的能力。
