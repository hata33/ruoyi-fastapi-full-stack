# 思维转变：从请求到响应

> 你每天都在调用 API，但你有想过 API 是如何工作的吗？让我们从"消费者"变成"生产者"。

## 前端视角 vs 后端视角

### 你熟悉的场景（前端）

```typescript
// 前端代码
const getUsers = async () => {
  const response = await axios.get('/api/users?page=1&size=10')
  const data = response.data  // { code: 200, rows: [], total: 100 }
  return data
}
```

你关注的是：
- 发送请求（调用 API）
- 等待响应（await）
- 处理数据（渲染页面）

### 你需要理解的场景（后端）

```python
# 后端代码
@app.get("/users")
async def get_users(page: int = 1, size: int = 10):
    # 1. 接收请求
    # 2. 处理业务逻辑
    users = await user_service.get_list(page, size)
    # 3. 返回响应
    return {"code": 200, "rows": users, "total": 100}
```

后端关注的是：
- 接收请求（解析 HTTP）
- 处理逻辑（查询数据库）
- 返回响应（序列化数据）

---

## HTTP 的本质：请求-响应模型

### 核心概念

HTTP 是一个**无状态的请求-响应协议**：

```mermaid
sequenceDiagram
    participant C as 客户端
    participant S as 服务器

    C->>S: ① 发送请求 (Request)<br/>GET /api/users
    Note over S: ② 处理请求
    S-->>C: ③ 返回响应 (Response)<br/>{"code": 200, "rows": []}
```

**关键理解**：
1. **无状态**：每次请求都是独立的，服务器不记得你上次请求了什么
2. **主动方**：客户端必须主动发起请求，服务器不能主动推送
3. **文本协议**：请求和响应都是文本（JSON、HTML、XML）

### 请求的构成

当你调用 `axios.get('/api/users?page=1')` 时，实际发送的是：

```http
GET /api/users?page=1&size=10 HTTP/1.1
Host: localhost:9099
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Content-Type: application/json
```

后端看到的是：
```python
@app.get("/users")  # 对应 GET /users
async def get_users(
    page: int = 1,      # 从 ?page=1 解析
    size: int = 10,     # 从 ?size=10 解析
    token: str = Depends(get_token)  # 从 Authorization 头解析
):
    pass
```

**本质映射**：
- URL 路径 → 路由函数
- 查询参数 → 函数参数
- 请求头 → 依赖注入
- 请求体 → Pydantic 模型

### 响应的构成

后端返回数据时：

```python
@app.get("/users")
async def get_users():
    return {"code": 200, "rows": [], "total": 0}
```

实际发送的是：

```http
HTTP/1.1 200 OK
Content-Type: application/json

{"code": 200, "rows": [], "total": 0}
```

前端收到的是：

```typescript
const response = await axios.get('/api/users')
// response.status = 200
// response.data = { code: 200, rows: [], total: 0 }
```

**本质映射**：
- 返回值 → JSON 序列化
- HTTPException → 状态码
- 响应头 → Content-Type 等

---

## 核心 1：路由 - URL 如何映射到代码

### 前端类比：Vue Router

```typescript
// 前端路由
const routes = [
  { path: '/users/:id', component: UserDetail }
]

// 访问 /users/123 会渲染 UserDetail 组件
```

### 后端路由：同样的概念

```python
# 后端路由
@app.get("/users/{user_id}")  # 路径参数
async def get_user(user_id: int):  # 自动转换为 int
    return {"user_id": user_id}

# 访问 GET /users/123 会调用这个函数
```

### 路由参数类型

| 类型 | 前端示例 | 后端示例 |
|------|----------|----------|
| 路径参数 | `/users/:id` | `@app.get("/users/{user_id}")` |
| 查询参数 | `?page=1&size=10` | `page: int = 1, size: int = 10` |
| 请求体 | `axios.post('/users', { name: '张三' })` | `user: UserModel` |

### 项目中的实际应用

```python
# module_admin/controller/user_controller.py

@userController.post("/list")  # POST 请求
async def get_user_list(
    query_user: UserModel,  # 请求体
    query_db: AsyncSession = Depends(get_db)  # 依赖注入
):
    # 业务逻辑
    pass
```

**前端调用**：
```typescript
// 前端代码
const { data } = await axios.post('/api/user/list', {
  userName: 'admin',
  status: '0'
})
```

---

## 核心 2：请求处理 - 数据如何流入后端

### 前端视角：你发送什么

```typescript
axios.post('/api/user', {
  userName: 'zhangsan',
  email: 'zhangsan@example.com',
  status: '0'
})
```

### 后端视角：如何接收数据

```python
from pydantic import BaseModel, Field

class UserModel(BaseModel):
    userName: str = Field(min_length=3, max_length=30)
    email: str = Field(regex=r'^[^@]+@[^@]+\.[^@]+$')
    status: str = Field(default='0')

@app.post("/user")
async def create_user(user: UserModel):
    # user.userName 自动从 JSON 解析
    # user.email 已经验证过格式
    return {"code": 200, "msg": "成功"}
```

### 数据流动过程

```mermaid
flowchart LR
    A[前端发送 JSON] --> B[Pydantic 验证]
    B --> C{userName<br/>是否符合规则?}
    C -->|✓ 通过| D[user.userName]
    D --> E[业务逻辑使用]
```

**示例数据**：
- 前端发送：`{"userName": "zhangsan"}`
- 验证通过后：`user.userName = "zhangsan"`

### 本质理解：类型系统

**前端 TypeScript**：
```typescript
interface User {
  userName: string
  email: string
}

const user: User = { userName: 'zhangsan', email: '...' }
```

**后端 Python（Pydantic）**：
```python
class UserModel(BaseModel):
    userName: str
    email: str

user = UserModel(userName='zhangsan', email='...')
```

**它们是同一个概念**：用类型来约束数据，让代码更安全！

---

## 核心 3：响应处理 - 数据如何流回前端

### 统一响应格式

前端希望收到的响应是**一致的**：

```typescript
// 理想情况：所有接口都返回这个格式
interface ApiResponse<T> {
  code: number
  msg: string
  rows: T[]  // 或 data: T
  total?: number
}
```

### 后端如何实现

```python
# module_admin/common/response.py

class ResponseModel:
    @staticmethod
    def success(data=None, msg="操作成功"):
        return {"code": 200, "msg": msg, "rows": data}

    @staticmethod
    def error(msg="操作失败", code=500):
        return {"code": code, "msg": msg}

# 使用
@app.get("/users")
async def get_users():
    users = await user_service.get_list()
    return ResponseModel.success(users)  # 统一格式
```

### 数据序列化

#### 什么是序列化？

**前端类比**：
```typescript
// 前端经常做这些事
const user = { id: 1, name: '张三', password: '...' }
const json = JSON.stringify(user)  // 序列化：对象 → JSON 字符串
const obj = JSON.parse(json)       // 反序列化：JSON 字符串 → 对象
```

**后端同样的概念**：
```python
# 序列化：Python 对象 → JSON 字符串（发送给前端）
user = {"user_id": 1, "user_name": "张三"}
json_str = json.dumps(user)  # '{"user_id": 1, "user_name": "张三"}'

# 反序列化：JSON 字符串 → Python 对象（接收前端数据）
json_str = '{"userName": "张三"}'
user = json.loads(json_str)  # {"userName": "张三"}
```

#### 为什么需要序列化？

```mermaid
flowchart LR
    A[Python 对象] -->|序列化| B[JSON 字符串]
    B -->|HTTP 传输| C[前端接收]
    C -->|反序列化| D[JavaScript 对象]
```

**关键原因**：
1. **HTTP 只能传输文本**：不能直接传输 Python 对象
2. **跨语言通信**：前端用 JS，后端用 Python，需要通用格式（JSON）
3. **数据脱敏**：不把敏感数据（如 password）发给前端

#### 问题：数据库对象不能直接序列化

**问题示例**：

```python
# SQLAlchemy ORM 对象
user = SysUser(
    user_id=1,
    user_name="admin",
    password="hashed_password",
    email="admin@example.com"
)

# ❌ 直接返回会报错
return user
# TypeError: Object of type SysUser is not JSON serializable

# ❌ 即使转成 dict 也不行
return user.__dict__
# 可能包含 SQLAlchemy 内部属性，且包含 password
```

**为什么不行？**
- SQLAlchemy 对象包含数据库关系、懒加载等复杂属性
- JSON 不知道如何转换这些属性
- 包含敏感数据（password、salt 等）

#### 解决方案：使用 Pydantic VO（视图对象）

**完整示例**：

```python
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

# 1. 定义 VO（View Object）- 只包含前端需要的数据
class UserVO(BaseModel):
    """用户视图对象 - 返回给前端"""
    userId: int = Field(alias="user_id")
    userName: str = Field(alias="user_name")
    email: Optional[str] = None
    createTime: str = Field(alias="create_time")
    # 注意：没有 password 字段！

    class Config:
        from_attributes = True  # 支持从 ORM 对象创建
        populate_by_name = True # 支持字段别名

# 2. 在 Controller 中使用
@userController.get("/user/{user_id}")
async def get_user(user_id: int, query_db: AsyncSession = Depends(get_db)):
    # 查询数据库
    user = await query_db.get(SysUser, user_id)

    if not user:
        raise BusinessException("用户不存在", code=404)

    # 转换为 VO
    user_vo = UserVO.model_validate(user)

    # 返回序列化的数据
    return Resp.success(data=user_vo)

# 返回给前端的 JSON：
# {
#   "code": 200,
#   "msg": "操作成功",
#   "data": {
#     "userId": 1,
#     "userName": "admin",
#     "email": "admin@example.com",
#     "createTime": "2026-02-02 10:30:00"
#   }
# }
```

#### 序列化的三个层次

```mermaid
flowchart TB
    subgraph 数据库层
        A[SysUser<br/>DO<br/>包含所有字段]
    end

    subgraph 业务层
        B[UserVO<br/>视图对象<br/>过滤敏感字段]
    end

    subgraph 传输层
        C[JSON<br/>字符串<br/>HTTP 传输]
    end

    A -->|1. model_validate| B
    B -->|2. json.dumps| C
    C -->|3. HTTP Response| D[前端接收] 
```

**代码示例**：

```python
# 第 1 层：数据库对象（DO）
user = SysUser(
    user_id=1,
    user_name="admin",
    password="hashed_password",  # 敏感数据
    salt="random_salt",          # 敏感数据
    email="admin@example.com"
)

# 第 2 层：转换为 VO
user_vo = UserVO.model_validate(user)
# user_vo.userId = 1
# user_vo.userName = "admin"
# user_vo.password 不存在！✓ 数据脱敏

# 第 3 层：FastAPI 自动序列化为 JSON
return Resp.success(data=user_vo)
# HTTP 响应体：{"code": 200, "data": {"userId": 1, ...}}
```

#### 核心：model_validate 原理

**model_validate 是什么？**

`model_validate()` 是 Pydantic 提供的核心方法，用于从其他对象（如 SQLAlchemy ORM 对象）创建 Pydantic 模型实例。它本质上是一个"智能转换器"。

```mermaid
flowchart LR
    A[SQLAlchemy 对象] --> B[model_validate]
    B --> C{读取<br/>from_attributes?}
    C -->|True| D[从对象属性读取]
    C -->|False| E[从字典读取]
    D --> F[字段映射<br/>alias 处理]
    E --> F
    F --> G[类型转换/验证]
    G --> H[Pydantic VO 实例]

    style A fill:#e1f5ff
    style B fill:#fff4e1
    style G fill:#ffe1f5
    style H fill:#e1ffe1
```

**内部执行步骤**：

```python
# 伪代码：model_validate 的简化逻辑
def model_validate(cls, obj):
    """
    Pydantic 内部执行的步骤
    """
    # 1. 判断 from_attributes 配置
    if cls.__config__.from_attributes:
        # 允许从对象属性读取（如 user.user_id）
        data = extract_from_object(obj)
    else:
        # 只能从字典读取（如 obj["user_id"]）
        data = extract_from_dict(obj)

    # 2. 字段映射：通过 alias 找到源字段名
    for field in cls.__fields__:
        alias = field.alias  # "user_id"
        value = getattr(obj, alias, None)  # user.user_id

    # 3. 类型验证和转换
    validated_data = validate_types(data)

    # 4. 创建 Pydantic 实例
    return cls(**validated_data)
```

**实际运行示例**：

```python
# ========== 源对象（SQLAlchemy）==========
user = SysUser(
    user_id=1,
    user_name="admin",
    password="hashed_password",  # 敏感数据
    email="admin@example.com"
)

# ========== 目标 VO（Pydantic）==========
class UserVO(BaseModel):
    userId: int = Field(alias="user_id")
    userName: str = Field(alias="user_name")
    email: str
    # 注意：没有 password 字段！

    class Config:
        from_attributes = True

# ========== 转换过程 ==========
user_vo = UserVO.model_validate(user)

# Pydantic 内部自动完成：
# 1. 扫描 UserVO 的字段：['userId', 'userName', 'email']
# 2. 对每个字段，从 user 对象读取值：
#    userId:   user.user_id  → 1
#    userName: user.user_name → "admin"
#    email:    user.email     → "admin@example.com"
#    password: (VO 中没定义，跳过) ✓ 自动过滤敏感数据
# 3. 类型验证：
#    1 是 int?         ✓
#    "admin" 是 str?   ✓
# 4. 创建 UserVO 实例并返回

print(user_vo.model_dump())
# {
#   'userId': 1,
#   'userName': 'admin',
#   'email': 'admin@example.com'
# }
# password 自动被过滤了！
```

**关键配置说明**：

```python
class UserVO(BaseModel):
    userId: int = Field(alias="user_id")

    class Config:
        from_attributes = True      # 关键配置 1
        populate_by_name = True     # 关键配置 2
```

| 配置 | 作用 | 示例 |
|------|------|------|
| `from_attributes = True` | 允许从对象属性读取 | `user.user_id` → ✓ |
| `populate_by_name = True` | 支持别名和字段名两种输入方式 | `{"user_id": 1}` 或 `{"userId": 1}` 都可以 |

**实际开发中的标准用法**：

```python
# ========== 1. 定义 VO（约定）==========
class UserVO(BaseModel):
    """用户视图对象 - 返回给前端"""
    userId: int = Field(alias="user_id")
    userName: str = Field(alias="user_name")
    email: str

    class Config:
        from_attributes = True
        populate_by_name = True

# ========== 2. Controller 中使用（标准模式）==========
@userController.get("/user/{user_id}")
async def get_user(user_id: int, query_db: AsyncSession = Depends(get_db)):
    # ① 查询数据库
    user = await query_db.get(SysUser, user_id)

    if not user:
        raise BusinessException("用户不存在", code=404)

    # ② 转换为 VO（一步到位）
    user_vo = UserVO.model_validate(user)

    # ③ 返回（FastAPI 自动序列化为 JSON）
    return Resp.success(data=user_vo)

# 就这么简单！三个步骤完成数据传输
```

**与手动转换对比**：

```python
# ❌ 手动转换（繁琐、容易出错）
user_vo = UserVO(
    userId=user.user_id,        # 手动映射每个字段
    userName=user.user_name,
    email=user.email
)
# 问题：
# - 字段多时很麻烦
# - 容易遗漏或写错
# - 没有类型验证

# ✅ 使用 model_validate（自动、安全）
user_vo = UserVO.model_validate(user)
# 优点：
# - 自动读取所有需要的字段
# - 自动进行类型验证
# - 自动过滤不需要的字段（如 password）
# - 自动处理字段别名（user_id → userId）
```

**前端类比**：

```typescript
// 前端需要手动做这些事
interface UserVO {
  userId: number
  userName: string
  // 没有 password
}

const user = { user_id: 1, user_name: "admin", password: "secret" }

// 手动转换
const userVO: UserVO = {
  userId: user.user_id,
  userName: user.user_name
  // password 被过滤
}

// 后端的 model_validate 就相当于自动完成了这个转换过程
```

**本质理解**：

`model_validate()` 做了四件事：

1. **智能读取**：根据 `from_attributes` 配置，自动从对象属性读取值
2. **字段映射**：通过 `alias` 自动转换字段名（`user_id` → `userId`）
3. **类型验证**：确保数据类型正确，或自动转换（如 `int("1")`）
4. **数据过滤**：只包含 VO 中定义的字段，自动过滤敏感数据

**实际项目中的流程**：

```mermaid
flowchart TB
    A[定义 VO] --> B[Controller 查询数据库]
    B --> C[得到 DO 对象]
    C --> D[model_validate<br/>自动转换]
    D --> E[得到 VO 对象]
    E --> F[Resp.success<br/>封装响应]
    F --> G[FastAPI<br/>自动序列化]
    G --> H[前端接收 JSON]

    style A fill:#e1f5ff
    style D fill:#fff4e1
    style G fill:#ffe1f5
    style H fill:#e1ffe1
```

**总结**：

在实际开发中，你只需要：
1. **约定好 VO**：定义字段、类型、别名
2. **调用 model_validate**：一步完成转换
3. **返回 VO**：FastAPI 自动序列化

这就是数据从数据库到前端的完整流程！

#### 处理复杂场景

**场景 1：字段别名转换**

```python
# 数据库字段：user_id（下划线）
# 前端字段：userId（驼峰）

class UserVO(BaseModel):
    userId: int = Field(alias="user_id")  # 映射
    userName: str = Field(alias="user_name")

    class Config:
        from_attributes = True
        populate_by_name = True

# 自动转换：user_id → userId
```

**场景 2：嵌套对象序列化**

```python
class RoleVO(BaseModel):
    roleId: int
    roleName: str

class UserWithRolesVO(BaseModel):
    userId: int
    userName: str
    roles: list[RoleVO]  # 嵌套列表

    class Config:
        from_attributes = True

# FastAPI 会递归序列化所有嵌套对象
```

**场景 3：日期时间格式化**

```python
class UserVO(BaseModel):
    userId: int
    createTime: str  # 定义为字符串

    @classmethod
    def from_db(cls, user: SysUser):
        """自定义转换逻辑"""
        return cls(
            userId=user.user_id,
            createTime=user.create_time.strftime('%Y-%m-%d %H:%M:%S')
        )

# 使用
user_vo = UserVO.from_db(user)
# createTime = "2026-02-02 10:30:00"
```

**场景 4：计算字段**

```python
class TransactionVO(BaseModel):
    transactionId: int
    amount: float
    type: str
    typeText: str  # 计算字段：支出/收入

    @classmethod
    def from_db(cls, transaction: Transaction):
        return cls(
            transactionId=transaction.transaction_id,
            amount=float(transaction.amount),
            type=transaction.type,
            typeText="支出" if transaction.type == "1" else "收入"
        )
```

#### 前后端对比

| 操作 | 前端（JavaScript） | 后端（Python） |
|------|-------------------|----------------|
| **序列化** | `JSON.stringify(obj)` | `json.dumps(obj)` / FastAPI 自动 |
| **反序列化** | `JSON.parse(str)` | `json.loads(str)` / Pydantic 解析 |
| **类型定义** | `interface User` | `class UserVO(BaseModel)` |
| **数据脱敏** | `const { password, ...rest } = user` | VO 中不定义 password 字段 |
| **字段映射** | 手动映射 | Field(alias="xxx") |

#### 常见问题

**Q1：为什么不直接用 dict？**

```python
# ❌ 不推荐：手动转 dict
return {
    "userId": user.user_id,
    "userName": user.user_name,
    "createTime": user.create_time.strftime('%Y-%m-%d')
}
# 问题：没有类型检查，容易出错

# ✅ 推荐：使用 Pydantic VO
return UserVO.model_validate(user)
# 优点：有类型检查、自动验证、文档生成
```

**Q2：DateTime 类型的字段如何处理？**

```python
# 方案 1：在 VO 中定义为字符串
class UserVO(BaseModel):
    createTime: str

    @classmethod
    def from_db(cls, user: SysUser):
        return cls(
            createTime=user.create_time.strftime('%Y-%m-%d %H:%M:%S')
        )

# 方案 2：使用 Pydantic 的 JSON 编码器
class UserVO(BaseModel):
    createTime: datetime

    class Config:
        json_encoders = {
            datetime: lambda v: v.strftime('%Y-%m-%d %H:%M:%S')
        }
```

**Q3：列表数据如何序列化？**

```python
@userController.get("/user/list")
async def get_user_list(query_db: AsyncSession = Depends(get_db)):
    # 查询列表
    users = await query_db.execute(select(SysUser))
    user_list = users.scalars().all()

    # 批量转换为 VO
    user_vos = [UserVO.model_validate(u) for u in user_list]

    return Resp.success(data=user_vos)
```

#### 项目中的实际应用

```python
# module_admin/entity/vo/user_vo.py
from pydantic import BaseModel, Field
from typing import Optional, List

class UserVO(BaseModel):
    """用户视图对象"""
    userId: int = Field(alias="user_id", description="用户ID")
    userName: str = Field(alias="user_name", description="用户名")
    nickName: Optional[str] = Field(default=None, alias="nick_name", description="昵称")
    email: Optional[str] = Field(default=None, description="邮箱")
    phonenumber: Optional[str] = Field(default=None, description="手机号")
    sex: Optional[str] = Field(default=None, description="性别")
    avatar: Optional[str] = Field(default=None, description="头像")
    status: str = Field(description="状态")
    createTime: str = Field(alias="create_time", description="创建时间")

    class Config:
        from_attributes = True
        populate_by_name = True

# module_admin/controller/user_controller.py
@userController.get("/user/{user_id}")
async def get_user_info(
    user_id: int,
    query_db: AsyncSession = Depends(get_db)
):
    """获取用户信息"""
    # 1. 查询数据库
    user = await query_db.get(SysUser, user_id)

    # 2. 检查是否存在
    if not user:
        raise BusinessException("用户不存在", code=404)

    # 3. 转换为 VO
    user_vo = UserVO.model_validate(user)

    # 4. 返回（FastAPI 自动序列化）
    return Resp.success(data=user_vo)

# 返回示例：
# {
#   "code": 200,
#   "msg": "操作成功",
#   "data": {
#     "userId": 1,
#     "userName": "admin",
#     "nickName": "管理员",
#     "email": "admin@example.com",
#     "createTime": "2026-02-02 10:30:00"
#   }
# }
```

---

## 核心 4：状态码 - 表达请求的结果

### 常用状态码

| 状态码 | 含义 | 前端处理 | 后端返回 |
|--------|------|----------|----------|
| 200 | 成功 | 正常处理数据 | `return {...}` |
| 401 | 未登录 | 跳转登录页 | `raise HTTPException(401)` |
| 403 | 无权限 | 提示无权限 | `raise HTTPException(403)` |
| 404 | 不存在 | 提示资源不存在 | `raise HTTPException(404)` |
| 500 | 服务器错误 | 提示系统错误 | 异常自动处理 |

### 项目中的实现

```python
# module_admin/common/exception.py

class BusinessException(Exception):
    def __init__(self, message: str, code: int = 500):
        self.message = message
        self.code = code

# 全局异常处理器
@app.exception_handler(BusinessException)
async def business_exception_handler(request, exc):
    return JSONResponse(
        status_code=200,  # 注意：业务异常也返回 200
        content={"code": exc.code, "msg": exc.message}
    )

# 使用
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = await user_service.get_by_id(user_id)
    if not user:
        raise BusinessException("用户不存在", code=404)
    return user
```

---

## 实战：追踪一个完整的请求

### 场景：用户登录

#### 第 1 步：前端发送请求

```typescript
// 前端代码
const login = async () => {
  const { data } = await axios.post('/api/login', {
    username: 'admin',
    password: 'admin123',
    code: '1234',
    uuid: '...'
  })

  if (data.code === 200) {
    localStorage.setItem('token', data.token)
  }
}
```

#### 第 2 步：后端接收请求

```python
# module_admin/controller/login_controller.py

@loginController.post("/login")
async def login(
    request: Request,
    login_body: LoginBody,  # Pydantic 模型
    query_db: AsyncSession = Depends(get_db)
):
    # 1. 验证验证码
    await validate_captcha(login_body.uuid, login_body.code)

    # 2. 查询用户
    user = await user_service.get_by_username(query_db, login_body.username)

    # 3. 验证密码
    if not validate_password(login_body.password, user.password):
        raise BusinessException("密码错误")

    # 4. 生成 Token
    token = create_jwt_token(user)

    # 5. 返回响应
    return {"code": 200, "token": token}
```

#### 第 3 步：前端接收响应

```typescript
// 前端代码
const { data } = await axios.post('/api/login', {...})
// data = { code: 200, token: 'eyJhbGciOiJIUzI1NiIs...' }
```

---

## 本质总结：后端开发的三大问题

1. **如何接收数据？**
   - 路径参数 → 函数参数
   - 查询参数 → 函数参数
   - 请求体 → Pydantic 模型

2. **如何处理数据？**
   - 调用 Service 层
   - 查询数据库
   - 业务逻辑处理

3. **如何返回数据？**
   - 统一响应格式
   - 数据序列化（VO 模型）
   - 正确的状态码

---

## 检查清单

理解了本节内容，你应该能回答：

- [ ] HTTP 请求和响应的构成是什么？
- [ ] 后端路由和前端路由的异同点是什么？
- [ ] Pydantic 模型和 TypeScript 接口的共同点是什么？
- [ ] 为什么需要统一的响应格式？
- [ ] 数据库对象不能直接序列化为 JSON，如何解决？
- [ ] 状态码 200、401、403、404、500 分别表示什么？

**下一步**：学习 [数据处理：模型即代码](./02-数据处理-模型即代码.md)
