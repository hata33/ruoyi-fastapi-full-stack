# 思维转变：从请求到响应

> 你每天都在调用 API，但你有想过 API 是如何工作的吗？让我们从"消费者"变成"生产者"。

## 前端视角 vs 后端视角

### 你熟悉的场景（前端）

```typescript
// 前端代码
const getUsers = async () => {
  const response = await axios.get('/api/users?page=1&size=10')
  const data = response.data  // { code: 200, rows: [], total: 100 }
  return data
}
```

你关注的是：
- 发送请求（调用 API）
- 等待响应（await）
- 处理数据（渲染页面）

### 你需要理解的场景（后端）

```python
# 后端代码
@app.get("/users")
async def get_users(page: int = 1, size: int = 10):
    # 1. 接收请求
    # 2. 处理业务逻辑
    users = await user_service.get_list(page, size)
    # 3. 返回响应
    return {"code": 200, "rows": users, "total": 100}
```

后端关注的是：
- 接收请求（解析 HTTP）
- 处理逻辑（查询数据库）
- 返回响应（序列化数据）

---

## HTTP 的本质：请求-响应模型

### 核心概念

HTTP 是一个**无状态的请求-响应协议**：

```
客户端                              服务器
  │                                   │
  │  ① 发送请求 (Request)              │
  │ ─────────────────────────────────>│
  │     GET /api/users                │
  │                                   │
  │              ② 处理请求             │
  │              ─────────            │
  │                                   │
  │  ③ 返回响应 (Response)             │
  │ <─────────────────────────────────│
  │     {"code": 200, "rows": []}     │
```

**关键理解**：
1. **无状态**：每次请求都是独立的，服务器不记得你上次请求了什么
2. **主动方**：客户端必须主动发起请求，服务器不能主动推送
3. **文本协议**：请求和响应都是文本（JSON、HTML、XML）

### 请求的构成

当你调用 `axios.get('/api/users?page=1')` 时，实际发送的是：

```http
GET /api/users?page=1&size=10 HTTP/1.1
Host: localhost:9099
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Content-Type: application/json
```

后端看到的是：
```python
@app.get("/users")  # 对应 GET /users
async def get_users(
    page: int = 1,      # 从 ?page=1 解析
    size: int = 10,     # 从 ?size=10 解析
    token: str = Depends(get_token)  # 从 Authorization 头解析
):
    pass
```

**本质映射**：
- URL 路径 → 路由函数
- 查询参数 → 函数参数
- 请求头 → 依赖注入
- 请求体 → Pydantic 模型

### 响应的构成

后端返回数据时：

```python
@app.get("/users")
async def get_users():
    return {"code": 200, "rows": [], "total": 0}
```

实际发送的是：

```http
HTTP/1.1 200 OK
Content-Type: application/json

{"code": 200, "rows": [], "total": 0}
```

前端收到的是：

```typescript
const response = await axios.get('/api/users')
// response.status = 200
// response.data = { code: 200, rows: [], total: 0 }
```

**本质映射**：
- 返回值 → JSON 序列化
- HTTPException → 状态码
- 响应头 → Content-Type 等

---

## 核心 1：路由 - URL 如何映射到代码

### 前端类比：Vue Router

```typescript
// 前端路由
const routes = [
  { path: '/users/:id', component: UserDetail }
]

// 访问 /users/123 会渲染 UserDetail 组件
```

### 后端路由：同样的概念

```python
# 后端路由
@app.get("/users/{user_id}")  # 路径参数
async def get_user(user_id: int):  # 自动转换为 int
    return {"user_id": user_id}

# 访问 GET /users/123 会调用这个函数
```

### 路由参数类型

| 类型 | 前端示例 | 后端示例 |
|------|----------|----------|
| 路径参数 | `/users/:id` | `@app.get("/users/{user_id}")` |
| 查询参数 | `?page=1&size=10` | `page: int = 1, size: int = 10` |
| 请求体 | `axios.post('/users', { name: '张三' })` | `user: UserModel` |

### 项目中的实际应用

```python
# module_admin/controller/user_controller.py

@userController.post("/list")  # POST 请求
async def get_user_list(
    query_user: UserModel,  # 请求体
    query_db: AsyncSession = Depends(get_db)  # 依赖注入
):
    # 业务逻辑
    pass
```

**前端调用**：
```typescript
// 前端代码
const { data } = await axios.post('/api/user/list', {
  userName: 'admin',
  status: '0'
})
```

---

## 核心 2：请求处理 - 数据如何流入后端

### 前端视角：你发送什么

```typescript
axios.post('/api/user', {
  userName: 'zhangsan',
  email: 'zhangsan@example.com',
  status: '0'
})
```

### 后端视角：如何接收数据

```python
from pydantic import BaseModel, Field

class UserModel(BaseModel):
    userName: str = Field(min_length=3, max_length=30)
    email: str = Field(regex=r'^[^@]+@[^@]+\.[^@]+$')
    status: str = Field(default='0')

@app.post("/user")
async def create_user(user: UserModel):
    # user.userName 自动从 JSON 解析
    # user.email 已经验证过格式
    return {"code": 200, "msg": "成功"}
```

### 数据流动过程

```
前端发送                          后端处理
─────────────────────────────────────────────────
JSON:
{ userName: "zhangsan" }          ↓
                                  ↓ Pydantic 验证
                                  ↓ userName 是否符合规则？
                                  ↓ ✓ 通过
                                  ↓ user.userName = "zhangsan"
                                  ↓
业务逻辑使用                       ↓
user.userName                      ↓
```

### 本质理解：类型系统

**前端 TypeScript**：
```typescript
interface User {
  userName: string
  email: string
}

const user: User = { userName: 'zhangsan', email: '...' }
```

**后端 Python（Pydantic）**：
```python
class UserModel(BaseModel):
    userName: str
    email: str

user = UserModel(userName='zhangsan', email='...')
```

**它们是同一个概念**：用类型来约束数据，让代码更安全！

---

## 核心 3：响应处理 - 数据如何流回前端

### 统一响应格式

前端希望收到的响应是**一致的**：

```typescript
// 理想情况：所有接口都返回这个格式
interface ApiResponse<T> {
  code: number
  msg: string
  rows: T[]  // 或 data: T
  total?: number
}
```

### 后端如何实现

```python
# module_admin/common/response.py

class ResponseModel:
    @staticmethod
    def success(data=None, msg="操作成功"):
        return {"code": 200, "msg": msg, "rows": data}

    @staticmethod
    def error(msg="操作失败", code=500):
        return {"code": code, "msg": msg}

# 使用
@app.get("/users")
async def get_users():
    users = await user_service.get_list()
    return ResponseModel.success(users)  # 统一格式
```

### 数据序列化

**问题**：数据库对象不能直接转 JSON

```python
# SQLAlchemy 对象
user = SysUser(user_id=1, user_name="admin", password="...")

# 直接返回会出错
return user  # ❌ TypeError: Object is not JSON serializable
```

**解决方案**：使用 Pydantic 模型（VO）

```python
class UserVO(BaseModel):
    userId: int
    userName: str
    # 不包含 password！

    class Config:
        from_attributes = True  # 支持从 ORM 对象创建

# 使用
user_vo = UserVO.model_validate(user)  # ✓ 自动转换
return user_vo  # ✓ 可以序列化为 JSON
```

**前端类比**：
```typescript
// 前端也这样做：只暴露需要的数据
interface UserVO {
  userId: number
  userName: string
  // 没有 password
}

const userVO: UserVO = { ...user, password: undefined }  // 脱敏
```

---

## 核心 4：状态码 - 表达请求的结果

### 常用状态码

| 状态码 | 含义 | 前端处理 | 后端返回 |
|--------|------|----------|----------|
| 200 | 成功 | 正常处理数据 | `return {...}` |
| 401 | 未登录 | 跳转登录页 | `raise HTTPException(401)` |
| 403 | 无权限 | 提示无权限 | `raise HTTPException(403)` |
| 404 | 不存在 | 提示资源不存在 | `raise HTTPException(404)` |
| 500 | 服务器错误 | 提示系统错误 | 异常自动处理 |

### 项目中的实现

```python
# module_admin/common/exception.py

class BusinessException(Exception):
    def __init__(self, message: str, code: int = 500):
        self.message = message
        self.code = code

# 全局异常处理器
@app.exception_handler(BusinessException)
async def business_exception_handler(request, exc):
    return JSONResponse(
        status_code=200,  # 注意：业务异常也返回 200
        content={"code": exc.code, "msg": exc.message}
    )

# 使用
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = await user_service.get_by_id(user_id)
    if not user:
        raise BusinessException("用户不存在", code=404)
    return user
```

---

## 实战：追踪一个完整的请求

### 场景：用户登录

#### 第 1 步：前端发送请求

```typescript
// 前端代码
const login = async () => {
  const { data } = await axios.post('/api/login', {
    username: 'admin',
    password: 'admin123',
    code: '1234',
    uuid: '...'
  })

  if (data.code === 200) {
    localStorage.setItem('token', data.token)
  }
}
```

#### 第 2 步：后端接收请求

```python
# module_admin/controller/login_controller.py

@loginController.post("/login")
async def login(
    request: Request,
    login_body: LoginBody,  # Pydantic 模型
    query_db: AsyncSession = Depends(get_db)
):
    # 1. 验证验证码
    await validate_captcha(login_body.uuid, login_body.code)

    # 2. 查询用户
    user = await user_service.get_by_username(query_db, login_body.username)

    # 3. 验证密码
    if not validate_password(login_body.password, user.password):
        raise BusinessException("密码错误")

    # 4. 生成 Token
    token = create_jwt_token(user)

    # 5. 返回响应
    return {"code": 200, "token": token}
```

#### 第 3 步：前端接收响应

```typescript
// 前端代码
const { data } = await axios.post('/api/login', {...})
// data = { code: 200, token: 'eyJhbGciOiJIUzI1NiIs...' }
```

---

## 本质总结：后端开发的三大问题

1. **如何接收数据？**
   - 路径参数 → 函数参数
   - 查询参数 → 函数参数
   - 请求体 → Pydantic 模型

2. **如何处理数据？**
   - 调用 Service 层
   - 查询数据库
   - 业务逻辑处理

3. **如何返回数据？**
   - 统一响应格式
   - 数据序列化（VO 模型）
   - 正确的状态码

---

## 检查清单

理解了本节内容，你应该能回答：

- [ ] HTTP 请求和响应的构成是什么？
- [ ] 后端路由和前端路由的异同点是什么？
- [ ] Pydantic 模型和 TypeScript 接口的共同点是什么？
- [ ] 为什么需要统一的响应格式？
- [ ] 数据库对象不能直接序列化为 JSON，如何解决？
- [ ] 状态码 200、401、403、404、500 分别表示什么？

**下一步**：学习 [数据处理：模型即代码](./02-数据处理-模型即代码.md)
