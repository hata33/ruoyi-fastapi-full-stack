# 数据处理：模型即代码

> 前端用 TypeScript 接口定义数据，后端用模型定义数据。理解类型系统的本质，你就理解了数据处理的核心。

## 前端类比：TypeScript 接口

### 你熟悉的代码

```typescript
// 前端定义数据结构
interface User {
  userId: number
  userName: string
  email: string
  status: '0' | '1'
  createTime: string
}

// 使用接口
const user: User = {
  userId: 1,
  userName: 'admin',
  email: 'admin@example.com',
  status: '0',
  createTime: '2024-01-01 00:00:00'
}
```

### TypeScript 的作用

1. **类型约束**：编译时检查类型错误
2. **智能提示**：IDE 自动补全
3. **文档作用**：代码即文档

---

## 后端：三种模型，三种作用

后端也需要"类型"，但分为**三种模型**：

```
DO (Data Object)    ←→  数据库表结构
VO (View Object)    ←→  API 返回结构
Query Model         ←→  API 请求参数
```

### 为什么需要三种模型？

| 场景 | 需要的数据 | 使用的模型 |
|------|-----------|-----------|
| 存储到数据库 | 所有字段，包括密码 | DO (Entity) |
| 返回给前端 | 脱敏数据，不含密码 | VO |
| 接收前端请求 | 查询条件、分页参数 | Query Model |

---

## 模型 1：DO - 数据库的映射

### 本质：表结构的代码表示

**前端类比**：
```typescript
// 就像你定义的接口
interface User {
  userId: number
  userName: string
  password: string  // 包含敏感信息
}
```

**后端实现**：
```python
# module_admin/entity/do/user_do.py
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class SysUser(Base):
    __tablename__ = 'sys_user'  # 对应数据库表

    # 主键
    user_id = Column(Integer, primary_key=True, autoincrement=True)

    # 字段定义
    user_name = Column(String(30), nullable=False)
    password = Column(String(100), nullable=False)  # 敏感信息
    email = Column(String(50))
    status = Column(String(1), default='0')
    create_time = Column(DateTime)
```

### DO 的核心作用

1. **映射表结构**：定义数据库表的结构
2. **ORM 基础**：让 Python 对象能操作数据库
3. **类型安全**：编译时检查字段类型

### ORM 的本质

**ORM (Object-Relational Mapping)** = 用对象操作数据库

```python
# 不使用 ORM（SQL 方式）
query_db.execute("SELECT * FROM sys_user WHERE user_id = 1")
# 需要手写 SQL，容易出错

# 使用 ORM（对象方式）
result = await query_db.execute(
    select(SysUser).where(SysUser.user_id == 1)
)
user = result.scalar_one_or_none()
# 类型安全，IDE 有提示
```

**前端类比**：
```typescript
// 就像用对象操作 DOM，而不是直接操作 HTML
const element = document.getElementById('app')
element.innerHTML = 'Hello'  // 比直接操作 HTML 字符串更安全
```

---

## 模型 2：VO - API 的返回格式

### 本质：数据脱敏 + 格式转换

**问题**：不能直接返回 DO

```python
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = await get_user_by_id(user_id)
    return user  # ❌ 危险！会暴露密码字段
```

**解决方案**：使用 VO

```python
# module_admin/entity/vo/user_vo.py
from pydantic import BaseModel, Field

class UserVO(BaseModel):
    userId: int
    userName: str
    email: str
    # 没有 password 字段！

    createTime: str = Field(alias='createTime')  # 驼峰命名

    class Config:
        from_attributes = True  # 支持从 DO 创建

# 使用
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    # 1. 查询数据库，得到 DO
    user_do = await get_user_by_id(user_id)

    # 2. 转换为 VO（自动脱敏）
    user_vo = UserVO.model_validate(user_do)

    # 3. 返回 VO
    return user_vo  # ✓ 不包含密码
```

### VO 的核心作用

1. **数据脱敏**：不返回敏感字段（密码、手机号等）
2. **格式转换**：蛇形命名 → 驼峰命名
3. **组合数据**：可以包含多个 DO 的字段

**前端类比**：
```typescript
// 前端也这样做：只暴露需要的数据
interface UserVO {
  userId: number
  userName: string
  // 没有 password
}

const getUserVO = (user: User): UserVO => {
  const { password, ...rest } = user
  return rest  // 只返回非敏感字段
}
```

### 列表响应的 VO

```python
class UserListVO(BaseModel):
    userId: int
    userName: string
    deptName: string  # 来自关联的 dept 表

    class Config:
        from_attributes = True

# 使用：需要 JOIN 查询
@app.get("/users/list")
async def get_user_list():
    # 查询用户和部门
    result = await query_db.execute(
        select(SysUser, SysDept)
        .join(SysDept, SysUser.dept_id == SysDept.dept_id)
    )

    # 组合数据
    users = []
    for user, dept in result:
        user_dict = {
            'userId': user.user_id,
            'userName': user.user_name,
            'deptName': dept.dept_name  # 来自关联表
        }
        users.append(UserListVO(**user_dict))

    return users
```

---

## 模型 3：Query Model - 请求参数的约束

### 本质：前端请求的"类型定义"

**前端代码**：
```typescript
// 前端发送请求
axios.post('/api/user/list', {
  userName: 'admin',
  status: '0',
  pageNum: 1,
  pageSize: 10
})
```

**后端接收**：
```python
# module_admin/entity/query/user_query.py
from pydantic import BaseModel, Field

class UserQuery(BaseModel):
    userName: Optional[str] = Field(default=None, max_length=30)
    status: Optional[str] = Field(default='0')
    pageNum: int = Field(default=1, ge=1)
    pageSize: int = Field(default=10, ge=1, le=100)

# 使用
@app.post("/users/list")
async def get_user_list(query: UserQuery):
    # query.userName 已经验证过
    # query.pageNum 已经是整数
    # query.pageSize 已经限制范围

    # 直接使用，无需再验证
    users = await user_service.get_list(
        user_name=query.userName,
        status=query.status,
        page_num=query.pageNum,
        page_size=query.pageSize
    )
    return users
```

### Query Model 的核心作用

1. **自动验证**：前端传错参数会自动报错
2. **类型转换**：字符串 → 整数等自动转换
3. **默认值**：自动填充默认值
4. **文档生成**：自动生成 Swagger 文档

**前端类比**：
```typescript
// 前端用 TypeScript 接口做同样的事
interface UserQuery {
  userName?: string
  status?: string
  pageNum: number
  pageSize: number
}

const query: UserQuery = {
  pageNum: 1,
  pageSize: 10
}
// TypeScript 会检查类型
```

---

## 三种模型的协作

### 完整的数据流

```
前端请求                          后端处理
─────────────────────────────────────────────────────────────
POST /api/user/list               1. Query Model 验证
{ userName: 'admin' }              ↓
                                  ↓ UserQuery(userName='admin')
                                  ↓
                                  2. Service 查询
                                  ↓ user_do = SysUser(...)
                                  ↓
                                  3. 转换为 VO
                                  ↓ user_vo = UserVO.from_orm(user_do)
                                  ↓
                                  4. 返回响应
                                  ↓ { userId: 1, userName: 'admin' }
                                  ↓
前端接收                           ← JSON（自动序列化）
{ userId: 1, userName: 'admin' }
```

### 代码示例

```python
# 1. Query Model - 接收请求
class UserQuery(BaseModel):
    userName: Optional[str] = None
    pageNum: int = 1
    pageSize: int = 10

# 2. DO - 数据库操作
class SysUser(Base):
    __tablename__ = 'sys_user'
    user_id = Column(Integer, primary_key=True)
    user_name = Column(String(30))

# 3. VO - 返回响应
class UserVO(BaseModel):
    userId: int
    userName: str
    class Config:
        from_attributes = True

# Controller
@app.post("/users/list")
async def get_user_list(
    query: UserQuery,  # ← Query Model
    query_db: AsyncSession = Depends(get_db)
):
    # 查询数据库，返回 DO
    user_do_list = await user_service.get_list(
        query_db, query.userName, query.pageNum, query.pageSize
    )

    # 转换为 VO
    user_vo_list = [
        UserVO.model_validate(user) for user in user_do_list
    ]

    # 返回 VO
    return {"rows": user_vo_list, "total": len(user_vo_list)}
```

---

## 项目中的实际应用

### 用户列表接口

```python
# module_admin/controller/user_controller.py

@userController.post("/list")
async def get_user_list(
    query_user: UserModel,  # ← Query Model
    query_db: AsyncSession = Depends(get_db)
):
    # 1. 获取查询参数（已验证）
    user_name = query_user.userName
    status = query_user.status

    # 2. 调用 Service 查询（返回 DO）
    user_list = await user_service.get_user_list(
        query_db, user_name, status
    )

    # 3. 转换为 VO
    user_vo_list = [UserVO.model_validate(user) for user in user_list]

    # 4. 返回统一格式
    return Resp.success(data=user_vo_list)
```

### 用户详情接口

```python
@userController.get("/{user_id}")
async def get_user_detail(
    user_id: int,  # ← 路径参数
    query_db: AsyncSession = Depends(get_db)
):
    # 1. 查询 DO
    user_do = await user_service.get_user_by_id(query_db, user_id)

    # 2. 检查是否存在
    if not user_do:
        raise BusinessException("用户不存在")

    # 3. 转换为 VO（脱敏）
    user_vo = UserDetailVO.model_validate(user_do)

    # 4. 返回
    return Resp.success(data=user_vo)
```

---

## 核心概念：类型系统的价值

### 前端：TypeScript 的价值

```typescript
// 没有类型
function getUser(id) {
  return { id, name: 'admin' }
}
const user = getUser(1)
console.log(user.nam)  // 拼写错误，运行时才发现

// 有类型
interface User { id: number; name: string }
function getUser(id: number): User { ... }
const user = getUser(1)
console.log(user.nam)  // 编译时就报错
```

### 后端：Pydantic 的价值

```python
# 没有类型验证
@app.post("/users")
async def create_user(data: dict):
    name = data.get('name')
    # name 可能是 None、可能是数字、可能是字符串
    # 需要手动检查

# 有类型验证
class UserModel(BaseModel):
    name: str = Field(min_length=3, max_length=30)

@app.post("/users")
async def create_user(user: UserModel):
    # user.name 一定是字符串，长度 3-30
    # Pydantic 自动验证，失败自动返回 400 错误
```

### 本质理解

**类型系统的核心价值**：
1. **提前发现错误**：编译时/验证时发现，而非运行时
2. **代码即文档**：看到模型就知道数据结构
3. **IDE 支持**：智能提示、自动补全
4. **重构安全**：改了模型，用的地方都会报错

---

## 实战：从零创建一个接口

### 需求：创建"部门列表"接口

#### 第 1 步：定义 Query Model

```python
# module_admin/entity/query/dept_query.py
from pydantic import BaseModel, Field
from typing import Optional

class DeptQuery(BaseModel):
    deptName: Optional[str] = Field(default=None, description="部门名称")
    status: Optional[str] = Field(default='0', description="状态")

    class Config:
        # 允许驼峰命名自动转换
        populate_by_name = True
```

#### 第 2 步：定义 DO（如果已有可跳过）

```python
# module_admin/entity/do/dept_do.py
class SysDept(Base):
    __tablename__ = 'sys_dept'
    dept_id = Column(Integer, primary_key=True)
    dept_name = Column(String(30))
    parent_id = Column(Integer)
    status = Column(String(1))
```

#### 第 3 步：定义 VO

```python
# module_admin/entity/vo/dept_vo.py
class DeptVO(BaseModel):
    deptId: int
    deptName: str
    parentId: int
    status: str

    class Config:
        from_attributes = True
        # 蛇形转驼峰
        alias_generator = to_camel_case
        populate_by_name = True
```

#### 第 4 步：实现 Service

```python
# module_admin/service/dept_service.py
@classmethod
async def get_dept_list(cls, db: AsyncSession, query: DeptQuery):
    result = await db.execute(
        select(SysDept)
        .where(SysDept.status == query.status)
        .where(
            SysDept.dept_name.like(f'%{query.deptName}%')
            if query.deptName else True
        )
    )
    return result.scalars().all()
```

#### 第 5 步：实现 Controller

```python
# module_admin/controller/dept_controller.py
@deptController.post("/list")
async def get_dept_list(
    query: DeptQuery,
    query_db: AsyncSession = Depends(get_db)
):
    dept_list = await dept_service.get_dept_list(query_db, query)
    dept_vo_list = [DeptVO.model_validate(d) for d in dept_list]
    return Resp.success(data=dept_vo_list)
```

---

## 本质总结

### 三种模型对比

| 维度 | DO (Entity) | VO | Query Model |
|------|-------------|-----|-------------|
| 作用 | 数据库映射 | API 返回 | API 请求 |
| 包含敏感信息 | ✓ | ✗ | - |
| 使用 Pydantic | ✗ | ✓ | ✓ |
| 使用 SQLAlchemy | ✓ | ✗ | ✗ |
| 命名风格 | 蛇形 | 驼峰 | 驼峰 |

### 数据流动

```
前端请求
  ↓
Query Model (验证参数)
  ↓
DO (查询数据库)
  ↓
VO (转换格式)
  ↓
前端响应
```

### 核心要点

1. **DO 用于数据库**：对应表结构
2. **VO 用于返回**：数据脱敏、格式转换
3. **Query Model 用于接收**：参数验证、类型转换

---

## 检查清单

理解了本节内容，你应该能回答：

- [ ] 为什么需要 DO、VO、Query Model 三种模型？
- [ ] ORM 的本质是什么？它解决了什么问题？
- [ ] 为什么不能直接返回 DO？
- [ ] Pydantic 和 TypeScript 的共同点是什么？
- [ ] 数据从数据库到前端的完整流动过程是什么？
- [ ] 如何创建一个新的 CRUD 接口？

**下一步**：学习 [接口设计：函数即路由](./03-接口设计-函数即路由.md)
