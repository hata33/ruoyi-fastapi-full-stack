# 数据建模思维

> 数据建模是后端开发的核心能力，决定了系统的可扩展性和性能。

## 什么是数据建模

数据建模是**对现实世界进行抽象**，用数据结构描述业务实体和它们之间的关系。

```
现实世界      →    抽象模型      →    数据库表
─────────────────────────────────────────────
用户、角色     →    User、Role   →    sys_user, sys_role
它们的关系     →    关联关系     →    sys_user_role
```

## 数据建模的三个层次

### 1. 概念模型

**目标**：理解业务需求，识别核心实体

```
问题域：员工管理系统
  ↓
核心实体：
- 员工（Employee）
- 部门（Department）
- 职位（Position）
- 薪资（Salary）
```

### 2. 逻辑模型

**目标**：定义实体属性和关系

```
Employee {
  id: 员工ID
  name: 姓名
  email: 邮箱
  dept_id: 所属部门ID (外键)
  position_id: 职位ID (外键)
}

Department {
  id: 部门ID
  name: 部门名称
  parent_id: 上级部门ID (自关联)
}

Relationship:
Employee ── belongs_to ──> Department
Employee ── holds ──> Position
```

### 3. 物理模型

**目标**：转换为具体的数据库表结构

```sql
CREATE TABLE sys_employee (
    employee_id INT PRIMARY KEY AUTO_INCREMENT,
    employee_name VARCHAR(30) NOT NULL,
    email VARCHAR(50),
    dept_id INT,
    position_id INT,
    status CHAR(1) DEFAULT '0',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (dept_id) REFERENCES sys_dept(dept_id),
    FOREIGN KEY (position_id) REFERENCES sys_position(position_id),
    INDEX idx_dept (dept_id)
);
```

---

## 核心设计原则

### 1. 范式理论

**第一范式 (1NF)**：每个字段都是不可分的

```
❌ 不符合 1NF
员工表: 张三 | 13800138000,13900139000

✅ 符合 1NF
员工表 + 电话表
员工: 张三
电话: 13800138000, 13900139000 (分别存储)
```

**第二范式 (2NF)**：消除部分依赖

```
❌ 不符合 2NF
订单明细表: (订单ID, 商品ID, 商品名称, 数量)
# 商品名称只依赖于商品ID，不依赖于(订单ID, 商品ID)

✅ 符合 2NF
订单明细表: (订单ID, 商品ID, 数量)
商品表: (商品ID, 商品名称)
```

**第三范式 (3NF)**：消除传递依赖

```
❌ 不符合 3NF
订单表: (订单ID, 用户ID, 用户姓名)
# 用户姓名通过 用户ID → 用户姓名 传递依赖

✅ 符合 3NF
订单表: (订单ID, 用户ID)
用户表: (用户ID, 用户姓名)
```

### 2. 实际应用中的权衡

```
理论完美 vs 实际性能

完全遵循范式：
✅ 数据一致性好
✅ 更新异常少
❌ 查询需要多次 JOIN

适当反范式化：
✅ 查询性能好
✅ 减少表关联
❌ 需要维护数据一致性
```

**项目示例**：

```python
# sys_user 表中同时存储了 dept_id
# 如果要获取部门名称，需要 JOIN sys_dept

# 如果查询频繁且性能敏感，可以考虑冗余字段
class SysUser(Base):
    user_id: int
    dept_id: int  # 外键
    dept_name: str = None  # 冗余字段，提高查询性能
```

---

## 关系设计

### 一对一 (1:1)

```
用户 ─── 身份证
1 : 1

# 方案1：单表
CREATE TABLE sys_user (
    user_id INT PRIMARY KEY,
    user_name VARCHAR(30),
    id_card_no VARCHAR(18)  -- 直接存储
);

# 方案2：分离表
CREATE TABLE sys_user (
    user_id INT PRIMARY KEY,
    user_name VARCHAR(30),
    id_card_id INT UNIQUE,
    FOREIGN KEY (id_card_id) REFERENCES sys_id_card(id_card_id)
);
```

### 一对多 (1:N)

```
部门 ─── 用户
1 : N

CREATE TABLE sys_user (
    user_id INT PRIMARY KEY,
    user_name VARCHAR(30),
    dept_id INT,  -- 外键
    FOREIGN KEY (dept_id) REFERENCES sys_dept(dept_id)
);

-- 查询某部门的所有用户
SELECT * FROM sys_user WHERE dept_id = 1;
```

### 多对多 (M:N)

```
用户 ──── 角色
M : N

-- 需要中间表
CREATE TABLE sys_user_role (
    user_id INT,
    role_id INT,
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES sys_user(user_id),
    FOREIGN KEY (role_id) REFERENCES sys_role(role_id)
);

-- 查询用户的角色
SELECT r.*
FROM sys_role r
JOIN sys_user_role ur ON r.role_id = ur.role_id
WHERE ur.user_id = 1;
```

### 自关联（树形结构）

```
部门树
├── 总公司
│   ├── 研发部
│   │   ├── 后端组
│   │   └── 前端组
│   └── 市场部

CREATE TABLE sys_dept (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(30),
    parent_id INT,  -- 指向父级部门
    FOREIGN KEY (parent_id) REFERENCES sys_dept(dept_id)
);

-- 查询子部门
SELECT * FROM sys_dept WHERE parent_id = 1;

-- 递归查询所有下级部门（MySQL 8.0+）
WITH RECURSIVE dept_tree AS (
    SELECT * FROM sys_dept WHERE dept_id = 1
    UNION ALL
    SELECT d.* FROM sys_dept d
    JOIN dept_tree t ON d.parent_id = t.dept_id
)
SELECT * FROM dept_tree;
```

---

## 字段设计

### 命名规范

| 规范 | 示例 | 说明 |
|------|------|------|
| 小写+下划线 | `user_name` | 避免大小写问题 |
| 有意义 | `create_time` | 不用 `t1`, `field1` |
| 表名前缀 | `sys_user_name` | 多表 JOIN 时避免冲突 |
| 布尔值用 is | `is_deleted` | 清晰表达语义 |
| 时间后缀 | `create_time`, `update_time` | 统一时间命名 |

### 类型选择

```python
# 整数
id: int = Field(Integer, comment="ID")          # 普通整数
count: int = Field(SmallInteger, comment="计数") # 小整数，节省空间

# 字符串
code: str = Field(String(32), comment="编码")    # 固定长度
name: str = Field(String(100), comment="名称")   # 可变长度
content: str = Field(Text, comment="内容")       # 长文本

# 时间
create_time: datetime = Field(DateTime, comment="创建时间")

# 金额
amount: decimal = Field(Numeric(10, 2), comment="金额")  # 精确小数

# 布尔
is_enabled: bool = Field(Boolean, comment="是否启用")
```

### 约束设计

```python
class SysUser(Base):
    __tablename__ = 'sys_user'

    # 主键约束
    user_id = Column(Integer, primary_key=True, autoincrement=True)

    # 非空约束
    user_name = Column(String(30), nullable=False)

    # 唯一约束
    email = Column(String(50), unique=True)

    # 默认值
    status = Column(String(1), default='0')

    # 检查约束
    @validates('status')
    def validate_status(self, key, value):
        if value not in ['0', '1', '2']:
            raise ValueError('status must be 0, 1, or 2')
        return value

    # 外键约束
    dept_id = Column(Integer, ForeignKey('sys_dept.dept_id'))
```

### 标准字段

```python
class BaseEntity(Base):
    """所有表的基类"""
    __abstract__ = True

    # 主键
    id = Column(Integer, primary_key=True, autoincrement=True)

    # 状态字段
    status = Column(String(1), default='0', comment='状态')
    del_flag = Column(String(1), default='0', comment='删除标志')

    # 审计字段
    create_by = Column(String(64), default='system', comment='创建者')
    create_time = Column(DateTime, default=datetime.now, comment='创建时间')
    update_by = Column(String(64), comment='更新者')
    update_time = Column(DateTime, onupdate=datetime.now, comment='更新时间')
    remark = Column(String(500), comment='备注')
```

---

## 索引设计

### 何时需要索引

```python
# ✅ 需要索引
WHERE user_name = 'admin'           # 频繁查询条件
ORDER BY create_time DESC           # 排序字段
JOIN dept_id = sys_dept.dept_id     # 关联字段

# ❌ 不需要索引
WHERE status = '0'                   # 区分度低（大部分数据都是0）
LIKE '%keyword%'                     # 模糊查询前缀
```

### 索引类型

```python
# 单列索引
user_name = Column(String(30), index=True)

# 组合索引（注意顺序）
__table_args__ = (
    Index('idx_user_search', 'dept_id', 'status', 'del_flag'),
)
# 查询时遵循最左前缀原则：
# ✅ WHERE dept_id = 1
# ✅ WHERE dept_id = 1 AND status = '0'
# ❌ WHERE status = '0'  # 不会使用索引

# 唯一索引
__table_args__ = (
    UniqueConstraint('user_name', name='uq_user_name'),
)
```

### 项目中的索引示例

```python
# module_admin/entity/do/user_do.py
class SysUser(Base):
    __tablename__ = 'sys_user'
    __table_args__ = (
        # 登录查询优化：用户名+状态+删除标志
        Index('idx_user_login', 'user_name', 'status', 'del_flag'),

        # 部门查询优化
        Index('idx_user_dept', 'dept_id', 'del_flag'),

        # 唯一约束：用户名唯一
        UniqueConstraint('user_name', name='uq_user_name'),

        # 唯一约束：邮箱唯一
        UniqueConstraint('email', name='uq_user_email'),
    )
```

---

## 数据建模实战

### 场景：订单系统

**需求**：
1. 用户可以下单购买商品
2. 一个订单包含多个商品
3. 订单有状态流转
4. 需要记录库存变化

**步骤 1：识别实体**

```
核心实体：
- User (用户)
- Product (商品)
- Order (订单)
- OrderItem (订单明细)
- Inventory (库存)
- OrderLog (订单日志)
```

**步骤 2：设计关系**

```
User ── 1:N ── Order ── 1:N ── OrderItem
Product ── 1:N ── OrderItem
Product ── 1:1 ── Inventory
Order ── 1:N ── OrderLog
```

**步骤 3：设计表结构**

```sql
-- 订单表
CREATE TABLE tb_order (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(32) UNIQUE NOT NULL,
    user_id INT NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    remark VARCHAR(500),
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES sys_user(user_id),
    INDEX idx_user (user_id),
    INDEX idx_status (status),
    INDEX idx_create_time (create_time)
);

-- 订单明细表
CREATE TABLE tb_order_item (
    item_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id BIGINT NOT NULL,
    product_id INT NOT NULL,
    product_name VARCHAR(100) NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES tb_order(order_id),
    FOREIGN KEY (product_id) REFERENCES tb_product(product_id),
    INDEX idx_order (order_id)
);
```

---

## 常见错误

### 1. 过度范式化

```
❌ 为了范式，创建太多表
每个属性都拆分成单独的表

✅ 适度冗余，提高查询性能
在用户表中存储 dept_name，减少 JOIN
```

### 2. 忽略查询模式

```
❌ 只考虑存储，不考虑查询
设计表结构时没有想清楚怎么查询

✅ 查询驱动设计
先想清楚查询需求，再设计表结构
```

### 3. 缺少审计字段

```
❌ 没有创建时间、更新时间
无法追踪数据变化

✅ 添加标准审计字段
create_by, create_time, update_by, update_time
```

### 4. 忽略软删除

```
❌ 直接物理删除数据
DELETE FROM sys_user WHERE user_id = 1
# 数据无法恢复

✅ 使用软删除
UPDATE sys_user SET del_flag = '1' WHERE user_id = 1
```

---

## 检查清单

设计数据库时，请检查：

- [ ] 表名和字段名符合规范
- [ ] 主键设计合理
- [ ] 外键关系正确
- [ ] 必要的字段有非空约束
- [ ] 唯一字段有唯一约束
- [ ] 频繁查询的字段有索引
- [ ] 包含审计字段
- [ ] 使用软删除而非物理删除
- [ ] 考虑了数据增长趋势
- [ ] 考虑了查询性能需求

**下一步**: 学习 [接口设计思维](./02-接口设计思维.md)
