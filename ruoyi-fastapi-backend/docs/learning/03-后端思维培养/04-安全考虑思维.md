# 安全考虑思维

> 安全是后端开发的生命线，需要贯穿整个开发流程。

## 安全第一原则

```
┌─────────────────────────────────┐
│   永远不要信任用户输入           │
│   永远不要信任客户端             │
│   永远不要假设一切正常           │
└─────────────────────────────────┘
```

---

## 1. 输入验证

### 白名单 vs 黑名单

```python
# ❌ 黑名单：过滤已知的危险输入
dangerous_chars = ["<script>", "onerror=", "javascript:"]
def sanitize(input):
    for char in dangerous_chars:
        input = input.replace(char, "")
    return input
# 问题：总有漏网之鱼

# ✅ 白名单：只允许已知的合法输入
import re

def validate_username(username):
    # 只允许字母、数字、下划线，3-30位
    if not re.match(r'^[a-zA-Z0-9_]{3,30}$', username):
        raise ValueError("用户名格式错误")
    return username
```

### Pydantic 验证

```python
from pydantic import BaseModel, Field, validator

class UserModel(BaseModel):
    user_name: str = Field(
        ...,
        min_length=3,
        max_length=30,
        regex=r'^[a-zA-Z0-9_]+$'
    )
    email: str = Field(..., regex=r'^[^@]+@[^@]+\.[^@]+$')
    password: str = Field(..., min_length=8)

    @validator('password')
    def validate_password(cls, v):
        # 至少包含数字和字母
        if not any(c.isdigit() for c in v):
            raise ValueError('密码必须包含数字')
        if not any(c.isalpha() for c in v):
            raise ValueError('密码必须包含字母')
        return v

# 使用时会自动验证
user = UserModel(
    user_name="admin",  # ✅ 合法
    # user_name="a@dmin",  # ❌ 抛出异常
    email="admin@example.com",
    password="Pass123"
)
```

### SQL 注入防护

```python
# ❌ 危险：字符串拼接
async def get_user(username: str):
    # 攻击输入：username = "admin' OR '1'='1"
    sql = f"SELECT * FROM users WHERE username = '{username}'"
    # 实际执行：SELECT * FROM users WHERE username = 'admin' OR '1'='1'
    return await db.execute(sql)

# ✅ 安全：参数化查询
async def get_user(username: str):
    stmt = select(SysUser).where(SysUser.user_name == username)
    return await db.execute(stmt)
```

---

## 2. 认证与授权

### 密码存储

```python
# ❌ 明文存储
password = "admin123"
# 存储到数据库：admin123  # 危险！

# ❌ 可逆加密
from cryptography.fernet import Fernet
password = Fernet(key).encrypt(b"admin123")
# 问题：密钥泄露后，所有密码暴露

# ✅ 单向哈希（bcrypt）
import bcrypt

# 哈希密码
hashed = bcrypt.hashpw(b"admin123", bcrypt.gensalt())
# 存储到数据库：$2b$12$EixZaYVK...

# 验证密码
if bcrypt.checkpw(b"admin123", hashed):
    print("密码正确")
```

### JWT 安全

```python
# ❌ 危险做法
token = jwt.encode(
    {"user_id": 1, "password": "admin123"},  # 包含敏感信息
    "secret",  # 弱密钥
    algorithm="HS256"
)

# ✅ 安全做法
token = jwt.encode(
    {
        "user_id": str(user.user_id),
        "user_name": user.user_name,
        "session_id": str(uuid.uuid4()),  # 支持单点登录
        "exp": datetime.now() + timedelta(minutes=30)  # 过期时间
    },
    JwtConfig.jwt_secret_key,  # 强密钥（从环境变量读取）
    algorithm=JwtConfig.jwt_algorithm
)

# 密钥管理
# 从环境变量读取，不硬编码
import os
SECRET_KEY = os.getenv("JWT_SECRET_KEY")
if not SECRET_KEY or len(SECRET_KEY) < 32:
    raise ValueError("JWT secret key must be at least 32 characters")
```

### Token 刷新

```python
# 访问 Token（短期）
access_token = create_access_token(
    data={"user_id": 1},
    expires_delta=timedelta(minutes=30)
)

# 刷新 Token（长期）
refresh_token = create_refresh_token(
    data={"user_id": 1},
    expires_delta=timedelta(days=7)
)

# Token 过期后使用刷新 Token 获取新的访问 Token
@app.post("/refresh")
async def refresh_token(refresh_token: str):
    payload = jwt.decode(refresh_token, SECRET_KEY)
    new_access_token = create_access_token(
        data={"user_id": payload["user_id"]}
    )
    return {"access_token": new_access_token}
```

---

## 3. 权限控制

### 接口权限

```python
# ❌ 不安全：前端隐藏按钮
# <button v-if="hasPermission" @click="deleteUser">删除</button>
# 问题：用户可以直接调用 API

# ✅ 安全：后端验证权限
@userController.delete("/{user_id}")
async def delete_user(
    user_id: int,
    _: bool = Depends(CheckUserInterfaceAuth("system:user:remove"))
):
    # 即使前端没有按钮，直接调用接口也会被拦截
    pass
```

### 数据权限

```python
# ❌ 不安全：所有人看到所有数据
@userController.get("/list")
async def get_user_list():
    return await db.execute(select(SysUser))

# ✅ 安全：根据角色返回不同数据
@userController.get("/list")
async def get_user_list(
    current_user: CurrentUserService = Depends(),
    data_scope: str = Depends(GetDataScope())
):
    # data_scope 是根据用户权限生成的 SQL 条件
    # 管理员：1 == 1（全部数据）
    # 普通用户：dept_id IN (1, 2, 3)（本部门数据）
    stmt = select(SysUser).where(eval(data_scope))
    return await db.execute(stmt)
```

### 水平越权防护

```python
# ❌ 水平越位漏洞
@userController.get("/{user_id}")
async def get_user(user_id: int, current_user: CurrentUserService = Depends()):
    # 用户 A 可以修改 user_id=1 的数据
    # 即使 user_id=1 是用户 B 的数据
    return await get_user_by_id(user_id)

# ✅ 验证数据归属
@userController.get("/{user_id}")
async def get_user(user_id: int, current_user: CurrentUserService = Depends()):
    user = await get_user_by_id(user_id)

    # 验证是否有权访问
    if not current_user.is_admin and user.user_id != current_user.user_id:
        raise PermissionException("无权访问")

    return user
```

---

## 4. 数据保护

### 敏感数据加密

```python
from cryptography.fernet import Fernet

# 加密密钥（从环境变量读取）
ENCRYPTION_KEY = os.getenv("ENCRYPTION_KEY")
cipher = Fernet(ENCRYPTION_KEY)

# 加密存储
def encrypt_sensitive_data(data: str) -> str:
    return cipher.encrypt(data.encode()).decode()

# 解密读取
def decrypt_sensitive_data(encrypted_data: str) -> str:
    return cipher.decrypt(encrypted_data.encode()).decode()

# 使用
class SysUser(Base):
    phone = Column(String(100))  # 加密存储
    id_card = Column(String(200))  # 加密存储

# 保存时加密
user.phone = encrypt_sensitive_data("13800138000")

# 读取时解密
phone = decrypt_sensitive_data(user.phone)
```

### 日志脱敏

```python
import re

def mask_sensitive_data(text: str) -> str:
    """脱敏敏感数据"""
    # 手机号
    text = re.sub(r'(\d{3})\d{4}(\d{4})', r'\1****\2', text)
    # 身份证
    text = re.sub(r'(\d{6})\d{8}(\d{4})', r'\1********\2', text)
    # 邮箱
    text = re.sub(r'([^@]+)@(.+)', lambda m: m.group(1)[0] + '***@' + m.group(2), text)
    return text

# 日志输出
logger.info(f"用户登录: {mask_sensitive_data('user:张三,phone:13800138000')}")
# 输出：用户登录: user:张三,phone:138****8000
```

### HTTPS 传输

```python
# 生产环境必须使用 HTTPS

# 开发环境可以配置
if AppConfig.app_env == "production":
    if not request.url.scheme == "https":
        raise HTTPException(status_code=400, detail="必须使用 HTTPS")

# 强制 HTTPS
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware
app.add_middleware(HTTPSRedirectMiddleware)
```

---

## 5. 防护措施

### 防暴力破解

```python
# 项目中的实现
async def check_login_attempts(request: Request, username: str):
    # 1. 检查 IP 黑名单
    ip = get_client_ip(request)
    if await redis.get(f"blacklist:{ip}"):
        raise LoginException("IP已被封禁")

    # 2. 检查账号锁定
    if await redis.get(f"account_lock:{username}"):
        raise LoginException("账号已锁定")

    # 3. 检查密码错误次数
    error_count = await redis.get(f"password_error:{username}")
    if error_count and int(error_count) >= 5:
        # 锁定账号 10 分钟
        await redis.setex(f"account_lock:{username}", 600, username)
        raise LoginException("密码错误次数过多，账号已锁定10分钟")

# 登录失败时
await redis.incr(f"password_error:{username}")
await redis.expire(f"password_error:{username}", 600)

# 登录成功时
await redis.delete(f"password_error:{username}")
```

### 防 XSS 攻击

```python
from markupsafe import escape

# ❌ 危险：直接输出用户输入
def render_comment(comment: str):
    return f"<div>{comment}</div>"
# 输入：<script>alert('XSS')</script>
# 输出：<div><script>alert('XSS')</script></div>

# ✅ 安全：转义输出
def render_comment(comment: str):
    return f"<div>{escape(comment)}</div>"
# 输入：<script>alert('XSS')</script>
# 输出：<div>&lt;script&gt;alert('XSS')&lt;/script&gt;</div>
```

### 防 CSRF 攻击

```python
# FastAPI 的 OAuth2 流程自带 CSRF 防护

from fastapi.security import OAuth2PasswordBearer

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/login")

# 使用 CSRF Token
@app.post("/api/form")
async def handle_form(
    csrf_token: str = Form(...),
    request: Request
):
    # 验证 CSRF Token
    if csrf_token != request.session.get("csrf_token"):
        raise HTTPException(status_code=403, detail="CSRF token 验证失败")
    pass
```

### 限流

```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@app.post("/api/login")
@limiter.limit("5/minute")  # 每分钟最多5次
async def login(request: Request):
    pass
```

---

## 6. 安全审计

### 日志记录

```python
# 记录关键操作
@Log(title='用户登录', business_type=BusinessType.OTHER)
async def login(request: Request, ...):
    # 自动记录：
    # - 操作人
    # - 操作时间
    # - 操作 IP
    # - 操作结果
    pass

# 敏感操作审计
async def change_password(user_id: int, old_pwd: str, new_pwd: str):
    # 记录密码修改日志
    await log_security_event(
        event_type="password_change",
        user_id=user_id,
        ip=get_client_ip(),
        success=result.success
    )
```

### 安全检查清单

发布前检查：

- [ ] 所有用户输入都经过验证
- [ ] 密码使用 bcrypt 哈希
- [ ] 敏感数据加密存储
- [ ] 接口都有权限检查
- [ ] 防止 SQL 注入
- [ ] 防止 XSS 攻击
- [ ] 防止 CSRF 攻击
- [ ] 实现了防暴力破解
- [ ] 实现了限流
- [ ] 记录了安全日志
- [ ] 使用 HTTPS
- [ ] Token 有过期时间
- [ ] 错误信息不泄露敏感信息

---

## 安全原则

1. **最小权限原则**
```
只授予必要的权限，默认拒绝

✅ 用户只能访问自己的数据
✅ 接口默认需要认证
❌ 所有接口都公开访问
```

2. **纵深防御**
```
多层防护，不依赖单一措施

认证 → 授权 → 数据权限 → 审计
```

3. **永不信任客户端**
```
所有验证都在服务端进行

❌ 前端验证即可
✅ 前端验证 + 后端验证
```

4. **安全左移**
```
在开发阶段就考虑安全，而不是事后补救

需求分析 → 设计 → 开发 → 测试 → 部署
    ↓       ↓     ↓      ↓      ↓
   安全   安全   安全   安全   安全
```

**下一步**: 学习 [可维护性思维](./05-可维护性思维.md)
