# 前端后端对照

> 本文档帮助前端开发者快速理解后端概念，通过前后端对比学习后端开发。

## 概念对照总览

```mermaid
flowchart TB
    subgraph 前端概念[前端概念]
        direction TB
        FE1[Vue Router<br/>路由映射]
        FE2[React Hooks<br/>状态管理]
        FE3[Promise<br/>异步处理]
        FE4[TypeScript<br/>类型系统]
        FE5[Axios<br/>HTTP请求]
        FE6[Vuex/Pinia<br/>状态管理]
    end

    subgraph 后端概念[后端概念]
        direction TB
        BE1[FastAPI Router<br/>路由装饰器]
        BE2[Depends<br/>依赖注入]
        BE3[async/await<br/>异步编程]
        BE4[Pydantic<br/>数据验证]
        BE5[HTTP Methods<br/>RESTful接口]
        BE6[Database<br/>数据持久化]
    end

    subgraph 连接理解[连接理解]
        C1[URL → 函数]
        C2[依赖管理]
        C3[并发处理]
        C4[类型安全]
        C5[请求响应]
        C6[状态存储]
    end

    FE1 --> C1 --> BE1
    FE2 --> C2 --> BE2
    FE3 --> C3 --> BE3
    FE4 --> C4 --> BE4
    FE5 --> C5 --> BE5
    FE6 --> C6 --> BE6

    ```

## 详细对照表

### 1. 路由对照

| 前端 (Vue Router) | 后端 (FastAPI) | 说明 |
|------------------|----------------|------|
| `/users/:id` 路径定义 | `@app.get("/users/{user_id}")` | 都是 URL 路径到处理函数的映射 |
| `useRoute()` 获取路由 | `user_id: int` 路径参数 | 获取 URL 中的参数 |
| `query` 查询参数 | `?page=1&size=10` 查询参数 | URL 问号后的参数 |
| 路由守卫 `beforeEnter` | 依赖注入 `Depends` | 在路由处理前执行逻辑 |
| 嵌套路由 `children` | APIRouter 路由分组 | 组织多个相关路由 |

### 2. 状态管理对照

| 前端 (Hooks) | 后端 (Depends) | 说明 |
|-------------|----------------|------|
| `useState` 状态 | 数据库会话 `db: Session = Depends(get_db)` | 管理可变的状态 |
| `useEffect` 副作用 | 依赖注入的执行逻辑 | 在特定时机执行代码 |
| `useContext` 上下文 | 全局依赖 | 跨组件/路由共享状态 |
| 自定义 Hook | 可复用的依赖函数 | 封装可复用逻辑 |
| Hook 依赖数组 | 依赖链 | 控制执行顺序和依赖关系 |

### 3. 异步处理对照

| 前端 (Promise) | 后端 (async/await) | 说明 |
|---------------|-------------------|------|
| `fetch().then()` | `await db.query()` | 等待异步操作完成 |
| `Promise.all()` | `asyncio.gather()` | 并发执行多个异步操作 |
| `async/await` | `async/await` | 语法相同，用法类似 |
| 错误处理 `.catch()` | `try/except` | 异步操作的错误处理 |
| 并发限制 | 连接池 | 控制并发数量 |

### 4. 类型系统对照

| 前端 (TypeScript) | 后端 (Pydantic) | 说明 |
|-------------------|-----------------|------|
| `interface User` | `class User(BaseModel)` | 定义数据结构 |
| `: string` 类型注解 | `: str` 类型注解 | 声明变量类型 |
| 类型检查 | 数据验证 | 运行时验证数据 |
| `?:` 可选 | `: Optional[str]` | 可选字段 |
| 泛型 `` | 泛型 `TypeVar` | 通用类型定义 |

### 5. HTTP 请求对照

| 前端 (Axios) | 后端 (HTTP Methods) | 说明 |
|-------------|---------------------|------|
| `axios.get()` | `@app.get()` | 获取资源 |
| `axios.post()` | `@app.post()` | 创建资源 |
| `axios.put()` | `@app.put()` | 完整更新资源 |
| `axios.patch()` | `@app.patch()` | 部分更新资源 |
| `axios.delete()` | `@app.delete()` | 删除资源 |
| `axios.interceptors` | 中间件 | 请求/响应拦截处理 |

### 6. 数据存储对照

| 前端 (Pinia/Vuex) | 后端 (Database) | 说明 |
|------------------|-----------------|------|
| Store 状态 | Database 数据库 | 持久化存储 |
| State 状态 | Table 行/记录 | 数据单元 |
| Getter 计算属性 | Query 查询 | 派生数据 |
| Action 同步/异步 | Transaction 事务 | 数据操作 |
| Module 模块 | Table/Schema 表结构 | 数据组织 |

## 场景对照

### 场景 1：用户登录

```mermaid
sequenceDiagram
    participant 前端 as 前端
    participant 后端 as 后端

    前端->>后端: POST /api/login<br/>{ username, password }
    Note over 前端: axios.post()

    后端->>后端: 验证参数<br/>(Pydantic)
    Note over 后端: 类似前端 TS 类型检查

    后端->>后端: 查询数据库<br/>(SQLAlchemy)
    Note over 后端: 类似前端 Pinia 读取状态

    后端->>后端: 验证密码<br/>(bcrypt)
    Note over 后端: 安全对比

    后端->>后端: 生成 Token<br/>(JWT)
    Note over 后端: 类似前端生成会话ID

    后端->>前端: { code, msg, data: { token } }
    Note over 后端: 统一响应格式

    前端->>前端: 存储 Token<br/>(localStorage)
    Note over 前端: 类似后端 Session 存储
```

### 场景 2：数据列表

| 步骤 | 前端操作 | 后端操作 |
|-----|---------|---------|
| 1 | 发起请求 `axios.get('/users?page=1')` | 接收路由 `@app.get("/users")` |
| 2 | 等待响应 `await` | 获取查询参数 `page: int = 1` |
| 3 | - | 验证参数 |
| 4 | - | 查询数据库 `db.query(User)` |
| 5 | - | 分页处理 `.offset().limit()` |
| 6 | 接收数据 `{ code, msg, rows, total }` | 返回响应 |
| 7 | 更新状态 `setState(data)` | - |
| 8 | 渲染列表 | - |

### 场景 3：错误处理

| 前端 | 后端 |
|-----|------|
| `try { await api() } catch(e) { showError(e) }` | `try: operation except Exception as e: raise HTTPException` |
| 用户看到错误提示 | 返回统一错误格式 `{ code: 500, msg: "..." }` |
| `.catch()` 捕获异常 | 异常处理中间件捕获 |
| 显示友好的错误信息 | 记录错误日志 |

## 关键差异理解

### 1. 运行环境

| 前端 | 后端 |
|-----|------|
| 浏览器中运行 | 服务器中运行 |
| 每个用户独立环境 | 共享的服务器环境 |
| 无状态（需要刷新恢复） | 有状态（数据库持久化） |
| 客户端渲染 | 服务端处理 |

### 2. 安全性

| 前端 | 后端 |
|-----|------|
| 代码可见，不能存储敏感信息 | 代码隐藏，可以处理敏感信息 |
| 本地存储不安全 | 服务器存储安全 |
| 验证只是用户体验 | 验证是安全必需 |
| 可以被绕过 | 必须严格验证 |

### 3. 性能关注点

| 前端 | 后端 |
|-----|------|
| 首屏加载时间 | 响应时间 |
| 渲染性能 | 并发处理能力 |
| 资源大小 | 数据库查询性能 |
| 用户体验 | 服务器资源使用 |

### 4. 调试方式

| 前端 | 后端 |
|-----|------|
| 浏览器 DevTools | 日志文件 |
| 控制台输出 | 断点调试 |
| Network 面板 | API 测试工具 |
| React/Vue DevTools | 数据库查询分析 |

## 学习建议

### 转换思路

| 方面 | 前端 | 后端 |
|-----|------|------|
| 角色 | 消费者 | 生产者 |
| 界面 | 用户界面 | 数据接口 |
| 环境 | 浏览器 | 服务器 |
| 关注点 | 用户体验 | 系统设计 |

### 利用前端经验

- **路由**：Vue Router → FastAPI 路由设计
- **异步**：Promise → async/await
- **类型**：TypeScript → Pydantic
- **状态**：Pinia → 数据库操作

### 学习要点

- 验证：前端是 UI 体验，后端是安全必需
- 数据：前端易失，后端持久
- 安全：前端可见，后端隐藏

## 快速参考

### 前端技能到后端映射

| 你已经会的 | 对应的后端技能 |
|-----------|---------------|
| Vue Router 路由 | FastAPI 路由设计 |
| React Hooks 状态管理 | Depends 依赖注入 |
| Promise 异步处理 | async/await 异步编程 |
| TypeScript 类型 | Pydantic 数据验证 |
| Axios HTTP 请求 | RESTful API 设计 |
| Pinia 状态存储 | Database 数据持久化 |

### 学习路径

```mermaid
flowchart LR
    Start([前端开发者]) --> Step1[阅读本文档<br/>建立概念映射]
    Step1 --> Step2[学习 FastAPI 基础<br/>对照 Vue Router]
    Step2 --> Step3[学习依赖注入<br/>对照 React Hooks]
    Step3 --> Step4[学习异步编程<br/>对照 Promise]
    Step4 --> Step5[学习数据验证<br/>对照 TypeScript]
    Step5 --> Step6[学习数据库操作<br/>对照 Pinia]

    ```

## 相关文档

- [05-前端开发者的后端入门](../05-前端开发者的后端入门) - 针对前端开发者的后端教程
- [01-学习路径规划.md](./01-学习路径规划.md) - 详细的学习路径
- [05-知识点依赖图.md](./05-知识点依赖图.md) - 学习前置知识
