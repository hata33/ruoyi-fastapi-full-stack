# è®¤è¯æˆæƒç³»ç»Ÿ

> ä¿æŠ¤è®°è´¦æ•°æ®å®‰å…¨ï¼Œå®ç°ç”¨æˆ·èº«ä»½è®¤è¯ä¸æƒé™æ§åˆ¶

## ğŸ“‹ æœ¬ç« ç›®æ ‡

- [ ] ç†è§£è®¤è¯ä¸æˆæƒçš„åŒºåˆ«
- [ ] å®ç° JWT è®¤è¯ç³»ç»Ÿ
- [ ] è®¾è®¡åŸºäºè§’è‰²çš„æƒé™æ§åˆ¶
- [ ] ä¿æŠ¤ API ç«¯ç‚¹å®‰å…¨

## ğŸ¯ è®¤è¯ vs æˆæƒ

### æ¦‚å¿µåŒºåˆ†

```mermaid
flowchart LR
    Request["è¯·æ±‚"] --> Authentication["è®¤è¯"]
    Authentication --> |"é€šè¿‡"| Authorization["æˆæƒ"]
    Authorization --> |"é€šè¿‡"| Resource["èµ„æºè®¿é—®"]

    subgraph AuthDetail["è®¤è¯ ä½ æ˜¯è°?"]
        A1["éªŒè¯èº«ä»½"]
        A2["ç™»å½•å¯†ç "]
        A3["ä»¤ç‰ŒéªŒè¯"]
    end

    subgraph AuthzDetail["æˆæƒ ä½ èƒ½åšä»€ä¹ˆ?"]
        B1["æ£€æŸ¥æƒé™"]
        B2["è§’è‰²æ£€æŸ¥"]
        B3["èµ„æºè®¿é—®æ§åˆ¶"]
    end

    Authentication -.è¯¦æƒ….-> AuthDetail
    Authorization -.è¯¦æƒ….-> AuthzDetail

    style Authentication fill:#e8f5e9
    style Authorization fill:#fff3e0
```

### è®¤è¯æµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant API as API
    participant Auth as è®¤è¯æœåŠ¡
    participant DB as æ•°æ®åº“

    User->>API: 1. ç™»å½•è¯·æ±‚ (username, password)
    API->>Auth: 2. éªŒè¯å‡­è¯
    Auth->>DB: 3. æŸ¥è¯¢ç”¨æˆ·
    DB-->>Auth: 4. ç”¨æˆ·ä¿¡æ¯
    Auth->>Auth: 5. éªŒè¯å¯†ç 
    Auth->>Auth: 6. ç”Ÿæˆ JWT
    Auth-->>API: 7. è¿”å› Token
    API-->>User: 8. Token å“åº”

    Note over User,DB: åç»­è¯·æ±‚

    User->>API: 9. è¯·æ±‚ + Token
    API->>Auth: 10. éªŒè¯ Token
    Auth-->>API: 11. ç”¨æˆ·ä¿¡æ¯
    API->>DB: 12. ä¸šåŠ¡æ“ä½œ
    DB-->>API: 13. è¿”å›æ•°æ®
    API-->>User: 14. å“åº”
```

## ğŸ” JWT è®¤è¯å®ç°

### JWT ç»“æ„

```mermaid
flowchart LR
    subgraph JWT["JWT ä»¤ç‰Œ"]
        Header["Header<br/>ç®—æ³•ä¿¡æ¯"]
        Payload["Payload<br/>ç”¨æˆ·æ•°æ®"]
        Signature["Signature<br/>ç­¾å"]
    end

    Header --> |"Base64"| H1["eyJhbGc..."]
    Payload --> |"Base64"| P1["eyJzdWI..."]
    Signature --> |"HMAC"| S1["SflKxw..."]

    H1 --> Token["å®Œæ•´ä»¤ç‰Œ"]
    P1 --> Token
    S1 --> Token

    style JWT fill:#e3f2fd
```

### é…ç½®ä¸å·¥å…·å‡½æ•°

```python
# core/security.py
from datetime import datetime, timedelta
from typing import Optional
from jose import jwt, JWTError
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel

# é…ç½®
SECRET_KEY = "your-secret-key-here"  # ç”Ÿäº§ç¯å¢ƒåº”ä»ç¯å¢ƒå˜é‡è¯»å–
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
REFRESH_TOKEN_EXPIRE_DAYS = 7

# å¯†ç å“ˆå¸Œ
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 æ–¹æ¡ˆ
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")

# Token æ•°æ®æ¨¡å‹
class TokenPayload(BaseModel):
    sub: int  # user_id
    exp: datetime
    type: str  # "access" or "refresh"

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

# å¯†ç å¤„ç†
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """éªŒè¯å¯†ç """
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """ç”Ÿæˆå¯†ç å“ˆå¸Œ"""
    return pwd_context.hash(password)

# JWT å¤„ç†
def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    """åˆ›å»ºè®¿é—®ä»¤ç‰Œ"""
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    payload = {
        "sub": user_id,
        "exp": expire,
        "type": "access"
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def create_refresh_token(user_id: int) -> str:
    """åˆ›å»ºåˆ·æ–°ä»¤ç‰Œ"""
    expire = datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    payload = {
        "sub": user_id,
        "exp": expire,
        "type": "refresh"
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def decode_token(token: str) -> Optional[TokenPayload]:
    """è§£ç ä»¤ç‰Œ"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return TokenPayload(**payload)
    except JWTError:
        return None
```

### è®¤è¯ä¾èµ–

```python
# dependencies/auth.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from typing import Optional

from core.security import oauth2_scheme, decode_token
from dependencies.database import get_db
from models.user import User

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    """è·å–å½“å‰ç”¨æˆ·ï¼ˆå¿…éœ€è®¤è¯ï¼‰"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="æ— æ³•éªŒè¯å‡­è¯",
        headers={"WWW-Authenticate": "Bearer"},
    )

    token_payload = decode_token(token)
    if token_payload is None:
        raise credentials_exception

    if token_payload.type != "access":
        raise credentials_exception

    user = db.get(User, token_payload.sub)
    if user is None:
        raise credentials_exception

    if not user.is_active:
        raise HTTPException(status_code=400, detail="ç”¨æˆ·å·²è¢«ç¦ç”¨")

    return user

async def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """è·å–å½“å‰æ´»è·ƒç”¨æˆ·"""
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="ç”¨æˆ·æœªæ¿€æ´»")
    return current_user

async def get_current_user_optional(
    token: Optional[str] = Depends(OAuth2PasswordBearer(auto_error=False)),
    db: Session = Depends(get_db)
) -> Optional[User]:
    """è·å–å½“å‰ç”¨æˆ·ï¼ˆå¯é€‰è®¤è¯ï¼‰"""
    if token is None:
        return None

    token_payload = decode_token(token)
    if token_payload is None:
        return None

    return db.get(User, token_payload.sub)
```

### è®¤è¯è·¯ç”±

```python
# routers/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import timedelta

from dependencies.database import get_db
from models.user import User
from schemas.user import UserCreate, UserResponse
from schemas.auth import LoginRequest, Token, RefreshTokenRequest
from core.security import (
    verify_password,
    get_password_hash,
    create_access_token,
    create_refresh_token,
    decode_token
)

router = APIRouter(prefix="/auth", tags=["è®¤è¯"])

@router.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def register(
    user_in: UserCreate,
    db: Session = Depends(get_db)
):
    """ç”¨æˆ·æ³¨å†Œ"""
    # æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å­˜åœ¨
    existing = db.query(User).filter(
        (User.username == user_in.username) | (User.email == user_in.email)
    ).first()

    if existing:
        if existing.username == user_in.username:
            raise HTTPException(400, "ç”¨æˆ·åå·²å­˜åœ¨")
        raise HTTPException(400, "é‚®ç®±å·²æ³¨å†Œ")

    # åˆ›å»ºç”¨æˆ·
    user = User(
        username=user_in.username,
        email=user_in.email,
        password_hash=get_password_hash(user_in.password)
    )
    db.add(user)
    db.commit()
    db.refresh(user)

    return user

@router.post("/login", response_model=Token)
def login(
    login_data: LoginRequest,
    db: Session = Depends(get_db)
):
    """
    ç”¨æˆ·ç™»å½•

    è¿”å›è®¿é—®ä»¤ç‰Œå’Œåˆ·æ–°ä»¤ç‰Œ
    """
    # æŸ¥æ‰¾ç”¨æˆ·
    user = db.query(User).filter(User.username == login_data.username).first()

    if not user or not verify_password(login_data.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯",
            headers={"WWW-Authenticate": "Bearer"},
        )

    if not user.is_active:
        raise HTTPException(400, "ç”¨æˆ·å·²è¢«ç¦ç”¨")

    # ç”Ÿæˆä»¤ç‰Œ
    access_token = create_access_token(user.id)
    refresh_token = create_refresh_token(user.id)

    return Token(
        access_token=access_token,
        refresh_token=refresh_token
    )

@router.post("/refresh", response_model=Token)
def refresh_token(
    refresh_data: RefreshTokenRequest,
    db: Session = Depends(get_db)
):
    """
    åˆ·æ–°ä»¤ç‰Œ

    ä½¿ç”¨åˆ·æ–°ä»¤ç‰Œè·å–æ–°çš„è®¿é—®ä»¤ç‰Œ
    """
    token_payload = decode_token(refresh_data.refresh_token)

    if token_payload is None or token_payload.type != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="æ— æ•ˆçš„åˆ·æ–°ä»¤ç‰Œ"
        )

    user = db.get(User, token_payload.sub)
    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ç”¨æˆ·ä¸å­˜åœ¨æˆ–å·²ç¦ç”¨"
        )

    # ç”Ÿæˆæ–°ä»¤ç‰Œ
    access_token = create_access_token(user.id)
    refresh_token = create_refresh_token(user.id)

    return Token(
        access_token=access_token,
        refresh_token=refresh_token
    )

@router.post("/logout")
def logout():
    """
    ç”¨æˆ·ç™»å‡º

    JWT æ— çŠ¶æ€ï¼ŒæœåŠ¡ç«¯ä¸ä¿å­˜ä¼šè¯
    å®¢æˆ·ç«¯éœ€è¦åˆ é™¤æœ¬åœ°å­˜å‚¨çš„ä»¤ç‰Œ
    """
    return {"message": "ç™»å‡ºæˆåŠŸ"}
```

## ğŸ›¡ï¸ è§’è‰²æƒé™æ§åˆ¶

### RBAC æ¨¡å‹è®¾è®¡

```mermaid
erDiagram
    USERS ||--o{ USER_ROLES : "æ‹¥æœ‰"
    ROLES ||--o{ USER_ROLES : "åˆ†é…ç»™"
    ROLES ||--o{ ROLE_PERMISSIONS : "æ‹¥æœ‰"
    PERMISSIONS ||--o{ ROLE_PERMISSIONS : "å±äº"

    USERS {
        int id PK
        string username
    }

    ROLES {
        int id PK
        string name
        string description
    }

    PERMISSIONS {
        int id PK
        string code
        string name
    }

    USER_ROLES {
        int user_id FK
        int role_id FK
    }

    ROLE_PERMISSIONS {
        int role_id FK
        int permission_id FK
    }
```

### æƒé™æ£€æŸ¥ä¾èµ–

```python
# dependencies/permission.py
from fastapi import Depends, HTTPException, status
from typing import List

from dependencies.auth import get_current_user
from models.user import User

def require_permissions(required_permissions: List[str]):
    """
    æƒé™æ£€æŸ¥ä¾èµ–å·¥å‚

    ç”¨æ³•:
    @app.get("/admin/users", dependencies=[Depends(require_permissions(["user:read"]))])
    """
    async def permission_checker(current_user: User = Depends(get_current_user)):
        # è¶…çº§ç”¨æˆ·æ‹¥æœ‰æ‰€æœ‰æƒé™
        if current_user.is_superuser:
            return current_user

        # è·å–ç”¨æˆ·æ‰€æœ‰æƒé™
        user_permissions = set()
        for role in current_user.roles:
            for permission in role.permissions:
                user_permissions.add(permission.code)

        # æ£€æŸ¥æ˜¯å¦æ‹¥æœ‰æ‰€éœ€æƒé™
        missing = set(required_permissions) - user_permissions
        if missing:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"ç¼ºå°‘æƒé™: {', '.join(missing)}"
            )

        return current_user

    return permission_checker

def require_roles(required_roles: List[str]):
    """è§’è‰²æ£€æŸ¥ä¾èµ–å·¥å‚"""
    async def role_checker(current_user: User = Depends(get_current_user)):
        if current_user.is_superuser:
            return current_user

        user_roles = {role.code for role in current_user.roles}

        if not set(required_roles) & user_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="æƒé™ä¸è¶³"
            )

        return current_user

    return role_checker
```

### èµ„æºæ‰€æœ‰æƒæ§åˆ¶

```mermaid
flowchart LR
    Request["API è¯·æ±‚"] --> Auth["è®¤è¯æ£€æŸ¥"]
    Auth --> |"é€šè¿‡"| Owner["æ‰€æœ‰æƒæ£€æŸ¥"]
    Auth --> |"å¤±è´¥"| Unauthorized["401"]

    Owner --> |"æ˜¯è‡ªå·±çš„"| Allow["å…è®¸è®¿é—®"]
    Owner --> |"æ˜¯ç®¡ç†å‘˜"| Allow
    Owner --> |"æ— æƒé™"| Forbidden["403"]

    style Allow fill:#c8e6c9
    style Unauthorized fill:#ffcdd2
    style Forbidden fill:#ffcdd2
```

```python
# dependencies/ownership.py
from fastapi import Depends, HTTPException, status
from sqlalchemy.orm import Session

from dependencies.auth import get_current_user
from dependencies.database import get_db
from models.user import User
from models.transaction import Transaction

def verify_transaction_ownership(
    transaction_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> Transaction:
    """éªŒè¯äº¤æ˜“æ‰€æœ‰æƒ"""
    transaction = db.get(Transaction, transaction_id)

    if not transaction:
        raise HTTPException(status_code=404, detail="äº¤æ˜“ä¸å­˜åœ¨")

    if transaction.user_id != current_user.id and not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="æ— æƒè®¿é—®æ­¤èµ„æº"
        )

    return transaction
```

## ğŸ“ ç»ƒä¹ ä»»åŠ¡

1. **å®ç°é‚®ç®±éªŒè¯** - æ³¨å†Œæ—¶å‘é€éªŒè¯é‚®ä»¶
2. **å®ç°å¯†ç é‡ç½®** - å‘é€é‡ç½®é“¾æ¥
3. **æ·»åŠ ç™»å½•æ—¥å¿—** - è®°å½•ç™»å½•æ—¶é—´ã€IP

## âœ… æ£€æŸ¥ç‚¹

- [ ] ç†è§£è®¤è¯ä¸æˆæƒçš„åŒºåˆ«
- [ ] å®ç° JWT è®¤è¯ç³»ç»Ÿ
- [ ] æŒæ¡å¯†ç åŠ å¯†å­˜å‚¨
- [ ] å®ç°åŸºäºè§’è‰²çš„æƒé™æ§åˆ¶
- [ ] å®ç°èµ„æºæ‰€æœ‰æƒæ£€æŸ¥

---

**ä¸Šä¸€ç« **ï¼š[03-æ•°æ®åº“ä¸ORM/04-å®Œæ•´CRUDå®ç°.md](../03-æ•°æ®åº“ä¸ORM/04-å®Œæ•´CRUDå®ç°.md)

**ä¸‹ä¸€ç« **ï¼š[02-æ€§èƒ½ä¼˜åŒ–å®è·µ.md](./02-æ€§èƒ½ä¼˜åŒ–å®è·µ.md)
